{"idx": 0, "db_id": "cordis", "query": "Find the total cost of the project Theseus", "evidence": "", "extracted_schema": {"projects": ["unics_id", "title", "total_cost", "ec_max_contribution", "start_date", "end_date"], "institutions": "drop_all", "countries": "drop_all", "activity_types": "drop_all", "ec_framework_programs": "drop_all", "erc_panels": "drop_all", "erc_research_domains": "drop_all", "eu_territorial_units": "drop_all", "funding_schemes": "drop_all", "people": "drop_all", "programmes": "drop_all", "project_erc_panels": "drop_all", "project_member_roles": "drop_all", "project_members": "drop_all", "project_programmes": "drop_all", "project_subject_areas": "drop_all", "project_topics": "drop_all", "subject_areas": "drop_all", "topics": "drop_all"}, "ground_truth": "SELECT T1.total_cost FROM projects AS T1 WHERE T1.title = 'Theseus'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "title", "ec_fund_scheme", "start_date", "end_date", "total_cost", "ec_max_contribution", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT total_cost \nFROM projects \nWHERE title = 'Theseus';", "qa_pairs": "To find the total cost of the project named \"Theseus\", you can use the following SQL query:\n\n```sql\nSELECT total_cost \nFROM projects \nWHERE title = 'Theseus';\n```\n\nThis query selects the `total_cost` from the `projects` table where the `title` of the project matches \"Theseus\".", "fixed": false, "try_times": 1, "pred": "SELECT total_cost \nFROM projects \nWHERE title = 'Theseus';"}
{"idx": 1, "db_id": "cordis", "query": "Show total cost of project with title Theseus", "evidence": "", "extracted_schema": {"projects": ["unics_id", "title", "total_cost", "ec_max_contribution", "start_date", "end_date"], "funding_schemes": "drop_all", "institutions": "drop_all"}, "ground_truth": "SELECT T1.total_cost FROM projects AS T1 WHERE T1.title = 'Theseus'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "title", "ec_fund_scheme", "start_date", "end_date", "total_cost", "ec_max_contribution", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT total_cost FROM projects WHERE title = 'Theseus'", "qa_pairs": "```sql\nSELECT total_cost FROM projects WHERE title = 'Theseus'\n```", "fixed": false, "try_times": 1, "pred": "SELECT total_cost FROM projects WHERE title = 'Theseus'"}
{"idx": 2, "db_id": "cordis", "query": "Show me the acronyms of projects that started in 2018", "evidence": "", "extracted_schema": {"projects": "keep_all", "project_members": "drop_all", "project_programmes": "drop_all", "project_topics": "drop_all", "project_subject_areas": "drop_all"}, "ground_truth": "SELECT acronym FROM projects WHERE start_year = 2018", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT acronym FROM projects WHERE start_year = 2018", "qa_pairs": "```sql\nSELECT acronym FROM projects WHERE start_year = 2018\n```", "fixed": false, "try_times": 1, "pred": "SELECT acronym FROM projects WHERE start_year = 2018"}
{"idx": 3, "db_id": "cordis", "query": "Get acronyms of projects beginning in 2018", "evidence": "", "extracted_schema": {"projects": "keep_all", "project_members": "drop_all", "project_programmes": "drop_all", "project_topics": "drop_all", "project_subject_areas": "drop_all", "project_erc_panels": "drop_all"}, "ground_truth": "SELECT acronym FROM projects WHERE start_year = 2018", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT acronym FROM projects WHERE start_year = 2018", "qa_pairs": "```sql\nSELECT acronym FROM projects WHERE start_year = 2018\n```", "fixed": false, "try_times": 1, "pred": "SELECT acronym FROM projects WHERE start_year = 2018"}
{"idx": 4, "db_id": "cordis", "query": "Show me the titles of projects that started before 2016", "evidence": "", "extracted_schema": {"projects": ["unics_id", "title", "start_date", "end_date", "ec_call", "ec_max_contribution"], "programmes": "drop_all", "institutions": "drop_all", "countries": "drop_all", "activity_types": "drop_all", "erc_panels": "drop_all", "erc_research_domains": "drop_all", "eu_territorial_units": "drop_all", "funding_schemes": "drop_all", "people": "drop_all", "project_member_roles": "drop_all", "project_members": "drop_all", "project_programmes": "drop_all", "project_subject_areas": "drop_all", "project_topics": "drop_all", "subject_areas": "drop_all", "topics": "drop_all", "ec_framework_programs": "drop_all"}, "ground_truth": "SELECT title FROM projects WHERE start_year < 2016", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "title", "ec_call", "ec_fund_scheme", "start_date", "end_date", "ec_max_contribution", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT title FROM projects WHERE start_date < '2016-01-01'", "qa_pairs": "```sql\nSELECT title FROM projects WHERE start_date < '2016-01-01'\n```", "fixed": false, "try_times": 1, "pred": "SELECT title FROM projects WHERE start_date < '2016-01-01'"}
{"idx": 5, "db_id": "cordis", "query": "Find titles of projects which started earlier than 2016", "evidence": "", "extracted_schema": {"projects": ["unics_id", "title", "start_date", "end_date", "ec_call", "ec_max_contribution"], "programmes": "drop_all", "institutions": "drop_all", "countries": "drop_all", "activity_types": "drop_all", "erc_panels": "drop_all", "erc_research_domains": "drop_all", "eu_territorial_units": "drop_all", "funding_schemes": "drop_all", "people": "drop_all", "project_member_roles": "drop_all", "project_members": "drop_all", "project_programmes": "drop_all", "project_subject_areas": "drop_all", "project_topics": "drop_all", "subject_areas": "drop_all", "topics": "drop_all", "ec_framework_programs": "drop_all"}, "ground_truth": "SELECT title FROM projects WHERE start_year < 2016", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "title", "ec_call", "ec_fund_scheme", "start_date", "end_date", "ec_max_contribution", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT title FROM projects WHERE start_date < '2016-01-01'", "qa_pairs": "```sql\nSELECT title FROM projects WHERE start_date < '2016-01-01'\n```", "fixed": false, "try_times": 1, "pred": "SELECT title FROM projects WHERE start_date < '2016-01-01'"}
{"idx": 6, "db_id": "cordis", "query": "Find institutions from the region of Nordjylland", "evidence": "", "extracted_schema": {"institutions": "keep_all", "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "countries": ["unics_id", "country_name", "country_code2", "country_code3"]}, "ground_truth": "SELECT T1.institutions_name FROM institutions AS T1 JOIN eu_territorial_units AS T2 ON T1.geocode_regions_3 = T2.geocode_regions WHERE T2.description = 'Nordjylland'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT institutions.institutions_name\nFROM institutions\nJOIN eu_territorial_units ON institutions.geocode_regions_3 = eu_territorial_units.geocode_regions\nWHERE eu_territorial_units.description = 'Nordjylland';", "qa_pairs": "To find institutions from the region of Nordjylland, we need to identify the corresponding geocode for Nordjylland in the `eu_territorial_units` table. Once we have that, we can join the `institutions` table with the `eu_territorial_units` table to filter the institutions based on the region.\n\nAssuming that \"Nordjylland\" corresponds to a specific `geocode_regions` value in the `eu_territorial_units` table, the SQL query would look like this:\n\n```sql\nSELECT institutions.institutions_name\nFROM institutions\nJOIN eu_territorial_units ON institutions.geocode_regions_3 = eu_territorial_units.geocode_regions\nWHERE eu_territorial_units.description = 'Nordjylland';\n```\n\nThis query selects the names of institutions located in the Nordjylland region by joining the `institutions` table with the `eu_territorial_units` table based on the region code.", "fixed": false, "try_times": 1, "pred": "SELECT institutions.institutions_name\nFROM institutions\nJOIN eu_territorial_units ON institutions.geocode_regions_3 = eu_territorial_units.geocode_regions\nWHERE eu_territorial_units.description = 'Nordjylland';"}
{"idx": 7, "db_id": "cordis", "query": "Show the name of institutions based in Nordjylland", "evidence": "", "extracted_schema": {"institutions": "keep_all", "countries": "drop_all", "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "project_members": "drop_all"}, "ground_truth": "SELECT T1.institutions_name FROM institutions AS T1 JOIN eu_territorial_units AS T2 ON T1.geocode_regions_3 = T2.geocode_regions WHERE T2.description = 'Nordjylland'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT institutions.institutions_name \nFROM institutions \nJOIN eu_territorial_units ON institutions.geocode_regions_3 = eu_territorial_units.geocode_regions \nWHERE eu_territorial_units.description = 'Nordjylland';", "qa_pairs": "To retrieve the names of institutions based in Nordjylland, we need to join the `institutions` table with the `eu_territorial_units` table to filter by the specific region. The `geocode_regions_3` in the `institutions` table should match the `geocode_regions` in the `eu_territorial_units` table where the description corresponds to \"Nordjylland\".\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT institutions.institutions_name \nFROM institutions \nJOIN eu_territorial_units ON institutions.geocode_regions_3 = eu_territorial_units.geocode_regions \nWHERE eu_territorial_units.description = 'Nordjylland';\n```\n\nThis query selects the names of institutions that are located in the Nordjylland region by performing an inner join between the `institutions` and `eu_territorial_units` tables based on the matching geocode regions.", "fixed": false, "try_times": 1, "pred": "SELECT institutions.institutions_name \nFROM institutions \nJOIN eu_territorial_units ON institutions.geocode_regions_3 = eu_territorial_units.geocode_regions \nWHERE eu_territorial_units.description = 'Nordjylland';"}
{"idx": 8, "db_id": "cordis", "query": "Find the name of principal investigators in projects that started in 2014", "evidence": "", "extracted_schema": {"projects": ["unics_id", "principal_investigator", "start_year", "start_date", "end_date", "title"], "people": ["unics_id", "full_name"], "institutions": "drop_all"}, "ground_truth": "SELECT T2.full_name FROM projects AS T1 join people as T2 on T1.principal_investigator = T2.unics_id WHERE T1.start_year = 2014", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "title", "ec_fund_scheme", "start_date", "end_date", "start_year", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT p.full_name \nFROM people AS p \nJOIN projects AS pr ON p.unics_id = pr.principal_investigator \nWHERE pr.start_year = 2014;", "qa_pairs": "```sql\nSELECT p.full_name \nFROM people AS p \nJOIN projects AS pr ON p.unics_id = pr.principal_investigator \nWHERE pr.start_year = 2014;\n```", "fixed": false, "try_times": 1, "pred": "SELECT p.full_name \nFROM people AS p \nJOIN projects AS pr ON p.unics_id = pr.principal_investigator \nWHERE pr.start_year = 2014;"}
{"idx": 9, "db_id": "cordis", "query": "Show the full name of people being investigators in projects that began in 2014", "evidence": "", "extracted_schema": {"people": "keep_all", "projects": ["unics_id", "title", "start_date", "end_date", "start_year", "end_year"], "project_members": ["unics_id", "project", "member_name", "member_role", "institution_id", "activity_type"]}, "ground_truth": "SELECT T2.full_name FROM projects AS T1 join people as T2 on T1.principal_investigator = T2.unics_id WHERE T1.start_year = 2014", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "member_name", "activity_type", "institution_id", "member_role", "geocode_regions_3"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "title", "ec_fund_scheme", "start_date", "end_date", "start_year", "end_year", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT p.full_name \nFROM people AS p \nJOIN projects AS pr ON p.unics_id = pr.principal_investigator \nWHERE pr.start_year = 2014;", "qa_pairs": "```sql\nSELECT p.full_name \nFROM people AS p \nJOIN projects AS pr ON p.unics_id = pr.principal_investigator \nWHERE pr.start_year = 2014;\n```", "fixed": false, "try_times": 1, "pred": "SELECT p.full_name \nFROM people AS p \nJOIN projects AS pr ON p.unics_id = pr.principal_investigator \nWHERE pr.start_year = 2014;"}
{"idx": 10, "db_id": "cordis", "query": "Find projects whose subject area is “Mathematics and Statistics”", "evidence": "", "extracted_schema": {"projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "project_subject_areas": ["project", "subject_area"], "subject_areas": ["code", "title", "description"]}, "ground_truth": "SELECT t1.title FROM projects AS T1 join project_subject_areas as psa on T1.unics_id = psa.project join subject_areas as sa on psa.subject_area = sa.code WHERE sa.title = 'Mathematics and Statistics'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT p.*\nFROM projects AS p\nJOIN project_subject_areas AS psa ON p.unics_id = psa.project\nJOIN subject_areas AS sa ON psa.subject_area = sa.code\nWHERE sa.title = 'Mathematics and Statistics';", "qa_pairs": "To find projects whose subject area is \"Mathematics and Statistics\", you will need to join the `projects` table with the `project_subject_areas` table and the `subject_areas` table. The `subject_areas` table contains the title of the subject areas, and you will filter for the specific subject area \"Mathematics and Statistics\".\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT p.*\nFROM projects AS p\nJOIN project_subject_areas AS psa ON p.unics_id = psa.project\nJOIN subject_areas AS sa ON psa.subject_area = sa.code\nWHERE sa.title = 'Mathematics and Statistics';\n```\n\nThis query selects all columns from the `projects` table where the associated subject area is \"Mathematics and Statistics\".", "fixed": true, "try_times": 2, "pred": "SELECT p.unics_id, p.acronym, p.title\nFROM projects AS p\nJOIN project_subject_areas AS psa ON p.unics_id = psa.project\nJOIN subject_areas AS sa ON psa.subject_area = sa.code\nWHERE sa.title = 'Mathematics and Statistics'\nAND psa.subject_area IS NOT NULL\nAND p.unics_id IS NOT NULL;"}
{"idx": 11, "db_id": "cordis", "query": "Show the acronym and subject area description of projects with subject area “Mathematics and Statistics”", "evidence": "", "extracted_schema": {"projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "start_date"], "subject_areas": ["code", "title", "description", "description"], "project_subject_areas": ["project", "subject_area"]}, "ground_truth": "SELECT t1.acronym, sa.description FROM projects AS T1 join project_subject_areas as psa on T1.unics_id = psa.project join subject_areas as sa on psa.subject_area = sa.code WHERE sa.title = 'Mathematics and Statistics'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "start_date", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT p.acronym, sa.description \nFROM projects AS p \nJOIN project_subject_areas AS psa ON p.unics_id = psa.project \nJOIN subject_areas AS sa ON psa.subject_area = sa.code \nWHERE sa.title = 'Mathematics and Statistics';", "qa_pairs": "To retrieve the acronym and subject area description of projects with the subject area \"Mathematics and Statistics\", you will need to join the `projects`, `project_subject_areas`, and `subject_areas` tables. Here is the corresponding SQL query:\n\n```sql\nSELECT p.acronym, sa.description \nFROM projects AS p \nJOIN project_subject_areas AS psa ON p.unics_id = psa.project \nJOIN subject_areas AS sa ON psa.subject_area = sa.code \nWHERE sa.title = 'Mathematics and Statistics';\n```\n\nThis query selects the acronym from the `projects` table and the description from the `subject_areas` table, filtering for projects that are associated with the subject area \"Mathematics and Statistics\".", "fixed": false, "try_times": 1, "pred": "SELECT p.acronym, sa.description \nFROM projects AS p \nJOIN project_subject_areas AS psa ON p.unics_id = psa.project \nJOIN subject_areas AS sa ON psa.subject_area = sa.code \nWHERE sa.title = 'Mathematics and Statistics';"}
{"idx": 12, "db_id": "cordis", "query": "Find all different topics of projects that ended in 2014", "evidence": "", "extracted_schema": {"projects": ["unics_id", "acronym", "title", "end_year", "start_year", "ec_fund_scheme"], "project_topics": ["project", "topic"], "topics": ["code", "rcn", "title"]}, "ground_truth": "SELECT distinct t.title FROM projects AS T1 join project_topics as pt on T1.unics_id = pt.project join topics as t on pt.topic = t.code where t1.end_year = 2014", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_fund_scheme", "start_year", "end_year", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT DISTINCT T2.topic \nFROM projects AS T1 \nJOIN project_topics AS T2 ON T1.unics_id = T2.project \nWHERE T1.end_year = 2014;", "qa_pairs": "To find all different topics of projects that ended in 2014, you will need to join the `projects` table with the `project_topics` table. You will filter the results based on the `end_year` of the projects. Here's the SQL query to achieve that:\n\n```sql\nSELECT DISTINCT T2.topic \nFROM projects AS T1 \nJOIN project_topics AS T2 ON T1.unics_id = T2.project \nWHERE T1.end_year = 2014;\n```\n\nThis query selects distinct topics from the `project_topics` table for projects that have an `end_year` of 2014.", "fixed": false, "try_times": 1, "pred": "SELECT DISTINCT T2.topic \nFROM projects AS T1 \nJOIN project_topics AS T2 ON T1.unics_id = T2.project \nWHERE T1.end_year = 2014;"}
{"idx": 13, "db_id": "cordis", "query": "Find distinct titles of topics of projects that with end year 2014", "evidence": "", "extracted_schema": {"topics": "keep_all", "projects": ["unics_id", "title", "end_year", "start_year", "ec_call", "ec_max_contribution"], "project_topics": ["project", "topic"]}, "ground_truth": "SELECT distinct t.title FROM projects AS T1 join project_topics as pt on T1.unics_id = pt.project join topics as t on pt.topic = t.code where t1.end_year = 2014", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "title", "ec_call", "ec_fund_scheme", "start_year", "end_year", "ec_max_contribution", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT DISTINCT t.title \nFROM topics AS t \nJOIN project_topics AS pt ON t.code = pt.topic \nJOIN projects AS p ON pt.project = p.unics_id \nWHERE p.end_year = 2014;", "qa_pairs": "```sql\nSELECT DISTINCT t.title \nFROM topics AS t \nJOIN project_topics AS pt ON t.code = pt.topic \nJOIN projects AS p ON pt.project = p.unics_id \nWHERE p.end_year = 2014;\n```", "fixed": false, "try_times": 1, "pred": "SELECT DISTINCT t.title \nFROM topics AS t \nJOIN project_topics AS pt ON t.code = pt.topic \nJOIN projects AS p ON pt.project = p.unics_id \nWHERE p.end_year = 2014;"}
{"idx": 14, "db_id": "cordis", "query": "Show the acronym of projects with a member from Greece", "evidence": "", "extracted_schema": {"project_members": "keep_all", "projects": "keep_all", "institutions": "drop_all", "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "project_programmes": "drop_all", "project_subject_areas": "drop_all"}, "ground_truth": "Select p.acronym from projects as p join project_members as pm on p.unics_id = pm.project join institutions as i on pm.institution_id = i.unics_id join countries as c on i.country_id = c.unics_id where c.country_name = 'Greece'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT DISTINCT p.acronym \nFROM projects AS p \nJOIN project_members AS pm ON p.unics_id = pm.project \nWHERE pm.country = 'GR';", "qa_pairs": "To retrieve the acronym of projects that have a member from Greece, we need to join the `projects` table with the `project_members` table, filtering for members whose country is Greece (represented by the country code 'GR'). Here’s the SQL query that accomplishes this:\n\n```sql\nSELECT DISTINCT p.acronym \nFROM projects AS p \nJOIN project_members AS pm ON p.unics_id = pm.project \nWHERE pm.country = 'GR';\n```\n\nThis query selects distinct acronyms from the `projects` table where there is a corresponding entry in the `project_members` table for members from Greece.", "fixed": false, "try_times": 1, "pred": "SELECT DISTINCT p.acronym \nFROM projects AS p \nJOIN project_members AS pm ON p.unics_id = pm.project \nWHERE pm.country = 'GR';"}
{"idx": 15, "db_id": "cordis", "query": "Show names of institutions from France or Germany", "evidence": "", "extracted_schema": {"institutions": "keep_all", "countries": "keep_all", "project_members": "drop_all", "projects": "drop_all"}, "ground_truth": "Select i.institutions_name from institutions as i join countries as c on i.country_id = c.unics_id where c.country_name = 'France' or c.country_name = 'Germany'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT institutions_name \nFROM institutions \nJOIN countries ON institutions.country_id = countries.unics_id \nWHERE countries.country_name IN ('France', 'Germany');", "qa_pairs": "```sql\nSELECT institutions_name \nFROM institutions \nJOIN countries ON institutions.country_id = countries.unics_id \nWHERE countries.country_name IN ('France', 'Germany');\n```", "fixed": false, "try_times": 1, "pred": "SELECT institutions_name \nFROM institutions \nJOIN countries ON institutions.country_id = countries.unics_id \nWHERE countries.country_name IN ('France', 'Germany');"}
{"idx": 16, "db_id": "cordis", "query": "Show names of institutions which are not from France", "evidence": "", "extracted_schema": {"institutions": "keep_all", "countries": "keep_all", "project_members": "drop_all", "projects": "drop_all"}, "ground_truth": "Select i.institutions_name from institutions as i join countries as c on i.country_id = c.unics_id where c.country_name != 'France'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT institutions_name \nFROM institutions \nWHERE country_id != (SELECT unics_id FROM countries WHERE country_name = 'France');", "qa_pairs": "```sql\nSELECT institutions_name \nFROM institutions \nWHERE country_id != (SELECT unics_id FROM countries WHERE country_name = 'France');\n```", "fixed": false, "try_times": 1, "pred": "SELECT institutions_name \nFROM institutions \nWHERE country_id != (SELECT unics_id FROM countries WHERE country_name = 'France');"}
{"idx": 17, "db_id": "cordis", "query": "Count the projects that started in 2016", "evidence": "", "extracted_schema": {"projects": "keep_all", "programmes": "drop_all", "project_members": "drop_all", "project_erc_panels": "drop_all", "project_subject_areas": "drop_all", "project_topics": "drop_all"}, "ground_truth": "Select count(p.unics_id) from projects as p where start_year = 2016", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT COUNT(*) FROM projects WHERE start_year = 2016", "qa_pairs": "```sql\nSELECT COUNT(*) FROM projects WHERE start_year = 2016\n```", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(*) FROM projects WHERE start_year = 2016"}
{"idx": 18, "db_id": "cordis", "query": "Show the title of the project with the highest total cost", "evidence": "", "extracted_schema": {"projects": "keep_all", "funding_schemes": "drop_all", "institutions": "drop_all", "countries": "drop_all"}, "ground_truth": "Select p.title from projects as p where total_cost = (select max(p2.total_cost) from projects as p2)", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT title FROM projects ORDER BY total_cost DESC LIMIT 1", "qa_pairs": "```sql\nSELECT title FROM projects ORDER BY total_cost DESC LIMIT 1\n```", "fixed": false, "try_times": 1, "pred": "SELECT title FROM projects ORDER BY total_cost DESC LIMIT 1"}
{"idx": 19, "db_id": "cordis", "query": "Show the name of members in projects costing less than the average project cost.", "evidence": "", "extracted_schema": {"projects": ["unics_id", "acronym", "title", "total_cost", "ec_max_contribution", "start_date"], "project_members": ["unics_id", "project", "member_name", "institution_id", "member_role", "country"], "institutions": "keep_all"}, "ground_truth": "SELECT T1.member_name FROM project_members AS T1 JOIN projects AS T2 ON T1.project = T2.unics_id WHERE T2.total_cost < (SELECT AVG(T23.total_cost) FROM projects AS T23)", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "member_name", "activity_type", "country", "institution_id", "member_role", "geocode_regions_3"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_fund_scheme", "start_date", "total_cost", "ec_max_contribution", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT pm.member_name \nFROM project_members AS pm \nJOIN projects AS p ON pm.project = p.unics_id \nWHERE p.total_cost < (SELECT AVG(total_cost) FROM projects);", "qa_pairs": "To show the name of members in projects costing less than the average project cost, you can use the following SQL query:\n\n```sql\nSELECT pm.member_name \nFROM project_members AS pm \nJOIN projects AS p ON pm.project = p.unics_id \nWHERE p.total_cost < (SELECT AVG(total_cost) FROM projects);\n```\n\n### Explanation:\n1. **SELECT pm.member_name**: This selects the member names from the `project_members` table.\n2. **FROM project_members AS pm**: This specifies the `project_members` table and gives it an alias `pm`.\n3. **JOIN projects AS p ON pm.project = p.unics_id**: This joins the `project_members` table with the `projects` table on the condition that the project ID in `project_members` matches the unique ID in `projects`.\n4. **WHERE p.total_cost < (SELECT AVG(total_cost) FROM projects)**: This filters the results to include only those members whose associated projects have a total cost less than the average total cost of all projects. The subquery `(SELECT AVG(total_cost) FROM projects)` calculates the average project cost.", "fixed": false, "try_times": 1, "pred": "SELECT pm.member_name \nFROM project_members AS pm \nJOIN projects AS p ON pm.project = p.unics_id \nWHERE p.total_cost < (SELECT AVG(total_cost) FROM projects);"}
{"idx": 20, "db_id": "cordis", "query": "Find the id of projects with at least 100 members", "evidence": "", "extracted_schema": {"projects": ["unics_id", "acronym", "title", "ec_call", "total_cost", "ec_max_contribution"], "project_members": ["project", "unics_id", "member_name", "institution_id", "member_role", "activity_type"], "institutions": ["unics_id", "institutions_name", "country_id", "geocode_regions_3", "website", "acronym"]}, "ground_truth": "select p.unics_id from projects as p join project_members as pm on p.unics_id = pm.project group by p.unics_id having count(p.unics_id) >= 100", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "acronym", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "member_name", "activity_type", "institution_id", "member_role", "geocode_regions_3"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "total_cost", "ec_max_contribution", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT project, COUNT(*) AS member_count\nFROM project_members\nGROUP BY project\nHAVING member_count >= 100;", "qa_pairs": "To find the IDs of projects with at least 100 members, you can use the following SQL query. This query counts the number of members for each project and filters the results to include only those projects that have 100 or more members.\n\n```sql\nSELECT project, COUNT(*) AS member_count\nFROM project_members\nGROUP BY project\nHAVING member_count >= 100;\n```\n\nThis SQL statement does the following:\n- Selects the `project` ID and counts the number of members associated with each project from the `project_members` table.\n- Groups the results by `project` to aggregate the member counts.\n- Uses the `HAVING` clause to filter the results to only include projects with a member count of 100 or more.", "fixed": false, "try_times": 1, "pred": "SELECT project, COUNT(*) AS member_count\nFROM project_members\nGROUP BY project\nHAVING member_count >= 100;"}
{"idx": 21, "db_id": "cordis", "query": "Find the code and title of the funding scheme which funded the highest number of projects.", "evidence": "", "extracted_schema": {"funding_schemes": "keep_all", "projects": "keep_all", "institutions": "drop_all", "countries": "drop_all", "activity_types": "drop_all", "erc_panels": "drop_all"}, "ground_truth": "select s.code, s.title from funding_schemes as s where s.code = (select s2.code from funding_schemes as s2 join projects as p on s2.code = p.ec_fund_scheme group by s2.code order by count(*) desc LIMIT 1)", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT fs.code, fs.title\nFROM funding_schemes AS fs\nJOIN projects AS p ON fs.code = p.ec_fund_scheme\nGROUP BY fs.code, fs.title\nORDER BY COUNT(p.unics_id) DESC\nLIMIT 1;", "qa_pairs": "To find the code and title of the funding scheme that funded the highest number of projects, you can use the following SQL query. This query will join the `projects` table with the `funding_schemes` table, group the results by the funding scheme code and title, count the number of projects for each funding scheme, and then order the results to find the one with the highest count.\n\nHere is the SQL query:\n\n```sql\nSELECT fs.code, fs.title\nFROM funding_schemes AS fs\nJOIN projects AS p ON fs.code = p.ec_fund_scheme\nGROUP BY fs.code, fs.title\nORDER BY COUNT(p.unics_id) DESC\nLIMIT 1;\n```\n\n### Explanation:\n1. **SELECT fs.code, fs.title**: This selects the code and title of the funding schemes.\n2. **FROM funding_schemes AS fs**: This specifies the `funding_schemes` table as the main table.\n3. **JOIN projects AS p ON fs.code = p.ec_fund_scheme**: This joins the `projects` table on the funding scheme code.\n4. **GROUP BY fs.code, fs.title**: This groups the results by funding scheme code and title.\n5. **ORDER BY COUNT(p.unics_id) DESC**: This orders the results by the count of projects in descending order.\n6. **LIMIT 1**: This limits the results to only the top entry, which is the funding scheme with the highest number of projects.", "fixed": false, "try_times": 1, "pred": "SELECT fs.code, fs.title\nFROM funding_schemes AS fs\nJOIN projects AS p ON fs.code = p.ec_fund_scheme\nGROUP BY fs.code, fs.title\nORDER BY COUNT(p.unics_id) DESC\nLIMIT 1;"}
{"idx": 22, "db_id": "cordis", "query": "Show the total costs of all projects", "evidence": "", "extracted_schema": {"projects": "keep_all", "funding_schemes": "drop_all", "institutions": "drop_all"}, "ground_truth": "SELECT sum(total_cost) FROM projects", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT SUM(total_cost) AS total_costs FROM projects;", "qa_pairs": "```sql\nSELECT SUM(total_cost) AS total_costs FROM projects;\n```", "fixed": false, "try_times": 1, "pred": "SELECT SUM(total_cost) AS total_costs FROM projects;"}
{"idx": 23, "db_id": "cordis", "query": "Show me the title of projects which have an end year and a start year after 2006", "evidence": "", "extracted_schema": {"projects": ["unics_id", "title", "start_year", "end_year", "ec_call", "ec_max_contribution"], "programmes": "drop_all", "project_members": "drop_all"}, "ground_truth": "select title from projects where start_year > 2006 and end_year > 2006", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "title", "ec_call", "ec_fund_scheme", "start_year", "end_year", "ec_max_contribution", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT title FROM projects WHERE start_year > 2006 AND end_year IS NOT NULL;", "qa_pairs": "```sql\nSELECT title FROM projects WHERE start_year > 2006 AND end_year IS NOT NULL;\n```", "fixed": false, "try_times": 1, "pred": "SELECT title FROM projects WHERE start_year > 2006 AND end_year IS NOT NULL;"}
{"idx": 24, "db_id": "cordis", "query": "Find the projects which lasted the longest and have an end year and a start year", "evidence": "", "extracted_schema": {"projects": "keep_all", "project_members": "drop_all", "programmes": "drop_all", "institutions": "drop_all"}, "ground_truth": "select title, end_year - start_year from projects order by end_year - start_year desc limit 1", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT * \nFROM projects \nWHERE start_year IS NOT NULL \n  AND end_year IS NOT NULL \nORDER BY (end_year - start_year) DESC \nLIMIT 1;", "qa_pairs": "To find the projects that lasted the longest and have both an end year and a start year, you can calculate the duration of each project by subtracting the start year from the end year. Then, you can select the projects with the maximum duration. Here's the SQL query to achieve that:\n\n```sql\nSELECT * \nFROM projects \nWHERE start_year IS NOT NULL \n  AND end_year IS NOT NULL \nORDER BY (end_year - start_year) DESC \nLIMIT 1;\n```\n\nThis query selects all columns from the `projects` table where both `start_year` and `end_year` are not null, orders the results by the duration (end year minus start year) in descending order, and limits the result to the top project with the longest duration.", "fixed": true, "try_times": 2, "pred": "-- SQL Type: SELECT\nSELECT unics_id, title, start_year, end_year \nFROM projects \nWHERE start_year IS NOT NULL \n  AND end_year IS NOT NULL \nORDER BY (end_year - start_year) DESC \nLIMIT 1;"}
{"idx": 25, "db_id": "cordis", "query": "Show me topic titles which starts with 'Raw materials'", "evidence": "", "extracted_schema": {"topics": "keep_all", "projects": "drop_all", "activity_types": "drop_all", "countries": "drop_all", "institutions": "drop_all", "programmes": "drop_all"}, "ground_truth": "select title from topics where title like 'Raw materials%'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT title FROM topics WHERE title LIKE 'Raw materials%'", "qa_pairs": "```sql\nSELECT title FROM topics WHERE title LIKE 'Raw materials%'\n```", "fixed": false, "try_times": 1, "pred": "SELECT title FROM topics WHERE title LIKE 'Raw materials%'"}
{"idx": 26, "db_id": "cordis", "query": "Show me topic titles which contain the word 'climate'", "evidence": "", "extracted_schema": {"topics": "keep_all", "projects": "drop_all", "activity_types": "drop_all", "countries": "drop_all", "ec_framework_programs": "drop_all", "erc_panels": "drop_all", "erc_research_domains": "drop_all", "eu_territorial_units": "drop_all", "funding_schemes": "drop_all", "institutions": "drop_all", "people": "drop_all", "programmes": "drop_all", "project_erc_panels": "drop_all", "project_member_roles": "drop_all", "project_members": "drop_all", "project_programmes": "drop_all", "project_subject_areas": "drop_all", "project_topics": "drop_all", "subject_areas": "drop_all"}, "ground_truth": "select title from topics where title like '%climate%'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT title FROM topics WHERE title LIKE '%climate%'", "qa_pairs": "```sql\nSELECT title FROM topics WHERE title LIKE '%climate%'\n```", "fixed": false, "try_times": 1, "pred": "SELECT title FROM topics WHERE title LIKE '%climate%'"}
{"idx": 27, "db_id": "cordis", "query": "Show me the number of projects where Thomas Bell was principal investigator", "evidence": "", "extracted_schema": {"projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "principal_investigator"], "people": ["unics_id", "full_name"], "project_members": ["unics_id", "project", "member_name", "member_role", "institution_id", "activity_type"]}, "ground_truth": "select count(*) from projects as p join people as peep on p.principal_investigator = peep.unics_id where peep.full_name = 'Thomas Bell'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "member_name", "activity_type", "institution_id", "member_role", "geocode_regions_3"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT COUNT(*) \nFROM projects \nWHERE principal_investigator = (SELECT unics_id FROM people WHERE full_name = 'Thomas Bell');", "qa_pairs": "To find the number of projects where Thomas Bell was the principal investigator, we need to join the `projects` table with the `people` table to filter for the specific person. Then, we can count the number of projects associated with that individual.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT COUNT(*) \nFROM projects \nWHERE principal_investigator = (SELECT unics_id FROM people WHERE full_name = 'Thomas Bell');\n```\n\nThis query counts all the projects in the `projects` table where the `principal_investigator` matches the `unics_id` of Thomas Bell from the `people` table.", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(*) \nFROM projects \nWHERE principal_investigator = (SELECT unics_id FROM people WHERE full_name = 'Thomas Bell');"}
{"idx": 28, "db_id": "cordis", "query": "Show me the all different names of people", "evidence": "", "extracted_schema": {"people": "keep_all", "countries": "drop_all", "institutions": "drop_all", "projects": "drop_all", "activity_types": "drop_all", "programmes": "drop_all"}, "ground_truth": "select distinct full_name from people", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT DISTINCT full_name FROM people;", "qa_pairs": "```sql\nSELECT DISTINCT full_name FROM people;\n```", "fixed": false, "try_times": 1, "pred": "SELECT DISTINCT full_name FROM people;"}
{"idx": 29, "db_id": "cordis", "query": "Find the acronym of projects which have total costs between 100000 and 200000", "evidence": "", "extracted_schema": {"projects": "keep_all", "funding_schemes": "drop_all", "institutions": "drop_all", "countries": "drop_all"}, "ground_truth": "select p.acronym from projects as p where p.total_cost between 100000 and 200000", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT acronym FROM projects WHERE total_cost BETWEEN 100000 AND 200000", "qa_pairs": "```sql\nSELECT acronym FROM projects WHERE total_cost BETWEEN 100000 AND 200000\n```", "fixed": false, "try_times": 1, "pred": "SELECT acronym FROM projects WHERE total_cost BETWEEN 100000 AND 200000"}
{"idx": 30, "db_id": "cordis", "query": "Show the title of projects with costs higher than 1000000", "evidence": "", "extracted_schema": {"projects": ["unics_id", "title", "total_cost", "ec_max_contribution", "start_date", "end_date"], "funding_schemes": "drop_all", "institutions": "drop_all"}, "ground_truth": "select p.title from projects as p where p.total_cost > 1000000", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "title", "ec_fund_scheme", "start_date", "end_date", "total_cost", "ec_max_contribution", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT title FROM projects WHERE total_cost > 1000000", "qa_pairs": "```sql\nSELECT title FROM projects WHERE total_cost > 1000000\n```", "fixed": false, "try_times": 1, "pred": "SELECT title FROM projects WHERE total_cost > 1000000"}
{"idx": 31, "db_id": "cordis", "query": "Show the title of projects with costs higher than a million", "evidence": "", "extracted_schema": {"projects": ["unics_id", "title", "total_cost", "ec_max_contribution", "start_date", "end_date"], "funding_schemes": "drop_all", "institutions": "drop_all"}, "ground_truth": "select p.title from projects as p where p.total_cost > 1000000", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "title", "ec_fund_scheme", "start_date", "end_date", "total_cost", "ec_max_contribution", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT title FROM projects WHERE total_cost > 1000000", "qa_pairs": "```sql\nSELECT title FROM projects WHERE total_cost > 1000000\n```", "fixed": false, "try_times": 1, "pred": "SELECT title FROM projects WHERE total_cost > 1000000"}
{"idx": 32, "db_id": "cordis", "query": "Show the project title and member name where the member has a partner role ", "evidence": "", "extracted_schema": {"project_members": "keep_all", "projects": "keep_all", "project_member_roles": "keep_all"}, "ground_truth": "select title, member_name from projects as p join project_members as pm on p.unics_id = pm.project join project_member_roles as pmr on pm.member_role = pmr.code where pmr.code = 'partner'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT projects.title, project_members.member_name \nFROM projects \nJOIN project_members ON projects.unics_id = project_members.project \nWHERE project_members.member_role = 'Partner'", "qa_pairs": "```sql\nSELECT projects.title, project_members.member_name \nFROM projects \nJOIN project_members ON projects.unics_id = project_members.project \nWHERE project_members.member_role = 'Partner'\n```", "fixed": true, "try_times": 3, "pred": "SELECT projects.title, project_members.member_name \nFROM projects \nJOIN project_members ON projects.unics_id = project_members.project \nWHERE project_members.member_role = 'Partner' \nAND project_members.member_name IS NOT NULL;"}
{"idx": 33, "db_id": "cordis", "query": "What different research domains do exist?", "evidence": "", "extracted_schema": {"erc_research_domains": "keep_all", "erc_panels": "drop_all", "activity_types": "drop_all", "countries": "drop_all", "ec_framework_programs": "drop_all", "eu_territorial_units": "drop_all", "funding_schemes": "drop_all", "institutions": "drop_all", "people": "drop_all", "programmes": "drop_all", "project_erc_panels": "drop_all", "project_member_roles": "drop_all", "project_members": "drop_all", "project_programmes": "drop_all", "project_subject_areas": "drop_all", "project_topics": "drop_all", "projects": "drop_all", "subject_areas": "drop_all", "topics": "drop_all"}, "ground_truth": "select distinct description from erc_research_domains", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT DISTINCT description FROM erc_research_domains;", "qa_pairs": "```sql\nSELECT DISTINCT description FROM erc_research_domains;\n```", "fixed": false, "try_times": 1, "pred": "SELECT DISTINCT description FROM erc_research_domains;"}
{"idx": 34, "db_id": "cordis", "query": "Show me the country name of all institutes.", "evidence": "", "extracted_schema": {"countries": "keep_all", "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "projects": "drop_all", "activity_types": "drop_all"}, "ground_truth": "select c.country_name from countries as c join institutions as i on c.unics_id = i.country_id", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT country_name FROM countries \nJOIN institutions ON countries.unics_id = institutions.country_id;", "qa_pairs": "```sql\nSELECT country_name FROM countries \nJOIN institutions ON countries.unics_id = institutions.country_id;\n```", "fixed": false, "try_times": 1, "pred": "SELECT country_name FROM countries \nJOIN institutions ON countries.unics_id = institutions.country_id;"}
{"idx": 35, "db_id": "cordis", "query": "Show me the country of all institutes.", "evidence": "", "extracted_schema": {"countries": "keep_all", "institutions": "keep_all", "activity_types": "drop_all", "ec_framework_programs": "drop_all", "erc_panels": "drop_all", "erc_research_domains": "drop_all", "eu_territorial_units": "drop_all", "funding_schemes": "drop_all", "people": "drop_all", "programmes": "drop_all", "project_erc_panels": "drop_all", "project_member_roles": "drop_all", "project_members": "drop_all", "project_programmes": "drop_all", "project_subject_areas": "drop_all", "project_topics": "drop_all", "projects": "drop_all", "subject_areas": "drop_all", "topics": "drop_all"}, "ground_truth": "select c.country_name from countries as c join institutions as i on c.unics_id = i.country_id", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT DISTINCT countries.country_name \nFROM institutions \nJOIN countries ON institutions.country_id = countries.unics_id;", "qa_pairs": "```sql\nSELECT DISTINCT countries.country_name \nFROM institutions \nJOIN countries ON institutions.country_id = countries.unics_id;\n```", "fixed": false, "try_times": 1, "pred": "SELECT DISTINCT countries.country_name \nFROM institutions \nJOIN countries ON institutions.country_id = countries.unics_id;"}
{"idx": 36, "db_id": "cordis", "query": "What is the country code 2 and country code 3 for Andorra?", "evidence": "", "extracted_schema": {"countries": "keep_all", "activity_types": "drop_all", "ec_framework_programs": "drop_all", "erc_panels": "drop_all", "erc_research_domains": "drop_all", "eu_territorial_units": "drop_all", "funding_schemes": "drop_all", "institutions": "drop_all", "people": "drop_all", "programmes": "drop_all", "project_erc_panels": "drop_all", "project_member_roles": "drop_all", "project_members": "drop_all", "project_programmes": "drop_all", "project_subject_areas": "drop_all", "project_topics": "drop_all", "projects": "drop_all", "subject_areas": "drop_all", "topics": "drop_all"}, "ground_truth": "select country_code2, country_code3 from countries where country_name = 'Andorra'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT country_code2, country_code3 FROM countries WHERE country_name = 'Andorra'", "qa_pairs": "```sql\nSELECT country_code2, country_code3 FROM countries WHERE country_name = 'Andorra'\n```", "fixed": false, "try_times": 1, "pred": "SELECT country_code2, country_code3 FROM countries WHERE country_name = 'Andorra'"}
{"idx": 37, "db_id": "cordis", "query": "Find the code of the funding scheme for Framework Partnership Agreement", "evidence": "", "extracted_schema": {"funding_schemes": "keep_all", "ec_framework_programs": "keep_all", "projects": "drop_all", "activity_types": "drop_all", "countries": "drop_all", "institutions": "drop_all", "people": "drop_all", "programmes": "drop_all", "project_erc_panels": "drop_all", "project_member_roles": "drop_all", "project_members": "drop_all", "project_programmes": "drop_all", "project_subject_areas": "drop_all", "project_topics": "drop_all", "topics": "drop_all", "erc_panels": "drop_all", "erc_research_domains": "drop_all", "eu_territorial_units": "drop_all", "subject_areas": "drop_all"}, "ground_truth": "select code from funding_schemes where title = 'Framework Partnership Agreement'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT code FROM funding_schemes WHERE title = 'Framework Partnership Agreement'", "qa_pairs": "```sql\nSELECT code FROM funding_schemes WHERE title = 'Framework Partnership Agreement'\n```", "fixed": false, "try_times": 1, "pred": "SELECT code FROM funding_schemes WHERE title = 'Framework Partnership Agreement'"}
{"idx": 38, "db_id": "cordis", "query": "Show me the full title of the program which is called 'Transport' in short.", "evidence": "", "extracted_schema": {"programmes": "keep_all", "projects": "drop_all", "institutions": "drop_all", "countries": "drop_all", "activity_types": "drop_all", "erc_panels": "drop_all"}, "ground_truth": "select title from programmes where short_name = 'Transport'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT title FROM programmes WHERE short_name = 'Transport';", "qa_pairs": "To retrieve the full title of the program that has a short name of 'Transport', you can use the following SQL query. This assumes that the short name is stored in the `programmes` table.\n\n```sql\nSELECT title FROM programmes WHERE short_name = 'Transport';\n```\n\nThis query selects the `title` from the `programmes` table where the `short_name` matches 'Transport'.", "fixed": false, "try_times": 1, "pred": "SELECT title FROM programmes WHERE short_name = 'Transport';"}
{"idx": 39, "db_id": "cordis", "query": "Find member name and role code of project members in project with acronym GTBB", "evidence": "", "extracted_schema": {"project_members": "keep_all", "projects": "keep_all", "institutions": "drop_all"}, "ground_truth": "select pm.member_name, pr.code from project_members as pm join projects as p on pm.project = p.unics_id join project_member_roles as pr on pm.member_role = pr.code where p.acronym = 'GTBB'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT pm.member_name, pm.member_role\nFROM project_members AS pm\nJOIN projects AS p ON pm.project = p.unics_id\nWHERE p.acronym = 'GTBB';", "qa_pairs": "To find the member name and role code of project members in the project with the acronym \"GTBB\", you will need to join the `project_members` table with the `projects` table based on the project identifier. Here's the SQL query that accomplishes this:\n\n```sql\nSELECT pm.member_name, pm.member_role\nFROM project_members AS pm\nJOIN projects AS p ON pm.project = p.unics_id\nWHERE p.acronym = 'GTBB';\n```\n\nThis query selects the `member_name` and `member_role` from the `project_members` table, joining it with the `projects` table to filter for the project with the acronym \"GTBB\".", "fixed": false, "try_times": 1, "pred": "SELECT pm.member_name, pm.member_role\nFROM project_members AS pm\nJOIN projects AS p ON pm.project = p.unics_id\nWHERE p.acronym = 'GTBB';"}
{"idx": 40, "db_id": "cordis", "query": "Find member name and role code of project members in project GTBB", "evidence": "", "extracted_schema": {"project_members": "keep_all", "projects": "keep_all", "project_member_roles": "keep_all", "institutions": "drop_all"}, "ground_truth": "select pm.member_name, pr.code from project_members as pm join projects as p on pm.project = p.unics_id join project_member_roles as pr on pm.member_role = pr.code where p.acronym = 'GTBB'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT pm.member_name, pm.member_role \nFROM project_members AS pm \nJOIN projects AS p ON pm.project = p.unics_id \nWHERE p.acronym = 'GTBB';", "qa_pairs": "To find the member name and role code of project members in the project with the acronym \"GTBB\", you can use the following SQL query:\n\n```sql\nSELECT pm.member_name, pm.member_role \nFROM project_members AS pm \nJOIN projects AS p ON pm.project = p.unics_id \nWHERE p.acronym = 'GTBB';\n```\n\nThis query joins the `project_members` table with the `projects` table on the project ID, filtering for the project with the acronym \"GTBB\" to retrieve the desired member names and their corresponding role codes.", "fixed": false, "try_times": 1, "pred": "SELECT pm.member_name, pm.member_role \nFROM project_members AS pm \nJOIN projects AS p ON pm.project = p.unics_id \nWHERE p.acronym = 'GTBB';"}
{"idx": 41, "db_id": "cordis", "query": "Show titles of programmes which have FP7 as parent program", "evidence": "", "extracted_schema": {"programmes": "keep_all", "ec_framework_programs": "drop_all", "projects": "drop_all", "funding_schemes": "drop_all", "institutions": "drop_all", "countries": "drop_all"}, "ground_truth": "select title from programmes where parent = 'FP7'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT title FROM programmes WHERE parent = 'FP7'", "qa_pairs": "```sql\nSELECT title FROM programmes WHERE parent = 'FP7'\n```", "fixed": false, "try_times": 1, "pred": "SELECT title FROM programmes WHERE parent = 'FP7'"}
{"idx": 42, "db_id": "cordis", "query": "Show titles of programmes which have program with code FP7 as parent program", "evidence": "", "extracted_schema": {"programmes": "keep_all", "projects": ["code", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref"], "ec_framework_programs": ["ec_framework_program_name"]}, "ground_truth": "select title from programmes where parent = 'FP7'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT title \nFROM programmes \nWHERE parent = 'FP7';", "qa_pairs": "To retrieve the titles of programmes that have a parent programme with the code 'FP7', you can use the following SQL query:\n\n```sql\nSELECT title \nFROM programmes \nWHERE parent = 'FP7';\n```\n\nThis query selects the `title` from the `programmes` table where the `parent` column matches 'FP7'.", "fixed": false, "try_times": 1, "pred": "SELECT title \nFROM programmes \nWHERE parent = 'FP7';"}
{"idx": 43, "db_id": "cordis", "query": "Get panel descriptions from research domain Life Sciences", "evidence": "", "extracted_schema": {"erc_panels": "keep_all", "erc_research_domains": "keep_all", "project_erc_panels": "drop_all", "activity_types": "drop_all", "countries": "drop_all", "institutions": "drop_all", "projects": "drop_all"}, "ground_truth": "select p.description from erc_panels as p join erc_research_domains as erd on p.part_of = erd.code where erd.description = 'Life Sciences'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT ep.description \nFROM erc_panels AS ep \nJOIN erc_research_domains AS erd ON ep.part_of = erd.code \nWHERE erd.description = 'Life Sciences';", "qa_pairs": "To retrieve panel descriptions from the research domain \"Life Sciences,\" you will need to join the `erc_panels` and `erc_research_domains` tables based on the foreign key relationship. The SQL query will filter the results to only include those panels that are part of the \"Life Sciences\" research domain.\n\nHere is the SQL query:\n\n```sql\nSELECT ep.description \nFROM erc_panels AS ep \nJOIN erc_research_domains AS erd ON ep.part_of = erd.code \nWHERE erd.description = 'Life Sciences';\n```\n\nThis query selects the `description` from the `erc_panels` table where the corresponding `description` in the `erc_research_domains` table matches \"Life Sciences.\"", "fixed": false, "try_times": 1, "pred": "SELECT ep.description \nFROM erc_panels AS ep \nJOIN erc_research_domains AS erd ON ep.part_of = erd.code \nWHERE erd.description = 'Life Sciences';"}
{"idx": 44, "db_id": "cordis", "query": "Get panel descriptions from research domain life sciences", "evidence": "", "extracted_schema": {"erc_panels": "keep_all", "erc_research_domains": ["code", "description"], "project_erc_panels": "drop_all"}, "ground_truth": "select p.description from erc_panels as p join erc_research_domains as erd on p.part_of = erd.code where erd.description = 'Life Sciences'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT ep.description \nFROM erc_panels AS ep \nJOIN erc_research_domains AS erd ON ep.part_of = erd.code \nWHERE erd.description = 'Life Sciences';", "qa_pairs": "To retrieve panel descriptions from the research domain \"Life Sciences,\" you will need to join the `erc_panels` table with the `erc_research_domains` table based on the `part_of` foreign key. You will then filter the results to only include those that belong to the \"Life Sciences\" research domain.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT ep.description \nFROM erc_panels AS ep \nJOIN erc_research_domains AS erd ON ep.part_of = erd.code \nWHERE erd.description = 'Life Sciences';\n```\n\nThis query selects the `description` from the `erc_panels` table where the corresponding research domain is \"Life Sciences.\"", "fixed": false, "try_times": 1, "pred": "SELECT ep.description \nFROM erc_panels AS ep \nJOIN erc_research_domains AS erd ON ep.part_of = erd.code \nWHERE erd.description = 'Life Sciences';"}
{"idx": 45, "db_id": "cordis", "query": "Find project members of type Research Organisations", "evidence": "", "extracted_schema": {"project_members": ["unics_id", "project", "member_name", "activity_type", "institution_id", "member_role"], "project_member_roles": ["code", "description"], "institutions": ["unics_id", "institutions_name", "country_id", "geocode_regions_3", "website", "acronym"]}, "ground_truth": "select member_name from project_members as mb join activity_types as a on a.code = mb.activity_type where a.description = 'Research Organisations'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "acronym", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "member_name", "activity_type", "institution_id", "member_role", "geocode_regions_3"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT pm.*\nFROM project_members AS pm\nJOIN project_member_roles AS pmr ON pm.member_role = pmr.code\nWHERE pmr.description = 'Participant';", "qa_pairs": "To find project members of type \"Research Organisations,\" we need to join the `project_members` table with the `project_member_roles` table to filter for the specific member role that corresponds to \"Research Organisations.\" However, since the provided schema does not explicitly list \"Research Organisations\" as a role, we will assume that it is represented by one of the existing roles in the `project_member_roles` table.\n\nLet's assume that \"Research Organisations\" corresponds to the role \"Participant.\" The SQL query would look like this:\n\n```sql\nSELECT pm.*\nFROM project_members AS pm\nJOIN project_member_roles AS pmr ON pm.member_role = pmr.code\nWHERE pmr.description = 'Participant';\n```\n\nThis query selects all columns from the `project_members` table where the member role matches the description \"Participant\" in the `project_member_roles` table. If \"Research Organisations\" corresponds to a different role, you would replace 'Participant' with the appropriate role description.", "fixed": true, "try_times": 2, "pred": "-- SQL Type: SELECT\nSELECT pm.unics_id, pm.member_name, pm.activity_type, pm.institution_id\nFROM project_members AS pm\nJOIN project_member_roles AS pmr ON pm.member_role = pmr.code\nWHERE pmr.description = 'Participant' AND pm.unics_id IS NOT NULL AND pm.member_name IS NOT NULL AND pm.activity_type IS NOT NULL AND pm.institution_id IS NOT NULL;"}
{"idx": 46, "db_id": "cordis", "query": "Get names of project members who's activity type description is Research Organisations", "evidence": "", "extracted_schema": {"activity_types": ["code", "description"], "project_members": ["unics_id", "project", "member_name", "activity_type", "institution_id", "member_role"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"]}, "ground_truth": "select member_name from project_members as mb join activity_types as a on a.code = mb.activity_type where a.description = 'Research Organisations'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "member_name", "activity_type", "institution_id", "member_role", "geocode_regions_3"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT pm.member_name \nFROM project_members AS pm \nJOIN project_member_roles AS pmr ON pm.member_role = pmr.code \nWHERE pmr.description = 'Research Organisations';", "qa_pairs": "To retrieve the names of project members whose activity type description is \"Research Organisations\", you will need to join the `project_members` table with the `project_member_roles` table to filter based on the activity type description. Here’s the SQL query that accomplishes this:\n\n```sql\nSELECT pm.member_name \nFROM project_members AS pm \nJOIN project_member_roles AS pmr ON pm.member_role = pmr.code \nWHERE pmr.description = 'Research Organisations';\n```\n\nThis query selects the `member_name` from the `project_members` table where the corresponding `member_role` matches the code in the `project_member_roles` table, and the description of that role is \"Research Organisations\".", "fixed": true, "try_times": 2, "pred": "SELECT pm.member_name \nFROM project_members AS pm \nJOIN activity_types AS at ON pm.activity_type = at.code \nWHERE at.description = 'Research Organisations';"}
{"idx": 47, "db_id": "cordis", "query": "What is the objective of DEEPCARBON?", "evidence": "", "extracted_schema": {"projects": ["unics_id", "acronym", "title", "ec_call", "objective", "principal_investigator"], "institutions": "drop_all", "countries": "drop_all", "activity_types": "drop_all", "ec_framework_programs": "drop_all", "erc_panels": "drop_all", "erc_research_domains": "drop_all", "eu_territorial_units": "drop_all", "funding_schemes": "drop_all", "people": "drop_all", "programmes": "drop_all", "project_erc_panels": "drop_all", "project_member_roles": "drop_all", "project_members": "drop_all", "project_programmes": "drop_all", "project_subject_areas": "drop_all", "project_topics": "drop_all", "subject_areas": "drop_all", "topics": "drop_all"}, "ground_truth": "select objective from projects where acronym = 'DEEPCARBON'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT objective FROM projects WHERE title = 'DEEPCARBON';", "qa_pairs": "To retrieve the objective of the project named \"DEEPCARBON,\" you would need to query the `projects` table where the title matches \"DEEPCARBON.\" The SQL query would look like this:\n\n```sql\nSELECT objective FROM projects WHERE title = 'DEEPCARBON';\n``` \n\nThis query selects the `objective` column from the `projects` table for the row where the `title` is \"DEEPCARBON.\"", "fixed": true, "try_times": 3, "pred": "-- SQL to retrieve the objective of the project titled 'DEEPCARBON'\nSELECT objective FROM projects WHERE title = 'DEEPCARBON';"}
{"idx": 48, "db_id": "cordis", "query": "What is the objective of the project with acronym DEEPCARBON?", "evidence": "", "extracted_schema": {"projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "objective"], "institutions": "drop_all", "project_members": "drop_all"}, "ground_truth": "select objective from projects where acronym = 'DEEPCARBON'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT objective FROM projects WHERE acronym = 'DEEPCARBON';", "qa_pairs": "To retrieve the objective of the project with the acronym \"DEEPCARBON\", you can use the following SQL query:\n\n```sql\nSELECT objective FROM projects WHERE acronym = 'DEEPCARBON';\n```\n\nThis query selects the `objective` column from the `projects` table where the `acronym` matches \"DEEPCARBON\".", "fixed": false, "try_times": 1, "pred": "SELECT objective FROM projects WHERE acronym = 'DEEPCARBON';"}
{"idx": 49, "db_id": "cordis", "query": "Get the title of projects having the term 'carbon capturing' in it's objective.", "evidence": "", "extracted_schema": {"projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "objective"], "project_subject_areas": "drop_all", "project_topics": "drop_all"}, "ground_truth": "select title from projects where objective like '%carbon capturing%'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT title FROM projects WHERE objective LIKE '%carbon capturing%'", "qa_pairs": "```sql\nSELECT title FROM projects WHERE objective LIKE '%carbon capturing%'\n```", "fixed": false, "try_times": 1, "pred": "SELECT title FROM projects WHERE objective LIKE '%carbon capturing%'"}
{"idx": 50, "db_id": "cordis", "query": "How many projects have an objective which contains 'carbon capturing'?", "evidence": "", "extracted_schema": {"projects": ["unics_id", "title", "objective", "ec_call", "ec_fund_scheme", "cordis_ref"], "project_subject_areas": "drop_all", "project_topics": "drop_all"}, "ground_truth": "select count(*) from projects where objective like '%carbon capturing%'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT COUNT(*) \nFROM projects \nWHERE objective LIKE '%carbon capturing%'", "qa_pairs": "To find the number of projects that have an objective containing the phrase 'carbon capturing', you can use the following SQL query:\n\n```sql\nSELECT COUNT(*) \nFROM projects \nWHERE objective LIKE '%carbon capturing%'\n```\n\nThis query counts all rows in the `projects` table where the `objective` column contains the substring 'carbon capturing'. The `%` wildcard is used to match any characters before or after the specified phrase.", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(*) \nFROM projects \nWHERE objective LIKE '%carbon capturing%'"}
{"idx": 51, "db_id": "cordis", "query": "Show all names of institutions from France except institutions from the territorial region of Paris", "evidence": "", "extracted_schema": {"institutions": "keep_all", "countries": "keep_all", "eu_territorial_units": "drop_all", "project_members": "drop_all"}, "ground_truth": "select i.institutions_name from institutions as i join countries as c on c.unics_id = i.country_id where country_name = 'France' except select i.institutions_name from institutions as i join countries as c on c.unics_id = i.country_id join eu_territorial_units as etu on i.geocode_regions_3 = etu.geocode_regions where country_name = 'France' and etu.description = 'Paris'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT institutions_name \nFROM institutions \nWHERE country_id = (SELECT unics_id FROM countries WHERE country_name = 'France') \nAND geocode_regions_3 <> (SELECT geocode_regions FROM eu_territorial_units WHERE description = 'Paris');", "qa_pairs": "To retrieve all names of institutions from France while excluding those from the territorial region of Paris, you can use the following SQL query. This assumes that the `geocode_regions_3` column in the `institutions` table contains a value that identifies the Paris region.\n\nHere's the SQL query:\n\n```sql\nSELECT institutions_name \nFROM institutions \nWHERE country_id = (SELECT unics_id FROM countries WHERE country_name = 'France') \nAND geocode_regions_3 <> (SELECT geocode_regions FROM eu_territorial_units WHERE description = 'Paris');\n```\n\n### Explanation:\n1. **Select Statement**: We are selecting the `institutions_name` from the `institutions` table.\n2. **Country Filter**: We filter institutions to only include those where the `country_id` matches the `unics_id` of France from the `countries` table.\n3. **Exclusion of Paris**: We exclude institutions that are in the Paris region by ensuring that `geocode_regions_3` does not match the `geocode_regions` associated with Paris in the `eu_territorial_units` table.\n\nMake sure to adjust the subquery for Paris if the description or the way to identify the Paris region differs in your actual database schema.", "fixed": false, "try_times": 1, "pred": "SELECT institutions_name \nFROM institutions \nWHERE country_id = (SELECT unics_id FROM countries WHERE country_name = 'France') \nAND geocode_regions_3 <> (SELECT geocode_regions FROM eu_territorial_units WHERE description = 'Paris');"}
{"idx": 52, "db_id": "cordis", "query": "Show institutions from France except the ones from Paris", "evidence": "", "extracted_schema": {"institutions": "keep_all", "countries": "keep_all", "eu_territorial_units": "drop_all", "people": "drop_all", "projects": "drop_all", "programmes": "drop_all"}, "ground_truth": "select i.institutions_name from institutions as i join countries as c on c.unics_id = i.country_id where country_name = 'France' except select i.institutions_name from institutions as i join countries as c on c.unics_id = i.country_id join eu_territorial_units as etu on i.geocode_regions_3 = etu.geocode_regions where country_name = 'France' and etu.description = 'Paris'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT institutions_name \nFROM institutions \nWHERE country_id = (SELECT unics_id FROM countries WHERE country_name = 'France') \nAND geocode_regions_3 <> (SELECT geocode_regions FROM eu_territorial_units WHERE description = 'PARIS');", "qa_pairs": "```sql\nSELECT institutions_name \nFROM institutions \nWHERE country_id = (SELECT unics_id FROM countries WHERE country_name = 'France') \nAND geocode_regions_3 <> (SELECT geocode_regions FROM eu_territorial_units WHERE description = 'PARIS');\n```", "fixed": true, "try_times": 3, "pred": "SELECT DISTINCT i.institutions_name \nFROM institutions i\nJOIN countries c ON i.country_id = c.unics_id\nJOIN project_members pm ON i.unics_id = pm.institution_id\nWHERE c.country_name = 'France' \nAND pm.city <> 'PARIS';"}
{"idx": 53, "db_id": "cordis", "query": "Which institutions have never been project coordinators", "evidence": "", "extracted_schema": {"institutions": "keep_all", "project_members": ["unics_id", "project", "institution_id", "member_role", "activity_type", "country"], "projects": ["unics_id", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "principal_investigator"]}, "ground_truth": "SELECT distinct member_name from project_members WHERE member_name NOT in (SELECT member_name from project_members where member_role = 'coordinator')", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "activity_type", "country", "institution_id", "member_role", "geocode_regions_3"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT i.institutions_name \nFROM institutions AS i \nLEFT JOIN project_members AS pm ON i.unics_id = pm.institution_id AND pm.member_role = 'Coordinator' \nWHERE pm.institution_id IS NULL;", "qa_pairs": "To find the institutions that have never been project coordinators, we need to identify institutions that do not appear in the `project_members` table with the role of 'Coordinator'. We can achieve this by using a `LEFT JOIN` to find institutions that do not have any corresponding entries in the `project_members` table with the specified role.\n\nHere's the SQL query to accomplish this:\n\n```sql\nSELECT i.institutions_name \nFROM institutions AS i \nLEFT JOIN project_members AS pm ON i.unics_id = pm.institution_id AND pm.member_role = 'Coordinator' \nWHERE pm.institution_id IS NULL;\n```\n\n### Explanation:\n1. **SELECT i.institutions_name**: We are selecting the names of the institutions.\n2. **FROM institutions AS i**: We are querying from the `institutions` table and aliasing it as `i`.\n3. **LEFT JOIN project_members AS pm**: We perform a left join with the `project_members` table (aliased as `pm`).\n4. **ON i.unics_id = pm.institution_id AND pm.member_role = 'Coordinator'**: We join on the condition that the institution's ID matches the project member's institution ID and that the member role is 'Coordinator'.\n5. **WHERE pm.institution_id IS NULL**: This condition filters the results to only include institutions that do not have any corresponding entries in the `project_members` table with the role of 'Coordinator', meaning they have never been project coordinators.", "fixed": false, "try_times": 1, "pred": "SELECT i.institutions_name \nFROM institutions AS i \nLEFT JOIN project_members AS pm ON i.unics_id = pm.institution_id AND pm.member_role = 'Coordinator' \nWHERE pm.institution_id IS NULL;"}
{"idx": 54, "db_id": "cordis", "query": "Show all of the instituions that have never coordinated a project", "evidence": "", "extracted_schema": {"institutions": "keep_all", "projects": "drop_all", "project_members": "drop_all", "project_member_roles": "drop_all", "project_programmes": "drop_all", "project_subject_areas": "drop_all"}, "ground_truth": "SELECT distinct member_name from project_members WHERE member_name NOT in (SELECT member_name from project_members where member_role = 'coordinator')", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT i.institutions_name\nFROM institutions AS i\nLEFT JOIN project_members AS pm ON i.unics_id = pm.institution_id AND pm.member_role = (SELECT code FROM project_member_roles WHERE description = 'Coordinator')\nWHERE pm.project IS NULL;", "qa_pairs": "To find all institutions that have never coordinated a project, we need to identify institutions that do not appear in the `project_members` table with the role of \"Coordinator\". We can achieve this by using a `LEFT JOIN` to find institutions that do not have any corresponding entries in the `project_members` table where the `member_role` is \"Coordinator\".\n\nHere is the SQL query to accomplish that:\n\n```sql\nSELECT i.institutions_name\nFROM institutions AS i\nLEFT JOIN project_members AS pm ON i.unics_id = pm.institution_id AND pm.member_role = (SELECT code FROM project_member_roles WHERE description = 'Coordinator')\nWHERE pm.project IS NULL;\n```\n\n### Explanation:\n1. **SELECT i.institutions_name**: We are selecting the names of the institutions.\n2. **FROM institutions AS i**: We are querying from the `institutions` table and giving it an alias `i`.\n3. **LEFT JOIN project_members AS pm**: We perform a left join with the `project_members` table (aliased as `pm`) to include all institutions even if they do not have matching entries in `project_members`.\n4. **ON i.unics_id = pm.institution_id**: We join on the condition that the `unics_id` from `institutions` matches the `institution_id` in `project_members`.\n5. **AND pm.member_role = (SELECT code FROM project_member_roles WHERE description = 'Coordinator')**: We filter the join to only consider rows where the role is \"Coordinator\".\n6. **WHERE pm.project IS NULL**: Finally, we filter the results to only include institutions that do not have any corresponding entries in `project_members` (i.e., they have never coordinated a project).\n\nThis query will return the names of all institutions that have never coordinated a project.", "fixed": false, "try_times": 1, "pred": "SELECT i.institutions_name\nFROM institutions AS i\nLEFT JOIN project_members AS pm ON i.unics_id = pm.institution_id AND pm.member_role = (SELECT code FROM project_member_roles WHERE description = 'Coordinator')\nWHERE pm.project IS NULL;"}
{"idx": 55, "db_id": "cordis", "query": "Show all of the names of people who have worked on multiple projects", "evidence": "", "extracted_schema": {"people": "keep_all", "project_members": "keep_all", "projects": "keep_all", "institutions": "drop_all", "countries": "drop_all", "activity_types": "drop_all", "ec_framework_programs": "drop_all", "erc_panels": "drop_all", "erc_research_domains": "drop_all", "eu_territorial_units": "drop_all", "funding_schemes": "drop_all", "project_erc_panels": "drop_all", "project_programmes": "drop_all", "project_subject_areas": "drop_all", "project_topics": "drop_all", "subject_areas": "drop_all", "topics": "drop_all"}, "ground_truth": "SELECT t1.full_name, count(p.title) FROM people as t1 join projects as p on t1.unics_id = p.principal_investigator group by t1.full_name HAVING count(p.title) > 1", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT p.full_name\nFROM project_members pm\nJOIN people p ON pm.unics_id = p.unics_id\nGROUP BY pm.unics_id\nHAVING COUNT(pm.project) > 1;", "qa_pairs": "To find all the names of people who have worked on multiple projects, we can use the `project_members` table to count the number of projects each person has worked on. We will then join this result with the `people` table to get the names of those individuals. \n\nHere’s the SQL query to achieve that:\n\n```sql\nSELECT p.full_name\nFROM project_members pm\nJOIN people p ON pm.unics_id = p.unics_id\nGROUP BY pm.unics_id\nHAVING COUNT(pm.project) > 1;\n```\n\n### Explanation:\n1. **FROM project_members pm**: We start from the `project_members` table, which contains the relationship between people and projects.\n2. **JOIN people p ON pm.unics_id = p.unics_id**: We join the `people` table to get the full names of the individuals based on their unique IDs.\n3. **GROUP BY pm.unics_id**: We group the results by the unique ID of the people to aggregate the project counts.\n4. **HAVING COUNT(pm.project) > 1**: We filter the groups to only include those who have worked on more than one project.\n\nThis query will return the names of all individuals who have participated in multiple projects.", "fixed": true, "try_times": 3, "pred": "-- SQL Type: SELECT\nSELECT p.full_name\nFROM project_members pm\nJOIN people p ON pm.unics_id = p.unics_id\nWHERE pm.project IS NOT NULL\nGROUP BY p.unics_id\nHAVING COUNT(DISTINCT pm.project) > 1;"}
{"idx": 56, "db_id": "cordis", "query": "Which people have worked on more than one project", "evidence": "", "extracted_schema": {"people": "keep_all", "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "project_members": ["unics_id", "project", "member_name", "institution_id", "member_role", "activity_type"]}, "ground_truth": "SELECT t1.full_name, count(p.title) FROM people as t1 join projects as p on t1.unics_id = p.principal_investigator group by t1.full_name HAVING count(p.title) > 1", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "member_name", "activity_type", "institution_id", "member_role", "geocode_regions_3"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT member_name \nFROM project_members \nGROUP BY unics_id \nHAVING COUNT(project) > 1;", "qa_pairs": "To find the people who have worked on more than one project, we can use the `project_members` table, which links people to projects. We will group the results by the `unics_id` of the people and count the number of projects associated with each person. We will then filter the results to include only those with a count greater than one.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT member_name \nFROM project_members \nGROUP BY unics_id \nHAVING COUNT(project) > 1;\n```\n\nThis query selects the names of members who have participated in more than one project by grouping the records by their unique identifier (`unics_id`) and counting the number of projects associated with each member. The `HAVING` clause ensures that only those with more than one project are included in the results.", "fixed": true, "try_times": 3, "pred": "-- SQL Type: SELECT\nSELECT pm.unics_id, p.full_name\nFROM project_members pm\nJOIN people p ON pm.unics_id = p.unics_id\nWHERE pm.project IS NOT NULL\nGROUP BY pm.unics_id, p.full_name\nHAVING COUNT(DISTINCT pm.project) > 1;"}
{"idx": 57, "db_id": "cordis", "query": "What is the title of the subject area that has been granted the most funding", "evidence": "", "extracted_schema": {"projects": ["unics_id", "title", "ec_max_contribution", "total_cost", "start_date", "end_date"], "subject_areas": ["code", "title", "description"], "funding_schemes": ["code", "title"]}, "ground_truth": "SELECT t1.title, MAX(t3.ec_max_contribution) from subject_areas as t1 join project_subject_areas as t2 on t1.code = t2.subject_area join projects as t3 on t2.project = t3.unics_id  group by t1.title order by  MAX(t3.ec_max_contribution) DESC LIMIT 1", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "title", "ec_fund_scheme", "start_date", "end_date", "total_cost", "ec_max_contribution", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT sa.title\nFROM subject_areas AS sa\nJOIN project_subject_areas AS psa ON sa.code = psa.subject_area\nJOIN projects AS p ON psa.project = p.unics_id\nGROUP BY sa.code\nORDER BY SUM(p.ec_max_contribution) DESC\nLIMIT 1;", "qa_pairs": "To find the title of the subject area that has been granted the most funding, we need to join the `projects`, `project_subject_areas`, and `subject_areas` tables. We will sum the `ec_max_contribution` from the `projects` table for each subject area and then select the subject area with the highest total funding.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT sa.title\nFROM subject_areas AS sa\nJOIN project_subject_areas AS psa ON sa.code = psa.subject_area\nJOIN projects AS p ON psa.project = p.unics_id\nGROUP BY sa.code\nORDER BY SUM(p.ec_max_contribution) DESC\nLIMIT 1;\n```\n\n### Explanation:\n1. **Join Tables**: We join `subject_areas` with `project_subject_areas` to link subject areas to projects, and then join with `projects` to access funding information.\n2. **Group By**: We group the results by the subject area code to aggregate funding amounts.\n3. **Sum Funding**: We calculate the total funding for each subject area using `SUM(p.ec_max_contribution)`.\n4. **Order By**: We order the results in descending order to get the subject area with the highest funding at the top.\n5. **Limit**: We limit the results to 1 to get only the top subject area.", "fixed": false, "try_times": 1, "pred": "SELECT sa.title\nFROM subject_areas AS sa\nJOIN project_subject_areas AS psa ON sa.code = psa.subject_area\nJOIN projects AS p ON psa.project = p.unics_id\nGROUP BY sa.code\nORDER BY SUM(p.ec_max_contribution) DESC\nLIMIT 1;"}
{"idx": 58, "db_id": "cordis", "query": "Which subject area has recieved the highest funding contribution?", "evidence": "", "extracted_schema": {"projects": ["unics_id", "acronym", "title", "ec_max_contribution", "total_cost", "start_date"], "funding_schemes": ["code", "title"], "subject_areas": ["code", "title", "description"]}, "ground_truth": "SELECT t1.title, MAX(t3.ec_max_contribution) from subject_areas as t1 join project_subject_areas as t2 on t1.code = t2.subject_area join projects as t3 on t2.project = t3.unics_id  group by t1.title order by  MAX(t3.ec_max_contribution) DESC LIMIT 1", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_fund_scheme", "start_date", "total_cost", "ec_max_contribution", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT sa.title, SUM(p.ec_max_contribution) AS total_funding\nFROM project_subject_areas AS psa\nJOIN subject_areas AS sa ON psa.subject_area = sa.code\nJOIN projects AS p ON psa.project = p.unics_id\nGROUP BY sa.title\nORDER BY total_funding DESC\nLIMIT 1;", "qa_pairs": "To find the subject area that has received the highest funding contribution, we need to join the `project_subject_areas`, `subject_areas`, and `projects` tables. We will sum the `ec_max_contribution` from the `projects` table for each subject area and then select the subject area with the maximum total funding contribution.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT sa.title, SUM(p.ec_max_contribution) AS total_funding\nFROM project_subject_areas AS psa\nJOIN subject_areas AS sa ON psa.subject_area = sa.code\nJOIN projects AS p ON psa.project = p.unics_id\nGROUP BY sa.title\nORDER BY total_funding DESC\nLIMIT 1;\n```\n\n### Explanation:\n1. **FROM project_subject_areas AS psa**: Start from the `project_subject_areas` table.\n2. **JOIN subject_areas AS sa ON psa.subject_area = sa.code**: Join with the `subject_areas` table to get the title of each subject area.\n3. **JOIN projects AS p ON psa.project = p.unics_id**: Join with the `projects` table to access the funding contributions.\n4. **SUM(p.ec_max_contribution) AS total_funding**: Calculate the total funding for each subject area.\n5. **GROUP BY sa.title**: Group the results by subject area title.\n6. **ORDER BY total_funding DESC**: Order the results in descending order based on total funding.\n7. **LIMIT 1**: Limit the results to only the top subject area with the highest funding contribution. \n\nThis query will return the subject area that has received the highest funding contribution along with the total amount.", "fixed": false, "try_times": 1, "pred": "SELECT sa.title, SUM(p.ec_max_contribution) AS total_funding\nFROM project_subject_areas AS psa\nJOIN subject_areas AS sa ON psa.subject_area = sa.code\nJOIN projects AS p ON psa.project = p.unics_id\nGROUP BY sa.title\nORDER BY total_funding DESC\nLIMIT 1;"}
{"idx": 59, "db_id": "cordis", "query": "Which subject area has recieved the least funding contribution", "evidence": "", "extracted_schema": {"projects": ["unics_id", "title", "total_cost", "ec_max_contribution", "start_date", "end_date"], "funding_schemes": ["code", "title"], "subject_areas": ["code", "title", "description"]}, "ground_truth": "SELECT t1.title, MIN(t3.ec_max_contribution) from subject_areas as t1 join project_subject_areas as t2 on t1.code = t2.subject_area join projects as t3 on t2.project = t3.unics_id  group by t1.title order by  MIN(t3.ec_max_contribution) DESC LIMIT 1", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "title", "ec_fund_scheme", "start_date", "end_date", "total_cost", "ec_max_contribution", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT sa.title, SUM(p.ec_max_contribution) AS total_funding\nFROM project_subject_areas AS psa\nJOIN subject_areas AS sa ON psa.subject_area = sa.code\nJOIN projects AS p ON psa.project = p.unics_id\nGROUP BY sa.title\nORDER BY total_funding ASC\nLIMIT 1;", "qa_pairs": "To find the subject area that has received the least funding contribution, we need to join the `project_subject_areas` table with the `projects` table to access the funding information. We will then group the results by subject area and sum the contributions, ordering the results to find the minimum.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT sa.title, SUM(p.ec_max_contribution) AS total_funding\nFROM project_subject_areas AS psa\nJOIN subject_areas AS sa ON psa.subject_area = sa.code\nJOIN projects AS p ON psa.project = p.unics_id\nGROUP BY sa.title\nORDER BY total_funding ASC\nLIMIT 1;\n```\n\n### Explanation:\n1. **Join Tables**: We join `project_subject_areas` (psa) with `subject_areas` (sa) to get the subject area titles and with `projects` (p) to access the funding contributions.\n2. **Group By**: We group the results by the subject area title.\n3. **Sum Contributions**: We calculate the total funding contribution for each subject area using `SUM(p.ec_max_contribution)`.\n4. **Order and Limit**: We order the results in ascending order of total funding and limit the output to 1 to get the subject area with the least funding contribution.", "fixed": false, "try_times": 1, "pred": "SELECT sa.title, SUM(p.ec_max_contribution) AS total_funding\nFROM project_subject_areas AS psa\nJOIN subject_areas AS sa ON psa.subject_area = sa.code\nJOIN projects AS p ON psa.project = p.unics_id\nGROUP BY sa.title\nORDER BY total_funding ASC\nLIMIT 1;"}
{"idx": 60, "db_id": "cordis", "query": "What is the title of the subject area that has been granted the least amount of funding", "evidence": "", "extracted_schema": {"projects": ["unics_id", "title", "ec_max_contribution", "start_date", "end_date", "cordis_ref"], "subject_areas": ["code", "title", "description"], "funding_schemes": ["code", "title"]}, "ground_truth": "SELECT t1.title, MIN(t3.ec_max_contribution) from subject_areas as t1 join project_subject_areas as t2 on t1.code = t2.subject_area join projects as t3 on t2.project = t3.unics_id  group by t1.title order by  MIN(t3.ec_max_contribution) DESC LIMIT 1", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "title", "ec_fund_scheme", "cordis_ref", "start_date", "end_date", "ec_max_contribution", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT sa.title\nFROM subject_areas AS sa\nJOIN project_subject_areas AS psa ON sa.code = psa.subject_area\nJOIN projects AS p ON psa.project = p.unics_id\nGROUP BY sa.code\nORDER BY SUM(p.ec_max_contribution) ASC\nLIMIT 1;", "qa_pairs": "To find the title of the subject area that has been granted the least amount of funding, we need to join the `projects` table with the `project_subject_areas` table and the `subject_areas` table. We will then aggregate the funding amounts by subject area and select the one with the minimum funding.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT sa.title\nFROM subject_areas AS sa\nJOIN project_subject_areas AS psa ON sa.code = psa.subject_area\nJOIN projects AS p ON psa.project = p.unics_id\nGROUP BY sa.code\nORDER BY SUM(p.ec_max_contribution) ASC\nLIMIT 1;\n```\n\n### Explanation:\n1. **Join Tables**: We join `subject_areas` with `project_subject_areas` to link subject areas to projects, and then join with `projects` to access the funding information.\n2. **Group By**: We group the results by the subject area code to aggregate the funding amounts.\n3. **Order By**: We order the results by the total funding amount in ascending order.\n4. **Limit**: We limit the results to 1 to get the subject area with the least funding.", "fixed": false, "try_times": 1, "pred": "SELECT sa.title\nFROM subject_areas AS sa\nJOIN project_subject_areas AS psa ON sa.code = psa.subject_area\nJOIN projects AS p ON psa.project = p.unics_id\nGROUP BY sa.code\nORDER BY SUM(p.ec_max_contribution) ASC\nLIMIT 1;"}
{"idx": 61, "db_id": "cordis", "query": "Which institution has participated in the most projects", "evidence": "", "extracted_schema": {"institutions": "keep_all", "projects": "keep_all", "project_members": "keep_all", "countries": "drop_all", "activity_types": "drop_all", "ec_framework_programs": "drop_all", "erc_panels": "drop_all", "erc_research_domains": "drop_all", "eu_territorial_units": "drop_all", "funding_schemes": "drop_all", "people": "drop_all", "programmes": "drop_all", "project_erc_panels": "drop_all", "project_member_roles": "drop_all", "project_programmes": "drop_all", "project_subject_areas": "drop_all", "project_topics": "drop_all", "subjects_areas": "drop_all", "topics": "drop_all"}, "ground_truth": "Select i.institutions_name, Count(distinct project) From project_members join institutions as i on project_members.institution_id = i.unics_id GROUP BY i.institutions_name order by count(distinct project) desc limit 1", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT institutions.institutions_name, COUNT(project_members.project) AS project_count\nFROM institutions\nJOIN project_members ON institutions.unics_id = project_members.institution_id\nGROUP BY institutions.unics_id\nORDER BY project_count DESC\nLIMIT 1;", "qa_pairs": "To find the institution that has participated in the most projects, you can use the following SQL query. This query counts the number of projects each institution has participated in and orders the results to find the institution with the highest count.\n\n```sql\nSELECT institutions.institutions_name, COUNT(project_members.project) AS project_count\nFROM institutions\nJOIN project_members ON institutions.unics_id = project_members.institution_id\nGROUP BY institutions.unics_id\nORDER BY project_count DESC\nLIMIT 1;\n```\n\n### Explanation:\n1. **SELECT institutions.institutions_name, COUNT(project_members.project) AS project_count**: This selects the institution's name and counts the number of projects associated with each institution.\n2. **FROM institutions JOIN project_members ON institutions.unics_id = project_members.institution_id**: This joins the `institutions` table with the `project_members` table on the institution ID.\n3. **GROUP BY institutions.unics_id**: This groups the results by institution ID to aggregate the project counts.\n4. **ORDER BY project_count DESC**: This orders the results in descending order based on the project count.\n5. **LIMIT 1**: This limits the results to only the top institution with the highest project count.", "fixed": false, "try_times": 1, "pred": "SELECT institutions.institutions_name, COUNT(project_members.project) AS project_count\nFROM institutions\nJOIN project_members ON institutions.unics_id = project_members.institution_id\nGROUP BY institutions.unics_id\nORDER BY project_count DESC\nLIMIT 1;"}
{"idx": 62, "db_id": "cordis", "query": "Show the institution that has been involved in the highest number of projects", "evidence": "", "extracted_schema": {"institutions": "keep_all", "projects": "keep_all", "project_members": "drop_all", "countries": "drop_all", "activity_types": "drop_all", "ec_framework_programs": "drop_all"}, "ground_truth": "Select i.institutions_name, Count(distinct project) From project_members join institutions as i on project_members.institution_id = i.unics_id GROUP BY i.institutions_name order by count(distinct project) desc limit 1", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT institutions.institutions_name, COUNT(projects.unics_id) AS project_count\nFROM institutions\nJOIN project_members ON institutions.unics_id = project_members.institution_id\nJOIN projects ON project_members.project = projects.unics_id\nGROUP BY institutions.unics_id\nORDER BY project_count DESC\nLIMIT 1;", "qa_pairs": "To find the institution that has been involved in the highest number of projects, you can use the following SQL query. This query counts the number of projects associated with each institution and orders the results to find the institution with the maximum count.\n\n```sql\nSELECT institutions.institutions_name, COUNT(projects.unics_id) AS project_count\nFROM institutions\nJOIN project_members ON institutions.unics_id = project_members.institution_id\nJOIN projects ON project_members.project = projects.unics_id\nGROUP BY institutions.unics_id\nORDER BY project_count DESC\nLIMIT 1;\n```\n\n### Explanation:\n1. **JOINs**: The query joins the `institutions`, `project_members`, and `projects` tables to link institutions with their respective projects.\n2. **COUNT**: It counts the number of projects for each institution.\n3. **GROUP BY**: The results are grouped by the institution's ID to aggregate the project counts.\n4. **ORDER BY**: The results are ordered in descending order based on the project count.\n5. **LIMIT 1**: This limits the result to only the institution with the highest number of projects.", "fixed": false, "try_times": 1, "pred": "SELECT institutions.institutions_name, COUNT(projects.unics_id) AS project_count\nFROM institutions\nJOIN project_members ON institutions.unics_id = project_members.institution_id\nJOIN projects ON project_members.project = projects.unics_id\nGROUP BY institutions.unics_id\nORDER BY project_count DESC\nLIMIT 1;"}
{"idx": 63, "db_id": "cordis", "query": "Which institution has participated in the fewest projects", "evidence": "", "extracted_schema": {"institutions": "keep_all", "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "project_members": ["unics_id", "project", "institution_id", "member_role", "activity_type", "country"]}, "ground_truth": "Select t2.institutions_name, Count(distinct project) From project_members as t1 join institutions as t2 on t1.institution_id = t2.unics_id GROUP BY t2.institutions_name order by count(distinct project) asc limit 1", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "activity_type", "country", "institution_id", "member_role", "geocode_regions_3"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT institutions.institutions_name, COUNT(project_members.project) AS project_count\nFROM institutions\nLEFT JOIN project_members ON institutions.unics_id = project_members.institution_id\nGROUP BY institutions.unics_id\nORDER BY project_count ASC\nLIMIT 1;", "qa_pairs": "To find the institution that has participated in the fewest projects, we need to count the number of projects each institution has participated in and then select the institution with the minimum count. We can achieve this by joining the `institutions` table with the `project_members` table and grouping by the institution's ID. Finally, we will order the results by the count of projects and limit the output to one record.\n\nHere is the SQL query to accomplish this:\n\n```sql\nSELECT institutions.institutions_name, COUNT(project_members.project) AS project_count\nFROM institutions\nLEFT JOIN project_members ON institutions.unics_id = project_members.institution_id\nGROUP BY institutions.unics_id\nORDER BY project_count ASC\nLIMIT 1;\n```\n\n### Explanation:\n- We select the institution's name and count the number of projects associated with each institution.\n- We use a `LEFT JOIN` to ensure that institutions with zero projects are also included in the results.\n- We group the results by the institution's unique ID (`unics_id`).\n- We order the results by the count of projects in ascending order to get the institution with the fewest projects at the top.\n- Finally, we limit the result to one record to get only the institution with the fewest projects.", "fixed": false, "try_times": 1, "pred": "SELECT institutions.institutions_name, COUNT(project_members.project) AS project_count\nFROM institutions\nLEFT JOIN project_members ON institutions.unics_id = project_members.institution_id\nGROUP BY institutions.unics_id\nORDER BY project_count ASC\nLIMIT 1;"}
{"idx": 64, "db_id": "cordis", "query": "Show the institution that has been involved in the least amount of projects", "evidence": "", "extracted_schema": {"institutions": "keep_all", "projects": ["unics_id", "acronym", "title", "ec_call", "start_date", "end_date"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"]}, "ground_truth": "Select t2.institutions_name, Count(distinct project) From project_members as t1 join institutions as t2 on t1.institution_id = t2.unics_id GROUP BY t2.institutions_name order by count(distinct project) asc limit 1", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "start_date", "end_date", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT institutions.institutions_name, COUNT(project_members.project) AS project_count\nFROM institutions\nLEFT JOIN project_members ON institutions.unics_id = project_members.institution_id\nGROUP BY institutions.unics_id\nORDER BY project_count ASC\nLIMIT 1;", "qa_pairs": "To find the institution that has been involved in the least amount of projects, we can use a SQL query that counts the number of projects associated with each institution and then selects the institution with the minimum count. Here's the SQL query to achieve that:\n\n```sql\nSELECT institutions.institutions_name, COUNT(project_members.project) AS project_count\nFROM institutions\nLEFT JOIN project_members ON institutions.unics_id = project_members.institution_id\nGROUP BY institutions.unics_id\nORDER BY project_count ASC\nLIMIT 1;\n```\n\n### Explanation:\n1. **SELECT institutions.institutions_name, COUNT(project_members.project) AS project_count**: This selects the institution's name and counts the number of projects associated with each institution.\n2. **FROM institutions**: This specifies the `institutions` table as the main table.\n3. **LEFT JOIN project_members ON institutions.unics_id = project_members.institution_id**: This joins the `project_members` table to the `institutions` table on the institution ID, allowing us to count the projects for each institution. A LEFT JOIN is used to ensure that institutions with no projects are still included in the results.\n4. **GROUP BY institutions.unics_id**: This groups the results by institution ID so that we can count the projects for each institution.\n5. **ORDER BY project_count ASC**: This orders the results by the count of projects in ascending order, so the institution with the least projects comes first.\n6. **LIMIT 1**: This limits the results to only the institution with the least number of projects. \n\nThis query will return the name of the institution that has been involved in the least amount of projects along with the count of those projects.", "fixed": false, "try_times": 1, "pred": "SELECT institutions.institutions_name, COUNT(project_members.project) AS project_count\nFROM institutions\nLEFT JOIN project_members ON institutions.unics_id = project_members.institution_id\nGROUP BY institutions.unics_id\nORDER BY project_count ASC\nLIMIT 1;"}
{"idx": 65, "db_id": "cordis", "query": "Which funding scheme provided the most funding", "evidence": "", "extracted_schema": {"funding_schemes": "keep_all", "projects": ["unics_id", "title", "ec_max_contribution", "total_cost", "ec_fund_scheme", "start_date"], "institutions": "drop_all"}, "ground_truth": "SELECT t1.title, sum(ec_max_contribution) from funding_schemes as t1 join projects as t2 on t1.code = t2.ec_fund_scheme group by t1.title ORDER BY sum(ec_max_contribution) DESC LIMIT 1", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "title", "ec_fund_scheme", "start_date", "total_cost", "ec_max_contribution", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT ec_fund_scheme, SUM(ec_max_contribution) AS total_funding\nFROM projects\nGROUP BY ec_fund_scheme\nORDER BY total_funding DESC\nLIMIT 1;", "qa_pairs": "To find the funding scheme that provided the most funding, we need to aggregate the total contributions from each funding scheme and then select the one with the highest total. The relevant table for this query is `projects`, which contains the `ec_max_contribution` and `ec_fund_scheme` columns.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT ec_fund_scheme, SUM(ec_max_contribution) AS total_funding\nFROM projects\nGROUP BY ec_fund_scheme\nORDER BY total_funding DESC\nLIMIT 1;\n```\n\nThis query does the following:\n1. Selects the `ec_fund_scheme` and the sum of `ec_max_contribution` for each funding scheme.\n2. Groups the results by `ec_fund_scheme` to aggregate the contributions.\n3. Orders the results in descending order based on the total funding.\n4. Limits the result to the top entry, which will be the funding scheme with the most funding.", "fixed": false, "try_times": 1, "pred": "SELECT ec_fund_scheme, SUM(ec_max_contribution) AS total_funding\nFROM projects\nGROUP BY ec_fund_scheme\nORDER BY total_funding DESC\nLIMIT 1;"}
{"idx": 66, "db_id": "cordis", "query": "Which funding scheme provided the least funding", "evidence": "", "extracted_schema": {"funding_schemes": "keep_all", "projects": ["ec_fund_scheme", "total_cost", "ec_max_contribution", "start_date", "end_date", "title"], "institutions": "drop_all"}, "ground_truth": "SELECT t1.title, sum(ec_max_contribution) from funding_schemes as t1 join projects as t2 on t1.code = t2.ec_fund_scheme group by t1.title ORDER BY sum(ec_max_contribution) ASC LIMIT 1", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "title", "ec_fund_scheme", "start_date", "end_date", "total_cost", "ec_max_contribution", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT fs.title, MIN(p.ec_max_contribution) AS least_funding\nFROM projects AS p\nJOIN funding_schemes AS fs ON p.ec_fund_scheme = fs.code\nGROUP BY fs.title\nORDER BY least_funding ASC\nLIMIT 1;", "qa_pairs": "To find the funding scheme that provided the least funding, we need to query the `projects` table to get the total cost and the maximum contribution for each funding scheme. We can then aggregate this data by funding scheme and find the one with the minimum total funding.\n\nHere's the SQL query to achieve that:\n\n```sql\nSELECT fs.title, MIN(p.ec_max_contribution) AS least_funding\nFROM projects AS p\nJOIN funding_schemes AS fs ON p.ec_fund_scheme = fs.code\nGROUP BY fs.title\nORDER BY least_funding ASC\nLIMIT 1;\n```\n\nThis query does the following:\n1. Joins the `projects` table with the `funding_schemes` table on the funding scheme code.\n2. Groups the results by the funding scheme title.\n3. Selects the minimum maximum contribution for each funding scheme.\n4. Orders the results by the least funding in ascending order.\n5. Limits the result to the top entry, which will be the funding scheme that provided the least funding.", "fixed": false, "try_times": 1, "pred": "SELECT fs.title, MIN(p.ec_max_contribution) AS least_funding\nFROM projects AS p\nJOIN funding_schemes AS fs ON p.ec_fund_scheme = fs.code\nGROUP BY fs.title\nORDER BY least_funding ASC\nLIMIT 1;"}
{"idx": 67, "db_id": "cordis", "query": "Show the industrial partners that have worked on projects and the amount of funding they have recieved in order from most to least", "evidence": "", "extracted_schema": {"institutions": "keep_all", "projects": "keep_all", "project_members": ["unics_id", "project", "institution_id", "member_role", "ec_contribution", "member_name"]}, "ground_truth": "SELECT t1.member_name, p.ec_max_contribution FROM project_members as t1 join activity_types as t2 on t1.activity_type = t2.code join projects as p on t1.project = p.unics_id WHERE t2.code = 'PRC' ORDER BY ec_max_contribution DESC", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "member_name", "activity_type", "ec_contribution", "institution_id", "member_role", "geocode_regions_3"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT \n    i.institutions_name AS industrial_partner, \n    SUM(pm.ec_contribution) AS total_funding\nFROM \n    project_members AS pm\nJOIN \n    institutions AS i ON pm.institution_id = i.unics_id\nWHERE \n    pm.member_role = 'Partner'  -- Assuming 'Partner' indicates industrial partners\nGROUP BY \n    i.institutions_name\nORDER BY \n    total_funding DESC;", "qa_pairs": "To retrieve the industrial partners that have worked on projects along with the amount of funding they have received, we need to join the relevant tables and aggregate the funding amounts. The `project_members` table contains information about the partners and their funding contributions, while the `institutions` table provides the names of the institutions.\n\nHere’s the SQL query that accomplishes this:\n\n```sql\nSELECT \n    i.institutions_name AS industrial_partner, \n    SUM(pm.ec_contribution) AS total_funding\nFROM \n    project_members AS pm\nJOIN \n    institutions AS i ON pm.institution_id = i.unics_id\nWHERE \n    pm.member_role = 'Partner'  -- Assuming 'Partner' indicates industrial partners\nGROUP BY \n    i.institutions_name\nORDER BY \n    total_funding DESC;\n```\n\n### Explanation:\n- **SELECT**: We select the institution name and the total funding received.\n- **SUM(pm.ec_contribution)**: This aggregates the funding contributions for each partner.\n- **FROM project_members AS pm**: We start from the `project_members` table.\n- **JOIN institutions AS i**: We join the `institutions` table to get the names of the partners.\n- **WHERE pm.member_role = 'Partner'**: We filter to include only those members who are classified as partners (industrial partners).\n- **GROUP BY i.institutions_name**: We group the results by the institution name to aggregate the funding.\n- **ORDER BY total_funding DESC**: Finally, we order the results by the total funding in descending order to show the most funded partners first.", "fixed": true, "try_times": 3, "pred": "-- SQL Script Type: SELECT\nSELECT \n    i.institutions_name AS industrial_partner, \n    SUM(pm.ec_contribution) AS total_funding\nFROM \n    project_members AS pm\nJOIN \n    institutions AS i ON pm.institution_id = i.unics_id\nWHERE \n    pm.member_role = 'Partner'  -- Assuming 'Partner' indicates industrial partners\n    AND pm.ec_contribution IS NOT NULL  -- Exclude NULL contributions\nGROUP BY \n    i.institutions_name\nHAVING \n    SUM(pm.ec_contribution) > 0  -- Ensure we only include partners with funding\nORDER BY \n    total_funding DESC;"}
{"idx": 68, "db_id": "cordis", "query": "Show the amount of funding and corresponding list of industrial partners that have worked on projects in order from the most funding to the least funding", "evidence": "", "extracted_schema": {"projects": ["unics_id", "title", "total_cost", "ec_max_contribution", "start_date", "end_date"], "project_members": ["unics_id", "project", "member_name", "institution_id", "member_role", "country"], "institutions": ["unics_id", "institutions_name", "country_id", "website", "acronym", "short_name"]}, "ground_truth": "SELECT t1.member_name, p.ec_max_contribution FROM project_members as t1 join activity_types as t2 on t1.activity_type = t2.code join projects as p on t1.project = p.unics_id WHERE t2.code = 'PRC' ORDER BY ec_max_contribution DESC", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "member_name", "activity_type", "country", "institution_id", "member_role", "geocode_regions_3"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "title", "ec_fund_scheme", "start_date", "end_date", "total_cost", "ec_max_contribution", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT \n    p.total_cost AS funding_amount, \n    GROUP_CONCAT(i.institutions_name) AS industrial_partners\nFROM \n    projects AS p\nJOIN \n    project_members AS pm ON p.unics_id = pm.project\nJOIN \n    institutions AS i ON pm.institution_id = i.unics_id\nGROUP BY \n    p.total_cost\nORDER BY \n    p.total_cost DESC;", "qa_pairs": "To show the amount of funding and the corresponding list of industrial partners that have worked on projects, we need to join the `projects`, `project_members`, and `institutions` tables. We will group the results by project funding and order them from the most funding to the least funding.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT \n    p.total_cost AS funding_amount, \n    GROUP_CONCAT(i.institutions_name) AS industrial_partners\nFROM \n    projects AS p\nJOIN \n    project_members AS pm ON p.unics_id = pm.project\nJOIN \n    institutions AS i ON pm.institution_id = i.unics_id\nGROUP BY \n    p.total_cost\nORDER BY \n    p.total_cost DESC;\n```\n\n### Explanation:\n- We select the `total_cost` from the `projects` table as `funding_amount`.\n- We use `GROUP_CONCAT` to concatenate the names of the institutions (industrial partners) that have worked on each project.\n- We join the `projects` table with the `project_members` table on the project ID and then join with the `institutions` table on the institution ID.\n- We group the results by `total_cost` to aggregate the industrial partners for each funding amount.\n- Finally, we order the results by `total_cost` in descending order to show the most funding first.", "fixed": false, "try_times": 1, "pred": "SELECT \n    p.total_cost AS funding_amount, \n    GROUP_CONCAT(i.institutions_name) AS industrial_partners\nFROM \n    projects AS p\nJOIN \n    project_members AS pm ON p.unics_id = pm.project\nJOIN \n    institutions AS i ON pm.institution_id = i.unics_id\nGROUP BY \n    p.total_cost\nORDER BY \n    p.total_cost DESC;"}
{"idx": 69, "db_id": "cordis", "query": "Show the title and the start year of the most recent projects", "evidence": "", "extracted_schema": {"projects": "keep_all", "programmes": "drop_all", "institutions": "drop_all", "project_members": "drop_all", "project_erc_panels": "drop_all", "project_subject_areas": "drop_all"}, "ground_truth": "SELECT p.title, p.start_year from projects as p order by start_year DESC", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT title, start_year \nFROM projects \nORDER BY start_year DESC \nLIMIT 1", "qa_pairs": "```sql\nSELECT title, start_year \nFROM projects \nORDER BY start_year DESC \nLIMIT 1\n```", "fixed": false, "try_times": 1, "pred": "SELECT title, start_year \nFROM projects \nORDER BY start_year DESC \nLIMIT 1"}
{"idx": 70, "db_id": "cordis", "query": "Which projects have started most recently?", "evidence": "", "extracted_schema": {"projects": "keep_all", "project_members": "drop_all", "project_programmes": "drop_all", "project_topics": "drop_all", "project_subject_areas": "drop_all"}, "ground_truth": "SELECT p.title, p.start_year from projects as p order by start_year DESC", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT * FROM projects WHERE start_date = (SELECT MAX(start_date) FROM projects);", "qa_pairs": "To find the projects that have started most recently, we need to query the `projects` table and sort the results by the `start_date` in descending order. We can then limit the results to show only the most recent projects. Here is the SQL query to achieve that:\n\n```sql\nSELECT * FROM projects ORDER BY start_date DESC LIMIT 1;\n```\n\nThis query selects all columns from the `projects` table, orders the results by the `start_date` in descending order, and limits the output to the most recent project. If there are multiple projects that started on the same most recent date and you want to see all of them, you can adjust the query accordingly. For example, if you want to see all projects that started on the latest date, you can use a subquery to first find the maximum start date:\n\n```sql\nSELECT * FROM projects WHERE start_date = (SELECT MAX(start_date) FROM projects);\n``` \n\nThis will return all projects that have the most recent start date.", "fixed": true, "try_times": 2, "pred": "-- SQL Type: SELECT\nSELECT unics_id, title, start_date \nFROM projects \nWHERE start_date IS NOT NULL \nAND start_date = (SELECT MAX(start_date) FROM projects WHERE start_date IS NOT NULL);"}
{"idx": 71, "db_id": "cordis", "query": "Show title and the starting year of the least recent projects", "evidence": "", "extracted_schema": {"projects": ["unics_id", "title", "start_year", "start_date", "end_year", "end_date"], "programmes": "drop_all", "institutions": "drop_all"}, "ground_truth": "SELECT p.title, p.start_year from projects as p order by start_year ASC", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "title", "ec_fund_scheme", "start_date", "end_date", "start_year", "end_year", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT title, start_year \nFROM projects \nWHERE start_year = (SELECT MAX(start_year) FROM projects);", "qa_pairs": "To show the title and the starting year of the least recent projects, we need to find the projects with the maximum starting year. Here's the SQL query that accomplishes this:\n\n```sql\nSELECT title, start_year \nFROM projects \nWHERE start_year = (SELECT MAX(start_year) FROM projects);\n```\n\nThis query selects the title and starting year of projects where the starting year is equal to the maximum starting year found in the `projects` table.", "fixed": false, "try_times": 1, "pred": "SELECT title, start_year \nFROM projects \nWHERE start_year = (SELECT MAX(start_year) FROM projects);"}
{"idx": 72, "db_id": "cordis", "query": "Which projects have started the least recently?", "evidence": "", "extracted_schema": {"projects": "keep_all", "programmes": "drop_all", "project_members": "drop_all", "project_erc_panels": "drop_all", "project_subject_areas": "drop_all", "project_topics": "drop_all"}, "ground_truth": "SELECT p.title, p.start_year from projects as p order by start_year ASC", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT * FROM projects ORDER BY start_date ASC LIMIT 5;", "qa_pairs": "To find the projects that have started the least recently, we can query the `projects` table and order the results by the `start_date` in ascending order. This will allow us to see the projects that started the earliest. Here’s the SQL query to achieve that:\n\n```sql\nSELECT * FROM projects ORDER BY start_date ASC;\n```\n\nThis query selects all columns from the `projects` table and orders the results by the `start_date` in ascending order, showing the projects that started the least recently at the top. If you want to limit the results to a specific number of projects, you can add a `LIMIT` clause at the end. For example, to get the top 5 least recently started projects:\n\n```sql\nSELECT * FROM projects ORDER BY start_date ASC LIMIT 5;\n```", "fixed": true, "try_times": 2, "pred": "-- SQL Type: SELECT\nSELECT unics_id, title, start_date \nFROM projects \nWHERE start_date IS NOT NULL \nORDER BY start_date ASC \nLIMIT 5;"}
{"idx": 73, "db_id": "cordis", "query": "What is the starting date of the first recorded project", "evidence": "", "extracted_schema": {"projects": "keep_all", "project_members": "drop_all", "project_programmes": "drop_all", "project_subject_areas": "drop_all", "project_topics": "drop_all", "project_erc_panels": "drop_all", "project_member_roles": "drop_all", "activity_types": "drop_all", "countries": "drop_all", "institutions": "drop_all", "ec_framework_programs": "drop_all", "erc_panels": "drop_all", "erc_research_domains": "drop_all", "eu_territorial_units": "drop_all", "funding_schemes": "drop_all", "people": "drop_all", "subject_areas": "drop_all", "topics": "drop_all"}, "ground_truth": "SELECT p.start_date from projects as p order by start_date ASC", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT MIN(start_date) AS first_start_date FROM projects WHERE start_date IS NOT NULL;", "qa_pairs": "To find the starting date of the first recorded project, you can use the following SQL query. This query selects the minimum start date from the `projects` table, which represents the earliest starting date of any project recorded in the database.\n\n```sql\nSELECT MIN(start_date) AS first_start_date FROM projects WHERE start_date IS NOT NULL;\n```\n\nThis query ensures that only non-null start dates are considered when determining the earliest date.", "fixed": false, "try_times": 1, "pred": "SELECT MIN(start_date) AS first_start_date FROM projects WHERE start_date IS NOT NULL;"}
{"idx": 74, "db_id": "cordis", "query": "On which date did the first project start?", "evidence": "", "extracted_schema": {"projects": "keep_all", "project_members": "drop_all", "project_programmes": "drop_all", "project_subject_areas": "drop_all", "project_topics": "drop_all", "project_erc_panels": "drop_all", "programmes": "drop_all", "institutions": "drop_all", "countries": "drop_all", "activity_types": "drop_all", "erc_panels": "drop_all", "erc_research_domains": "drop_all", "eu_territorial_units": "drop_all", "funding_schemes": "drop_all", "people": "drop_all", "subject_areas": "drop_all", "topics": "drop_all", "ec_framework_programs": "drop_all"}, "ground_truth": "SELECT p.start_date from projects as p order by start_date ASC", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT MIN(start_date) FROM projects WHERE start_date IS NOT NULL;", "qa_pairs": "```sql\nSELECT MIN(start_date) FROM projects WHERE start_date IS NOT NULL;\n```", "fixed": false, "try_times": 1, "pred": "SELECT MIN(start_date) FROM projects WHERE start_date IS NOT NULL;"}
{"idx": 75, "db_id": "cordis", "query": "Show the titles of all of the projects in the subject area of Climate change and Carbon cycle research", "evidence": "", "extracted_schema": {"projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "subject_areas": ["code", "title", "description"], "project_subject_areas": ["project", "subject_area"]}, "ground_truth": "SELECT t3.title from subject_areas as t1 join project_subject_areas as t2 on t1.code = t2.subject_area join projects as t3 on t2.project = t3.unics_id WHERE t1.title = 'Climate change and Carbon cycle research'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT p.title \nFROM projects AS p \nJOIN project_subject_areas AS psa ON p.unics_id = psa.project \nJOIN subject_areas AS sa ON psa.subject_area = sa.code \nWHERE sa.title = 'Climate change and Carbon cycle research';", "qa_pairs": "To retrieve the titles of all projects in the subject area of \"Climate change and Carbon cycle research,\" we need to join the `projects`, `project_subject_areas`, and `subject_areas` tables. We will filter the results based on the title of the subject area.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT p.title \nFROM projects AS p \nJOIN project_subject_areas AS psa ON p.unics_id = psa.project \nJOIN subject_areas AS sa ON psa.subject_area = sa.code \nWHERE sa.title = 'Climate change and Carbon cycle research';\n```\n\nThis query selects the titles of projects that are linked to the specified subject area by joining the relevant tables and applying the necessary filter.", "fixed": false, "try_times": 1, "pred": "SELECT p.title \nFROM projects AS p \nJOIN project_subject_areas AS psa ON p.unics_id = psa.project \nJOIN subject_areas AS sa ON psa.subject_area = sa.code \nWHERE sa.title = 'Climate change and Carbon cycle research';"}
{"idx": 76, "db_id": "cordis", "query": "Show the titles of all of the projects that share the subject area code 'CCC", "evidence": "", "extracted_schema": {"projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "project_subject_areas": ["project", "subject_area"], "subject_areas": ["code", "title", "description"]}, "ground_truth": "SELECT t3.title from subject_areas as t1 join project_subject_areas as t2 on t1.code = t2.subject_area join projects as t3 on t2.project = t3.unics_id WHERE t1.title = 'Climate change and Carbon cycle research'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT p.title \nFROM projects AS p \nJOIN project_subject_areas AS psa ON p.unics_id = psa.project \nWHERE psa.subject_area = 'CCC';", "qa_pairs": "To retrieve the titles of all projects that share the subject area code 'CCC', you will need to join the `projects` table with the `project_subject_areas` table based on the project ID, and then filter the results based on the subject area code. Here is the corresponding SQL query:\n\n```sql\nSELECT p.title \nFROM projects AS p \nJOIN project_subject_areas AS psa ON p.unics_id = psa.project \nWHERE psa.subject_area = 'CCC';\n```\n\nThis query selects the titles of projects from the `projects` table where there is a matching entry in the `project_subject_areas` table for the specified subject area code 'CCC'.", "fixed": false, "try_times": 1, "pred": "SELECT p.title \nFROM projects AS p \nJOIN project_subject_areas AS psa ON p.unics_id = psa.project \nWHERE psa.subject_area = 'CCC';"}
{"idx": 77, "db_id": "cordis", "query": "List all of the possible roles that project members can have in projects", "evidence": "", "extracted_schema": {"project_member_roles": "keep_all", "project_members": "drop_all", "projects": "drop_all", "institutions": "drop_all"}, "ground_truth": "SELECT pmr.description from project_member_roles as pmr", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT DISTINCT description FROM project_member_roles;", "qa_pairs": "```sql\nSELECT DISTINCT description FROM project_member_roles;\n```", "fixed": false, "try_times": 1, "pred": "SELECT DISTINCT description FROM project_member_roles;"}
{"idx": 78, "db_id": "cordis", "query": "What are all of the ways that projects members can participate in projects?", "evidence": "", "extracted_schema": {"project_member_roles": "keep_all", "project_members": "keep_all", "projects": "drop_all", "activity_types": "drop_all", "institutions": "drop_all", "people": "drop_all"}, "ground_truth": "SELECT pmr.description from project_member_roles as pmr", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT DISTINCT description FROM project_member_roles;", "qa_pairs": "To find all the ways that project members can participate in projects, we need to query the `project_member_roles` table, which contains the descriptions of the different roles that members can have in projects.\n\nHere is the SQL query to retrieve all unique participation roles:\n\n```sql\nSELECT DISTINCT description FROM project_member_roles;\n```\n\nThis query selects the distinct descriptions from the `project_member_roles` table, which will give us a list of all the different ways that project members can participate in projects.", "fixed": false, "try_times": 1, "pred": "SELECT DISTINCT description FROM project_member_roles;"}
{"idx": 79, "db_id": "cordis", "query": "How many erc panels are dedicated to Life Sciences", "evidence": "", "extracted_schema": {"erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "projects": "drop_all"}, "ground_truth": "SELECT count(t1.description) from erc_panels as t1 join erc_research_domains as t2 on t2.code = t1.part_of WHERE t2.description = 'Life Sciences'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT COUNT(*) \nFROM erc_panels AS EP \nJOIN erc_research_domains AS ERD ON EP.part_of = ERD.code \nWHERE ERD.description = 'Life Sciences';", "qa_pairs": "To find out how many ERC panels are dedicated to Life Sciences, we need to join the `erc_panels` table with the `erc_research_domains` table to filter for the specific research domain of \"Life Sciences\". We can then count the number of panels that match this criterion.\n\nHere is the SQL query to achieve that:\n\n```sql\nSELECT COUNT(*) \nFROM erc_panels AS EP \nJOIN erc_research_domains AS ERD ON EP.part_of = ERD.code \nWHERE ERD.description = 'Life Sciences';\n```\n\nThis query counts the number of rows in the `erc_panels` table that are associated with the \"Life Sciences\" research domain.", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(*) \nFROM erc_panels AS EP \nJOIN erc_research_domains AS ERD ON EP.part_of = ERD.code \nWHERE ERD.description = 'Life Sciences';"}
{"idx": 80, "db_id": "cordis", "query": "Count the number of erc panels that are part of Life Sciences", "evidence": "", "extracted_schema": {"erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "projects": "drop_all"}, "ground_truth": "SELECT count(t1.description) from erc_panels as t1 join erc_research_domains as t2 on t2.code = t1.part_of WHERE t2.code = 'LS'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT COUNT(*) \nFROM erc_panels AS EP \nJOIN erc_research_domains AS ERD ON EP.part_of = ERD.code \nWHERE ERD.description = 'Life Sciences';", "qa_pairs": "To count the number of ERC panels that are part of the \"Life Sciences\" research domain, you can use the following SQL query. This query joins the `erc_panels` table with the `erc_research_domains` table to filter for the specific research domain and then counts the number of matching panels.\n\n```sql\nSELECT COUNT(*) \nFROM erc_panels AS EP \nJOIN erc_research_domains AS ERD ON EP.part_of = ERD.code \nWHERE ERD.description = 'Life Sciences';\n```\n\nThis SQL statement will return the count of ERC panels that are categorized under the \"Life Sciences\" research domain.", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(*) \nFROM erc_panels AS EP \nJOIN erc_research_domains AS ERD ON EP.part_of = ERD.code \nWHERE ERD.description = 'Life Sciences';"}
{"idx": 81, "db_id": "cordis", "query": "List all of the european research council panels related to social sciences and humanities", "evidence": "", "extracted_schema": {"erc_panels": "keep_all", "erc_research_domains": ["code", "description"], "project_erc_panels": ["project", "panel"]}, "ground_truth": "SELECT t1.description from erc_panels as t1 join erc_research_domains as t2 on t2.code = t1.part_of WHERE t2.code = 'SH'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT erc_panels.code, erc_panels.description\nFROM erc_panels\nJOIN erc_research_domains ON erc_panels.part_of = erc_research_domains.code\nWHERE erc_research_domains.description = 'Social Sciences And Humanities';", "qa_pairs": "To list all of the European Research Council (ERC) panels related to social sciences and humanities, you need to join the `erc_panels` table with the `erc_research_domains` table based on the `part_of` foreign key. You will filter the results to include only those panels that are associated with the \"Social Sciences And Humanities\" research domain.\n\nHere is the corresponding SQL query:\n\n```sql\nSELECT erc_panels.code, erc_panels.description\nFROM erc_panels\nJOIN erc_research_domains ON erc_panels.part_of = erc_research_domains.code\nWHERE erc_research_domains.description = 'Social Sciences And Humanities';\n```\n\nThis query selects the `code` and `description` of the ERC panels that are part of the \"Social Sciences And Humanities\" research domain.", "fixed": false, "try_times": 1, "pred": "SELECT erc_panels.code, erc_panels.description\nFROM erc_panels\nJOIN erc_research_domains ON erc_panels.part_of = erc_research_domains.code\nWHERE erc_research_domains.description = 'Social Sciences And Humanities';"}
{"idx": 82, "db_id": "cordis", "query": "How many european research council panels are related to social sciences and humanities", "evidence": "", "extracted_schema": {"erc_panels": "keep_all", "erc_research_domains": ["code", "description"], "projects": "drop_all", "activity_types": "drop_all", "countries": "drop_all", "institutions": "drop_all", "people": "drop_all", "programmes": "drop_all", "project_erc_panels": "drop_all", "project_member_roles": "drop_all", "project_members": "drop_all", "project_programmes": "drop_all", "project_subject_areas": "drop_all", "project_topics": "drop_all", "subject_areas": "drop_all", "topics": "drop_all", "eu_territorial_units": "drop_all", "funding_schemes": "drop_all", "ec_framework_programs": "drop_all"}, "ground_truth": "SELECT count(t1.description) from erc_panels as t1 join erc_research_domains as t2 on t2.code = t1.part_of WHERE t2.code = 'SH'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT COUNT(*) \nFROM erc_panels AS T1 \nJOIN erc_research_domains AS T2 ON T1.part_of = T2.code \nWHERE T2.description = 'Social Sciences And Humanities';", "qa_pairs": "To find out how many European Research Council (ERC) panels are related to \"Social Sciences And Humanities,\" we need to join the `erc_panels` table with the `erc_research_domains` table based on the `part_of` foreign key. We will then filter the results to only include panels that are part of the \"Social Sciences And Humanities\" domain and count them.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT COUNT(*) \nFROM erc_panels AS T1 \nJOIN erc_research_domains AS T2 ON T1.part_of = T2.code \nWHERE T2.description = 'Social Sciences And Humanities';\n```\n\nThis query counts the number of ERC panels that are associated with the specified research domain.", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(*) \nFROM erc_panels AS T1 \nJOIN erc_research_domains AS T2 ON T1.part_of = T2.code \nWHERE T2.description = 'Social Sciences And Humanities';"}
{"idx": 83, "db_id": "cordis", "query": "Show all of the project members that are private for profit entities", "evidence": "", "extracted_schema": {"project_members": "keep_all", "institutions": "keep_all", "projects": "keep_all", "countries": "drop_all", "activity_types": "drop_all", "ec_framework_programs": "drop_all", "erc_panels": "drop_all", "erc_research_domains": "drop_all", "eu_territorial_units": "drop_all", "funding_schemes": "drop_all", "people": "drop_all", "programmes": "drop_all", "project_erc_panels": "drop_all", "project_member_roles": "drop_all", "project_programmes": "drop_all", "project_subject_areas": "drop_all", "project_topics": "drop_all", "subject_areas": "drop_all", "topics": "drop_all"}, "ground_truth": "SELECT member_name FROM project_members as t1 join activity_types as t2 on t1.activity_type = t2.code WHERE t2.code = 'PRC'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT * \nFROM project_members \nWHERE member_role = 'Partner';", "qa_pairs": "To show all of the project members that are private for profit entities, we need to identify the relevant criteria for \"private for profit entities.\" Assuming that this information is indicated by a specific value in the `member_role` column of the `project_members` table, we can filter based on that.\n\nHowever, since the schema does not explicitly define what constitutes a \"private for profit entity,\" I will assume that the relevant role is indicated by a specific `member_role` code. For this example, let's assume that the code for \"private for profit entities\" is 'Partner'.\n\nHere’s the SQL query to retrieve all project members that are classified as private for profit entities:\n\n```sql\nSELECT * \nFROM project_members \nWHERE member_role = 'Partner';\n```\n\nThis query selects all columns from the `project_members` table where the `member_role` is 'Partner', which we are assuming represents private for profit entities. If there are specific criteria or codes that define private for profit entities in your actual schema, you would need to adjust the `WHERE` clause accordingly.", "fixed": true, "try_times": 3, "pred": "SELECT -- SQL Type: SELECT\n    pm.unics_id, \n    pm.project, \n    pm.member_name, \n    pm.member_role\nFROM \n    project_members pm\nJOIN \n    institutions i ON pm.institution_id = i.unics_id\nWHERE \n    pm.member_role = 'Partner' \n    AND pm.institution_id IS NOT NULL\n    AND i.institutions_name IS NOT NULL; -- Assuming we want to ensure the institution name is not null"}
{"idx": 84, "db_id": "cordis", "query": "Which project members are businesses?", "evidence": "", "extracted_schema": {"project_members": "keep_all", "institutions": "keep_all", "countries": "drop_all", "projects": "drop_all"}, "ground_truth": "SELECT member_name FROM project_members as t1 join activity_types as t2 on t1.activity_type = t2.code WHERE t2.code = 'PRC'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT member_name \nFROM project_members \nWHERE member_role = (SELECT code FROM project_member_roles WHERE description = 'Business');", "qa_pairs": "To find out which project members are businesses, we need to identify the relevant criteria that define a \"business\" in the context of the provided database schema. However, the schema does not explicitly define a column that indicates whether a member is a business or not. \n\nAssuming that the `member_role` in the `project_members` table could contain roles that indicate a business (for example, if there are specific codes for businesses), we can query the `project_members` table to find members with such roles.\n\nHere’s a possible SQL query to retrieve project members that are businesses, assuming that there is a specific role code for businesses (let's say 'Business' is one of the roles):\n\n```sql\nSELECT member_name \nFROM project_members \nWHERE member_role = (SELECT code FROM project_member_roles WHERE description = 'Business');\n```\n\nIf there are specific codes for businesses in the `project_member_roles` table, you would replace 'Business' with the appropriate description. If the schema does not provide a clear way to identify businesses, additional context or data would be needed to refine this query.", "fixed": true, "try_times": 3, "pred": "SELECT pm.member_name \nFROM project_members pm\nJOIN project_member_roles pmr ON pm.member_role = pmr.code\nWHERE pmr.description = 'Partner';"}
{"idx": 85, "db_id": "cordis", "query": "How many project members are businesses?", "evidence": "", "extracted_schema": {"project_members": ["unics_id", "project", "member_name", "institution_id", "member_role", "country"], "institutions": ["unics_id", "country_id", "institutions_name", "acronym", "website", "db_pedia_url"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"]}, "ground_truth": "SELECT count(member_name) FROM project_members as t1 join activity_types as t2 on t1.activity_type = t2.code WHERE t2.code = 'PRC'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "acronym", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "member_name", "activity_type", "country", "institution_id", "member_role", "geocode_regions_3"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT COUNT(*) \nFROM project_members \nWHERE member_role = (SELECT code FROM project_member_roles WHERE description = 'Partner');", "qa_pairs": "To determine how many project members are businesses, we need to identify which members are classified as businesses. This classification is typically indicated by the `member_role` in the `project_members` table. Assuming that there is a specific role code that corresponds to businesses, we can count the number of project members with that role.\n\nLet's assume that the role code for businesses is 'Partner' (you may need to adjust this based on the actual data). The SQL query would look like this:\n\n```sql\nSELECT COUNT(*) \nFROM project_members \nWHERE member_role = (SELECT code FROM project_member_roles WHERE description = 'Partner');\n```\n\nThis query counts the number of project members whose role is classified as 'Partner', which we are assuming represents businesses. If there is a different role that indicates businesses, you would replace 'Partner' with the appropriate description.", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(*) \nFROM project_members \nWHERE member_role = (SELECT code FROM project_member_roles WHERE description = 'Partner');"}
{"idx": 86, "db_id": "cordis", "query": "How many project members are Higher or Secondary Education Establishments?", "evidence": "", "extracted_schema": {"institutions": "keep_all", "project_members": "keep_all", "project_member_roles": "keep_all", "projects": "drop_all", "countries": "drop_all", "activity_types": "drop_all"}, "ground_truth": "SELECT count (distinct member_name) FROM project_members as t1 join activity_types as t2 on t1.activity_type = t2.code WHERE t2.code = 'HES'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT COUNT(*) \nFROM project_members \nWHERE member_role IN (\n    SELECT code \n    FROM project_member_roles \n    WHERE description IN ('Higher Education Establishment', 'Secondary Education Establishment')\n);", "qa_pairs": "To find out how many project members are categorized as Higher or Secondary Education Establishments, we need to look at the `project_members` table and check the `member_role` field against the relevant roles that correspond to Higher or Secondary Education Establishments. \n\nAssuming that the roles for Higher or Secondary Education Establishments are defined in the `project_member_roles` table, we can write a SQL query to count the number of project members that fall under these categories.\n\nHere's the SQL query:\n\n```sql\nSELECT COUNT(*) \nFROM project_members \nWHERE member_role IN (\n    SELECT code \n    FROM project_member_roles \n    WHERE description IN ('Higher Education Establishment', 'Secondary Education Establishment')\n);\n```\n\nThis query counts the number of project members whose roles match either \"Higher Education Establishment\" or \"Secondary Education Establishment\". Adjust the descriptions in the `WHERE` clause as necessary based on the actual descriptions in your `project_member_roles` table.", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(*) \nFROM project_members \nWHERE member_role IN (\n    SELECT code \n    FROM project_member_roles \n    WHERE description IN ('Higher Education Establishment', 'Secondary Education Establishment')\n);"}
{"idx": 87, "db_id": "cordis", "query": "Count the number of project members that are Educational Establishments", "evidence": "", "extracted_schema": {"project_members": ["unics_id", "project", "member_name", "institution_id", "member_role", "country"], "institutions": ["unics_id", "institutions_name", "country_id", "geocode_regions_3", "website", "acronym"], "project_programmes": ["project", "programme", "code"]}, "ground_truth": "SELECT count (distinct member_name) FROM project_members as t1 join activity_types as t2 on t1.activity_type = t2.code WHERE t2.description = 'Higher or Secondary Education Establishments'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "acronym", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "member_name", "activity_type", "country", "institution_id", "member_role", "geocode_regions_3"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "start_date", "end_date", "start_year", "end_year", "homepage", "total_cost", "ec_max_contribution", "framework_program", "objective", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT COUNT(*) \nFROM project_members \nWHERE member_role = 'Host institution' OR member_role = 'Partner';", "qa_pairs": "To count the number of project members that are classified as Educational Establishments, we need to identify which members fall under that category. Assuming that the `member_role` in the `project_members` table indicates the type of institution or member, we can filter for the relevant roles that correspond to Educational Establishments.\n\nHere’s the SQL query to achieve this:\n\n```sql\nSELECT COUNT(*) \nFROM project_members \nWHERE member_role = 'Host institution' OR member_role = 'Partner';\n```\n\nIn this query, we are counting the number of project members whose roles are either 'Host institution' or 'Partner', which are typically associated with Educational Establishments. Adjust the `WHERE` clause based on the actual roles that represent Educational Establishments in your database.", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(*) \nFROM project_members \nWHERE member_role = 'Host institution' OR member_role = 'Partner';"}
{"idx": 88, "db_id": "cordis", "query": "How many projects have been related to Robotics?", "evidence": "", "extracted_schema": {"projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "project_topics": ["project", "topic"], "project_subject_areas": ["project", "subject_area"]}, "ground_truth": "SELECT count(t3.title) from subject_areas as t1 join project_subject_areas as t2 on t1.code = t2.subject_area join projects as t3 on t2.project = t3.unics_id WHERE t1.title = 'Robotics'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT COUNT(*) \nFROM projects AS P \nJOIN project_topics AS PT ON P.unics_id = PT.project \nJOIN topics AS T ON PT.topic = T.code \nWHERE T.title LIKE '%Robotics%'", "qa_pairs": "To find out how many projects have been related to Robotics, we need to look for any entries in the `project_topics` table that are associated with the topic of Robotics. However, the provided schema does not explicitly list the topics, so we will assume that there is a topic related to Robotics in the `topics` table.\n\nThe SQL query will involve joining the `projects` table with the `project_topics` table and filtering for the topic related to Robotics. Here’s how you can write the SQL query:\n\n```sql\nSELECT COUNT(*) \nFROM projects AS P \nJOIN project_topics AS PT ON P.unics_id = PT.project \nJOIN topics AS T ON PT.topic = T.code \nWHERE T.title LIKE '%Robotics%'\n```\n\nThis query counts the number of projects that have a topic related to Robotics by joining the relevant tables and filtering based on the topic title.", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(*) \nFROM projects AS P \nJOIN project_topics AS PT ON P.unics_id = PT.project \nJOIN topics AS T ON PT.topic = T.code \nWHERE T.title LIKE '%Robotics%'"}
{"idx": 89, "db_id": "cordis", "query": "What is the number of projects that have been carried out in the subject area of Robotics?", "evidence": "", "extracted_schema": {"projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "subject_areas": ["code", "title", "description"], "project_subject_areas": ["project", "subject_area"]}, "ground_truth": "SELECT count(t3.title) from subject_areas as t1 join project_subject_areas as t2 on t1.code = t2.subject_area join projects as t3 on t2.project = t3.unics_id WHERE t1.title = 'Robotics'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT COUNT(DISTINCT ps.project) AS number_of_projects\nFROM project_subject_areas AS ps\nJOIN subject_areas AS sa ON ps.subject_area = sa.code\nWHERE sa.title = 'Robotics';", "qa_pairs": "To find the number of projects that have been carried out in the subject area of Robotics, you will need to join the `project_subject_areas` table with the `subject_areas` table to filter for the subject area of Robotics. Then, you can count the number of projects associated with that subject area.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT COUNT(DISTINCT ps.project) AS number_of_projects\nFROM project_subject_areas AS ps\nJOIN subject_areas AS sa ON ps.subject_area = sa.code\nWHERE sa.title = 'Robotics';\n```\n\nThis query counts the distinct projects in the `project_subject_areas` table that are linked to the subject area titled 'Robotics' in the `subject_areas` table.", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(DISTINCT ps.project) AS number_of_projects\nFROM project_subject_areas AS ps\nJOIN subject_areas AS sa ON ps.subject_area = sa.code\nWHERE sa.title = 'Robotics';"}
{"idx": 90, "db_id": "cordis", "query": "Which non-EU entity has recieved the most funding through a project?", "evidence": "", "extracted_schema": {"projects": ["unics_id", "title", "ec_max_contribution", "total_cost", "start_date", "end_date"], "institutions": ["unics_id", "institutions_name", "country_id", "website", "acronym", "short_name"], "funding_schemes": ["code", "title"]}, "ground_truth": "SELECT t1.member_name, p.ec_max_contribution FROM project_members as t1 join activity_types as t2 on t1.activity_type = t2.code join projects as p on t1.project = p.unics_id WHERE t1.geocode_regions_3 = 'NONEU' ORDER BY ec_max_contribution DESC LIMIT 1", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "title", "ec_fund_scheme", "start_date", "end_date", "total_cost", "ec_max_contribution", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT \n    institutions.institutions_name, \n    SUM(projects.ec_max_contribution) AS total_funding\nFROM \n    project_members\nJOIN \n    institutions ON project_members.institution_id = institutions.unics_id\nJOIN \n    projects ON project_members.project = projects.unics_id\nWHERE \n    institutions.country_id NOT IN (/* List of EU country IDs */)\nGROUP BY \n    institutions.institutions_name\nORDER BY \n    total_funding DESC\nLIMIT 1;", "qa_pairs": "To determine which non-EU entity has received the most funding through a project, we need to analyze the `project_members` table, which contains information about the funding received by different entities. We will group the results by the `institution_id` and sum the `ec_max_contribution` for each institution. We will also need to filter out EU entities based on their country codes.\n\nAssuming that we have a list of EU country codes, we can use that to filter out EU entities. However, since the specific list of EU country codes is not provided in the schema, I will write the SQL query generically, and you can replace the placeholder with the actual EU country codes.\n\nHere's the SQL query:\n\n```sql\nSELECT \n    institutions.institutions_name, \n    SUM(projects.ec_max_contribution) AS total_funding\nFROM \n    project_members\nJOIN \n    institutions ON project_members.institution_id = institutions.unics_id\nJOIN \n    projects ON project_members.project = projects.unics_id\nWHERE \n    institutions.country_id NOT IN (/* List of EU country IDs */)\nGROUP BY \n    institutions.institutions_name\nORDER BY \n    total_funding DESC\nLIMIT 1;\n```\n\n### Explanation:\n- We join the `project_members`, `institutions`, and `projects` tables to get the necessary information.\n- We filter out institutions that belong to EU countries using the `NOT IN` clause.\n- We group the results by institution name and sum the `ec_max_contribution` to get the total funding for each institution.\n- Finally, we order the results in descending order of total funding and limit the output to the top result to find the non-EU entity that has received the most funding.", "fixed": false, "try_times": 1, "pred": "SELECT \n    institutions.institutions_name, \n    SUM(projects.ec_max_contribution) AS total_funding\nFROM \n    project_members\nJOIN \n    institutions ON project_members.institution_id = institutions.unics_id\nJOIN \n    projects ON project_members.project = projects.unics_id\nWHERE \n    institutions.country_id NOT IN (/* List of EU country IDs */)\nGROUP BY \n    institutions.institutions_name\nORDER BY \n    total_funding DESC\nLIMIT 1;"}
{"idx": 91, "db_id": "cordis", "query": "Which entity located outside of the EU has received the most funding?", "evidence": "", "extracted_schema": {"countries": "keep_all", "institutions": "keep_all", "projects": ["unics_id", "title", "total_cost", "ec_max_contribution", "ec_fund_scheme", "start_date"]}, "ground_truth": "SELECT t1.member_name, p.ec_max_contribution FROM project_members as t1 join activity_types as t2 on t1.activity_type = t2.code join projects as p on t1.project = p.unics_id WHERE t1.geocode_regions_3 = 'NONEU' ORDER BY ec_max_contribution DESC LIMIT 1", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "title", "ec_fund_scheme", "start_date", "total_cost", "ec_max_contribution", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT institutions.institutions_name, SUM(projects.ec_max_contribution) AS total_funding\nFROM institutions\nJOIN project_members ON institutions.unics_id = project_members.institution_id\nJOIN projects ON project_members.project = projects.unics_id\nWHERE institutions.country_id NOT IN (SELECT unics_id FROM countries WHERE country_code2 IN ('AD', 'AE', 'AF', 'AG', 'AI', 'AL', 'AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE', 'GB'))\nGROUP BY institutions.institutions_name\nORDER BY total_funding DESC\nLIMIT 1;", "qa_pairs": "To determine which entity located outside of the EU has received the most funding, we need to join the relevant tables that contain information about entities, their funding, and their geographical locations. In this case, we will focus on the `institutions` table to identify entities and the `projects` table to find the funding amounts.\n\nHere's the SQL query to achieve this:\n\n```sql\nSELECT institutions.institutions_name, SUM(projects.ec_max_contribution) AS total_funding\nFROM institutions\nJOIN project_members ON institutions.unics_id = project_members.institution_id\nJOIN projects ON project_members.project = projects.unics_id\nWHERE institutions.country_id NOT IN (SELECT unics_id FROM countries WHERE country_code2 IN ('AD', 'AE', 'AF', 'AG', 'AI', 'AL', 'AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE', 'GB'))\nGROUP BY institutions.institutions_name\nORDER BY total_funding DESC\nLIMIT 1;\n```\n\n### Explanation:\n1. **Join Tables**: We join the `institutions`, `project_members`, and `projects` tables to link institutions with their respective projects and funding.\n2. **Filter Non-EU Entities**: We filter out institutions located in the EU by checking against a subquery that selects the `unics_id` of countries that are part of the EU.\n3. **Aggregate Funding**: We use `SUM` to calculate the total funding received by each institution.\n4. **Group and Order**: We group the results by institution name and order them by total funding in descending order.\n5. **Limit Result**: We limit the result to the top entity with the highest funding.\n\nThis query will return the name of the entity located outside of the EU that has received the most funding along with the total amount of funding.", "fixed": false, "try_times": 1, "pred": "SELECT institutions.institutions_name, SUM(projects.ec_max_contribution) AS total_funding\nFROM institutions\nJOIN project_members ON institutions.unics_id = project_members.institution_id\nJOIN projects ON project_members.project = projects.unics_id\nWHERE institutions.country_id NOT IN (SELECT unics_id FROM countries WHERE country_code2 IN ('AD', 'AE', 'AF', 'AG', 'AI', 'AL', 'AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE', 'GB'))\nGROUP BY institutions.institutions_name\nORDER BY total_funding DESC\nLIMIT 1;"}
{"idx": 92, "db_id": "cordis", "query": "Which non-EU entity has recieved the least funding through a project?", "evidence": "", "extracted_schema": {"projects": ["unics_id", "title", "ec_max_contribution", "total_cost", "start_date", "end_date"], "institutions": ["unics_id", "institutions_name", "country_id", "website", "acronym", "short_name"], "funding_schemes": ["code", "title"]}, "ground_truth": "SELECT t1.member_name, p.ec_max_contribution FROM project_members as t1 join activity_types as t2 on t1.activity_type = t2.code join projects as p on t1.project = p.unics_id WHERE t1.geocode_regions_3 = 'NONEU' ORDER BY ec_max_contribution ASC LIMIT 1", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "title", "ec_fund_scheme", "start_date", "end_date", "total_cost", "ec_max_contribution", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT institution_id, SUM(ec_max_contribution) AS total_funding\nFROM project_members\nWHERE country NOT IN (SELECT country_code2 FROM countries WHERE country_name IN (SELECT country_name FROM countries WHERE country_code2 IN ('AD', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE', 'GB')))\nGROUP BY institution_id\nORDER BY total_funding ASC\nLIMIT 1;", "qa_pairs": "To find the non-EU entity that has received the least funding through a project, we need to look at the `project_members` table, which contains information about the funding received by different entities. We will also need to identify which entities are non-EU based on their country codes.\n\nAssuming that non-EU countries are represented by specific country codes (for example, codes that are not part of the EU), we can filter out the EU entities and then find the one with the least funding.\n\nHere’s the SQL query to achieve this:\n\n```sql\nSELECT institution_id, SUM(ec_max_contribution) AS total_funding\nFROM project_members\nWHERE country NOT IN (SELECT country_code2 FROM countries WHERE country_name IN (SELECT country_name FROM countries WHERE country_code2 IN ('AD', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE', 'GB')))\nGROUP BY institution_id\nORDER BY total_funding ASC\nLIMIT 1;\n```\n\n### Explanation:\n1. **SELECT institution_id, SUM(ec_max_contribution)**: We select the institution ID and the total funding received by summing up the `ec_max_contribution`.\n2. **FROM project_members**: We are querying from the `project_members` table.\n3. **WHERE country NOT IN (...)**: We filter out the entities that belong to EU countries. The inner query selects country codes of EU countries.\n4. **GROUP BY institution_id**: We group the results by institution ID to aggregate the funding.\n5. **ORDER BY total_funding ASC**: We order the results in ascending order based on the total funding received.\n6. **LIMIT 1**: We limit the results to only the entity with the least funding.\n\nThis query will return the non-EU entity that has received the least funding through a project.", "fixed": true, "try_times": 2, "pred": "-- SQL Type: SELECT\nSELECT institution_id, SUM(ec_contribution) AS total_funding\nFROM project_members\nWHERE country NOT IN (\n    SELECT country_code2 \n    FROM countries \n    WHERE country_name IN (\n        SELECT country_name \n        FROM countries \n        WHERE country_code2 IN (\n            'AD', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', \n            'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', \n            'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE', 'GB'\n        )\n    )\n) AND country IS NOT NULL\nGROUP BY institution_id\nORDER BY total_funding ASC\nLIMIT 1;"}
{"idx": 93, "db_id": "cordis", "query": "Which entity located outside of the EU has received the least funding?", "evidence": "", "extracted_schema": {"countries": "keep_all", "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "projects": ["unics_id", "title", "ec_max_contribution", "total_cost", "start_date", "end_date"]}, "ground_truth": "SELECT t1.member_name, p.ec_max_contribution FROM project_members as t1 join activity_types as t2 on t1.activity_type = t2.code join projects as p on t1.project = p.unics_id WHERE t1.geocode_regions_3 = 'NONEU' ORDER BY ec_max_contribution ASC LIMIT 1", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "title", "ec_fund_scheme", "start_date", "end_date", "total_cost", "ec_max_contribution", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT institutions.institutions_name, MIN(projects.ec_max_contribution) AS least_funding\nFROM project_members\nJOIN institutions ON project_members.institution_id = institutions.unics_id\nJOIN projects ON project_members.project = projects.unics_id\nWHERE institutions.country_id NOT IN (SELECT unics_id FROM countries WHERE country_code2 IN ('AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE'))\nGROUP BY institutions.institutions_name\nORDER BY least_funding ASC\nLIMIT 1;", "qa_pairs": "To find the entity located outside of the EU that has received the least funding, we need to join the `project_members` table with the `institutions` table to identify the institutions outside of the EU and then order the results by the `ec_max_contribution` to find the one with the least funding.\n\nHere's the SQL query to achieve that:\n\n```sql\nSELECT institutions.institutions_name, MIN(projects.ec_max_contribution) AS least_funding\nFROM project_members\nJOIN institutions ON project_members.institution_id = institutions.unics_id\nJOIN projects ON project_members.project = projects.unics_id\nWHERE institutions.country_id NOT IN (SELECT unics_id FROM countries WHERE country_code2 IN ('AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE'))\nGROUP BY institutions.institutions_name\nORDER BY least_funding ASC\nLIMIT 1;\n```\n\n### Explanation:\n1. **Join Tables**: We join `project_members`, `institutions`, and `projects` to get the necessary information about institutions and their funding.\n2. **Filter Non-EU Countries**: We filter out institutions that are located outside of the EU by checking their `country_id` against a subquery that selects EU country IDs.\n3. **Group and Aggregate**: We group by institution name and use `MIN()` to find the least funding amount.\n4. **Order and Limit**: Finally, we order the results by the funding amount in ascending order and limit the result to 1 to get the entity with the least funding.", "fixed": false, "try_times": 1, "pred": "SELECT institutions.institutions_name, MIN(projects.ec_max_contribution) AS least_funding\nFROM project_members\nJOIN institutions ON project_members.institution_id = institutions.unics_id\nJOIN projects ON project_members.project = projects.unics_id\nWHERE institutions.country_id NOT IN (SELECT unics_id FROM countries WHERE country_code2 IN ('AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE'))\nGROUP BY institutions.institutions_name\nORDER BY least_funding ASC\nLIMIT 1;"}
{"idx": 94, "db_id": "cordis", "query": "How many non-EU entities have participated in projects?", "evidence": "", "extracted_schema": {"institutions": "keep_all", "project_members": ["unics_id", "project", "institution_id", "member_role", "country", "activity_type"], "projects": "drop_all", "countries": "drop_all", "activity_types": "drop_all", "ec_framework_programs": "drop_all", "erc_panels": "drop_all", "erc_research_domains": "drop_all", "eu_territorial_units": "drop_all", "funding_schemes": "drop_all", "people": "drop_all", "programmes": "drop_all", "project_erc_panels": "drop_all", "project_programmes": "drop_all", "project_subject_areas": "drop_all", "project_topics": "drop_all", "subject_areas": "drop_all", "topics": "drop_all"}, "ground_truth": "SELECT count(distinct t1.member_name) FROM project_members as t1 join activity_types as t2 on t1.activity_type = t2.code join projects as p on t1.project = p.unics_id  WHERE t1.geocode_regions_3 = 'NONEU'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "activity_type", "country", "institution_id", "member_role", "geocode_regions_3"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT COUNT(DISTINCT institution_id) \nFROM project_members \nWHERE country NOT IN ('AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE', 'GB');", "qa_pairs": "To determine how many non-EU entities have participated in projects, we need to identify the entities that are not part of the EU. This can typically be done by checking the `country` field in the `project_members` table against a list of EU country codes. However, since the database schema does not provide a direct list of EU countries, we will assume that any country code that is not in the EU is considered a non-EU entity.\n\nThe SQL query will count the distinct `institution_id` from the `project_members` table where the `country` is not in the list of EU country codes. For the sake of this example, let's assume that the EU country codes are known and we will use a placeholder list of EU country codes.\n\nHere’s the SQL query:\n\n```sql\nSELECT COUNT(DISTINCT institution_id) \nFROM project_members \nWHERE country NOT IN ('AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE', 'GB');\n```\n\nIn this query:\n- We count the distinct `institution_id` from the `project_members` table.\n- We filter out the countries that are part of the EU using the `NOT IN` clause with a list of EU country codes. \n\nMake sure to replace the placeholder EU country codes with the actual codes as necessary.", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(DISTINCT institution_id) \nFROM project_members \nWHERE country NOT IN ('AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE', 'GB');"}
{"idx": 95, "db_id": "cordis", "query": "Which entities that are located outside of the European Union have participated in projects?", "evidence": "", "extracted_schema": {"institutions": "keep_all", "project_members": "keep_all", "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "projects": "drop_all", "activity_types": "drop_all", "ec_framework_programs": "drop_all", "erc_panels": "drop_all", "erc_research_domains": "drop_all", "eu_territorial_units": "drop_all", "funding_schemes": "drop_all", "people": "drop_all", "programmes": "drop_all", "project_erc_panels": "drop_all", "project_programmes": "drop_all", "project_subject_areas": "drop_all", "project_topics": "drop_all", "subject_areas": "drop_all", "topics": "drop_all"}, "ground_truth": "SELECT distinct t1.member_name FROM project_members as t1 join activity_types as t2 on t1.activity_type = t2.code join projects as p on t1.project = p.unics_id WHERE t1.geocode_regions_3 = 'NONEU'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT DISTINCT institutions.institutions_name\nFROM project_members\nJOIN institutions ON project_members.institution_id = institutions.unics_id\nJOIN countries ON institutions.country_id = countries.unics_id\nWHERE countries.country_code2 NOT IN (\n    'AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', \n    'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', \n    'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE', 'GB'\n);", "qa_pairs": "To find entities located outside of the European Union that have participated in projects, we need to identify the relevant tables and their relationships. The `project_members` table contains information about the entities that participated in projects, and the `institutions` table contains information about the institutions, including their country.\n\nWe can assume that countries that are not part of the European Union can be identified by their country codes. However, since the schema does not explicitly provide a list of EU countries, we will need to filter out the countries based on the `countries` table.\n\nHere’s the SQL query to achieve this:\n\n```sql\nSELECT DISTINCT institutions.institutions_name\nFROM project_members\nJOIN institutions ON project_members.institution_id = institutions.unics_id\nJOIN countries ON institutions.country_id = countries.unics_id\nWHERE countries.country_code2 NOT IN (\n    'AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', \n    'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', \n    'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE', 'GB'\n);\n```\n\n### Explanation:\n1. **SELECT DISTINCT institutions.institutions_name**: We want to select the names of institutions, ensuring that we only get unique names.\n2. **FROM project_members**: We start from the `project_members` table, which contains the records of entities that participated in projects.\n3. **JOIN institutions ON project_members.institution_id = institutions.unics_id**: We join the `institutions` table to get the details of the institutions that participated in the projects.\n4. **JOIN countries ON institutions.country_id = countries.unics_id**: We join the `countries` table to get the country information for each institution.\n5. **WHERE countries.country_code2 NOT IN (...)**: We filter out the institutions that are located in EU countries by excluding their country codes. The list of country codes provided in the `NOT IN` clause represents EU member states.\n\nThis query will return the names of institutions that are located outside of the European Union and have participated in projects.", "fixed": false, "try_times": 1, "pred": "SELECT DISTINCT institutions.institutions_name\nFROM project_members\nJOIN institutions ON project_members.institution_id = institutions.unics_id\nJOIN countries ON institutions.country_id = countries.unics_id\nWHERE countries.country_code2 NOT IN (\n    'AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', \n    'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', \n    'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE', 'GB'\n);"}
{"idx": 96, "db_id": "cordis", "query": "Show all of the programmes with titles that are related to climate", "evidence": "", "extracted_schema": {"programmes": "keep_all", "projects": ["unics_id", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref"], "subject_areas": ["code", "title", "description"]}, "ground_truth": "SELECT p.title from programmes as p WHERE p.title like '%climate%'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "title", "ec_call", "ec_fund_scheme", "cordis_ref", "ec_ref", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT * FROM programmes WHERE title LIKE '%climate%'", "qa_pairs": "To retrieve all programmes with titles related to climate, we can use a SQL query that searches for the keyword \"climate\" in the title of the programmes. Assuming that the title field in the `programmes` table contains relevant information, the SQL query would look like this:\n\n```sql\nSELECT * FROM programmes WHERE title LIKE '%climate%'\n```\n\nThis query selects all columns from the `programmes` table where the title contains the word \"climate\". The `%` wildcard allows for any characters to appear before or after the word \"climate\".", "fixed": false, "try_times": 1, "pred": "SELECT * FROM programmes WHERE title LIKE '%climate%'"}
{"idx": 97, "db_id": "cordis", "query": "List the programms that have the term climate in the title", "evidence": "", "extracted_schema": {"programmes": "keep_all", "topics": "drop_all", "projects": "drop_all", "countries": "drop_all", "activity_types": "drop_all", "institutions": "drop_all"}, "ground_truth": "SELECT p.title from programmes as p WHERE p.title like '%climate%'", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "acronym", "title", "ec_call", "ec_fund_scheme", "cordis_ref"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT * FROM programmes WHERE title LIKE '%climate%'", "qa_pairs": "```sql\nSELECT * FROM programmes WHERE title LIKE '%climate%'\n```", "fixed": false, "try_times": 1, "pred": "SELECT * FROM programmes WHERE title LIKE '%climate%'"}
{"idx": 98, "db_id": "cordis", "query": "Show the title and amount of funds that have been allocated per programme", "evidence": "", "extracted_schema": {"programmes": "keep_all", "projects": ["unics_id", "title", "ec_max_contribution", "total_cost", "start_date", "end_date"], "funding_schemes": "keep_all"}, "ground_truth": "SELECT t1.title, sum(t3.ec_max_contribution) from programmes as t1 join project_programmes as t2 on t1.code = t2.programme join projects as t3 on t3.unics_id = t2.project group by t1.title", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "title", "ec_fund_scheme", "start_date", "end_date", "total_cost", "ec_max_contribution", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT p.title AS programme_title, SUM(pr.total_cost) AS total_funds_allocated\nFROM programmes AS p\nJOIN project_programmes AS pp ON p.code = pp.programme\nJOIN projects AS pr ON pp.project = pr.unics_id\nGROUP BY p.code, p.title;", "qa_pairs": "To show the title and amount of funds that have been allocated per programme, you will need to join the `projects` table with the `project_programmes` table to associate each project with its corresponding programme. Then, you can select the title of the programme and the total cost or the EC max contribution allocated to each project.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT p.title AS programme_title, SUM(pr.total_cost) AS total_funds_allocated\nFROM programmes AS p\nJOIN project_programmes AS pp ON p.code = pp.programme\nJOIN projects AS pr ON pp.project = pr.unics_id\nGROUP BY p.code, p.title;\n```\n\nThis query does the following:\n- Selects the title of the programme and the sum of the total cost from the projects.\n- Joins the `programmes` table with the `project_programmes` table to link projects to their respective programmes.\n- Joins the `projects` table to get the total cost associated with each project.\n- Groups the results by the programme code and title to aggregate the total funds allocated per programme.", "fixed": false, "try_times": 1, "pred": "SELECT p.title AS programme_title, SUM(pr.total_cost) AS total_funds_allocated\nFROM programmes AS p\nJOIN project_programmes AS pp ON p.code = pp.programme\nJOIN projects AS pr ON pp.project = pr.unics_id\nGROUP BY p.code, p.title;"}
{"idx": 99, "db_id": "cordis", "query": "List all of the titles and the amount of funding that has been dispersed per programme", "evidence": "", "extracted_schema": {"programmes": "keep_all", "projects": ["unics_id", "title", "ec_max_contribution", "total_cost", "start_date", "end_date"], "funding_schemes": "keep_all"}, "ground_truth": "SELECT t1.title, sum(t3.ec_max_contribution) from programmes as t1 join project_programmes as t2 on t1.code = t2.programme join projects as t3 on t3.unics_id = t2.project group by t1.title", "difficulty": "cordis", "chosen_db_schem_dict": {"activity_types": ["code", "description"], "countries": ["unics_id", "country_name", "country_code2", "country_code3", "geocode_country_code"], "ec_framework_programs": ["ec_framework_program_name"], "erc_panels": ["code", "description", "part_of"], "erc_research_domains": ["code", "description"], "eu_territorial_units": ["geocode_regions", "description", "geocode_level", "nuts_version"], "funding_schemes": ["code", "title"], "institutions": ["unics_id", "country_id", "institutions_name", "geocode_regions_3", "db_pedia_url", "wikidata_url", "grid_id", "acronym", "short_name", "website"], "people": ["unics_id", "full_name"], "programmes": ["code", "rcn", "title", "short_name", "parent"], "project_erc_panels": ["project", "panel"], "project_member_roles": ["code", "description"], "project_members": ["unics_id", "project", "pic_number", "rcn", "member_name", "activity_type", "country", "street", "city", "postal_code", "ec_contribution", "institution_id", "member_role", "geocode_regions_3", "member_short_name", "department_name", "vat_number", "latitude", "longitude"], "project_programmes": ["project", "programme"], "project_subject_areas": ["project", "subject_area"], "project_topics": ["project", "topic"], "projects": ["unics_id", "title", "ec_fund_scheme", "start_date", "end_date", "total_cost", "ec_max_contribution", "framework_program", "principal_investigator"], "subject_areas": ["code", "title", "description"], "topics": ["code", "rcn", "title"]}, "pruned": true, "final_sql": "SELECT p.title AS Programme_Title, SUM(pr.ec_max_contribution) AS Total_Funding\nFROM programmes AS p\nJOIN project_programmes AS pp ON p.code = pp.programme\nJOIN projects AS pr ON pp.project = pr.unics_id\nGROUP BY p.title;", "qa_pairs": "To list all of the titles and the amount of funding that has been dispersed per programme, we need to join the `programmes` table with the `projects` table. The `projects` table contains the funding information, specifically the `ec_max_contribution` which represents the maximum contribution (funding) for each project. We will group the results by the programme title to get the total funding dispersed per programme.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT p.title AS Programme_Title, SUM(pr.ec_max_contribution) AS Total_Funding\nFROM programmes AS p\nJOIN project_programmes AS pp ON p.code = pp.programme\nJOIN projects AS pr ON pp.project = pr.unics_id\nGROUP BY p.title;\n```\n\n### Explanation:\n- We select the title of the programme and the sum of the maximum contributions from the projects.\n- We join the `programmes` table with the `project_programmes` table to link programmes to their respective projects.\n- We then join the `projects` table to access the funding information.\n- Finally, we group the results by the programme title to get the total funding for each programme.", "fixed": true, "try_times": 3, "pred": "-- SQL Script Type: SELECT\nSELECT p.title AS Programme_Title, SUM(pr.ec_max_contribution) AS Total_Funding\nFROM programmes AS p\nJOIN project_programmes AS pp ON p.code = pp.programme\nJOIN projects AS pr ON pp.project = pr.unics_id\nWHERE pr.ec_max_contribution IS NOT NULL\nGROUP BY p.title;"}
{"idx": 100, "db_id": "oncomx", "query": "Show me all disease mutations with ref_aa E", "evidence": "", "extracted_schema": {"disease_mutation": "keep_all", "disease_mutation_site_annotation": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_tissue": "drop_all", "disease": "drop_all", "biomarker": "drop_all"}, "ground_truth": "SELECT * FROM disease_mutation WHERE ref_aa = 'E'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT * FROM disease_mutation WHERE ref_aa = 'E'", "qa_pairs": "```sql\nSELECT * FROM disease_mutation WHERE ref_aa = 'E'\n```", "fixed": false, "try_times": 1, "pred": "SELECT * FROM disease_mutation WHERE ref_aa = 'E'"}
{"idx": 101, "db_id": "oncomx", "query": "In how many FDA tests was manufacturer 23andMe involved?", "evidence": "", "extracted_schema": {"biomarker_fda_test": ["test_manufacturer", "test_trade_name", "test_submission", "biomarker_origin", "doid", "test_number_genes"], "biomarker_fda": ["test_trade_name", "test_submission", "id"], "biomarker_fda_test_use": ["test_trade_name", "test_submission", "approved_indication", "actual_use", "id"]}, "ground_truth": "SELECT count(*)\nFROM biomarker_fda_test\nWHERE biomarker_fda_test.test_manufacturer = '23andMe'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "test_number_genes"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT COUNT(*) \nFROM biomarker_fda_test \nWHERE test_manufacturer = '23andMe';", "qa_pairs": "To find out how many FDA tests the manufacturer \"23andMe\" was involved in, we need to query the `biomarker_fda_test` table, which contains information about FDA tests and their manufacturers. We will count the number of entries where the manufacturer is \"23andMe\".\n\nHere is the SQL query to achieve that:\n\n```sql\nSELECT COUNT(*) \nFROM biomarker_fda_test \nWHERE test_manufacturer = '23andMe';\n```\n\nThis query counts all rows in the `biomarker_fda_test` table where the `test_manufacturer` is \"23andMe\".", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(*) \nFROM biomarker_fda_test \nWHERE test_manufacturer = '23andMe';"}
{"idx": 102, "db_id": "oncomx", "query": "What is the common name for species 'Mus'?", "evidence": "", "extracted_schema": {"species": "keep_all", "xref_gene_ensembl": "drop_all", "biomarker": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_use": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_edrn": "drop_all", "biomarker_article": "drop_all", "biomarker_alias": "drop_all", "disease": "drop_all", "disease_mutation": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease_mutation_tissue": "drop_all", "cancer_tissue": "drop_all", "healthy_expression": "drop_all", "differential_expression": "drop_all", "stage": "drop_all", "anatomical_entity": "drop_all", "map_uniprot_canonical_id": "drop_all", "map_protein_disease_mutation": "drop_all"}, "ground_truth": "SELECT speciescommonname\nFROM species\nWHERE genus = 'Mus'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT speciescommonname FROM species WHERE genus = 'Mus';", "qa_pairs": "```sql\nSELECT speciescommonname FROM species WHERE genus = 'Mus';\n```", "fixed": false, "try_times": 1, "pred": "SELECT speciescommonname FROM species WHERE genus = 'Mus';"}
{"idx": 103, "db_id": "oncomx", "query": "What species are there?", "evidence": "", "extracted_schema": {"species": "keep_all", "disease": "drop_all", "biomarker": "drop_all", "biomarker_fda": "drop_all"}, "ground_truth": "SELECT * FROM species", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT DISTINCT speciescommonname FROM species;", "qa_pairs": "```sql\nSELECT DISTINCT speciescommonname FROM species;\n```", "fixed": false, "try_times": 1, "pred": "SELECT DISTINCT speciescommonname FROM species;"}
{"idx": 104, "db_id": "oncomx", "query": "Show me all disease mutations", "evidence": "", "extracted_schema": {"disease_mutation": "keep_all", "disease_mutation_article": "keep_all", "disease_mutation_impact_prediction": "keep_all"}, "ground_truth": "SELECT * FROM disease_mutation", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT * FROM disease_mutation", "qa_pairs": "```sql\nSELECT * FROM disease_mutation\n```", "fixed": false, "try_times": 1, "pred": "SELECT * FROM disease_mutation"}
{"idx": 105, "db_id": "oncomx", "query": "Get a list of all biomarker descriptions", "evidence": "", "extracted_schema": {"biomarker": "keep_all", "biomarker_alias": "drop_all", "biomarker_article": "drop_all", "biomarker_edrn": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_use": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease": "drop_all", "xref_gene_ensembl": "drop_all", "species": "drop_all", "stage": "drop_all", "disease_mutation": "drop_all", "healthy_expression": "drop_all", "anatomical_entity": "drop_all", "map_uniprot_canonical_id": "drop_all", "disease_mutation_tissue": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all", "differential_expression": "drop_all"}, "ground_truth": "SELECT biomarker_description FROM biomarker", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT biomarker_description FROM biomarker;", "qa_pairs": "```sql\nSELECT biomarker_description FROM biomarker;\n```", "fixed": false, "try_times": 1, "pred": "SELECT biomarker_description FROM biomarker;"}
{"idx": 106, "db_id": "oncomx", "query": "In how many fda test trials was test manufacturer 'ABBOTT MOLECULAR INC' involved?", "evidence": "", "extracted_schema": {"biomarker_fda_test_trial": "keep_all", "biomarker_fda_test": "keep_all", "biomarker_fda": "keep_all"}, "ground_truth": "SELECT count(*)\nFROM biomarker_fda_test\n         JOIN biomarker_fda_test_trial\n              ON biomarker_fda_test.test_submission = biomarker_fda_test_trial.test_submission and\n                 biomarker_fda_test.test_trade_name = biomarker_fda_test_trial.test_trade_name\nWHERE test_manufacturer = 'ABBOTT MOLECULAR INC'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT COUNT(DISTINCT test_trial_id) \nFROM biomarker_fda_test_trial \nWHERE test_trade_name IN (\n    SELECT test_trade_name \n    FROM biomarker_fda_test \n    WHERE test_manufacturer = 'ABBOTT MOLECULAR INC'\n);", "qa_pairs": "To find out how many FDA test trials involved the test manufacturer 'ABBOTT MOLECULAR INC', we need to query the `biomarker_fda_test` table to filter by the manufacturer and then count the distinct test trials associated with that manufacturer.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT COUNT(DISTINCT test_trial_id) \nFROM biomarker_fda_test_trial \nWHERE test_trade_name IN (\n    SELECT test_trade_name \n    FROM biomarker_fda_test \n    WHERE test_manufacturer = 'ABBOTT MOLECULAR INC'\n);\n```\n\nThis query first selects the `test_trade_name` from the `biomarker_fda_test` table where the `test_manufacturer` is 'ABBOTT MOLECULAR INC'. Then, it counts the distinct `test_trial_id` from the `biomarker_fda_test_trial` table that matches those `test_trade_name` values.", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(DISTINCT test_trial_id) \nFROM biomarker_fda_test_trial \nWHERE test_trade_name IN (\n    SELECT test_trade_name \n    FROM biomarker_fda_test \n    WHERE test_manufacturer = 'ABBOTT MOLECULAR INC'\n);"}
{"idx": 107, "db_id": "oncomx", "query": "Show the gene symbol and the description of cancer biomarkers with panel = 'false'", "evidence": "", "extracted_schema": {"biomarker": ["gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel", "id"], "biomarker_fda": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_use": "drop_all", "biomarker_edrn": "drop_all", "biomarker_alias": "drop_all", "biomarker_article": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_fda_test_trial": "drop_all", "disease": "drop_all", "disease_mutation": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease_mutation_tissue": "drop_all", "healthy_expression": "drop_all", "anatomical_entity": "drop_all", "map_uniprot_canonical_id": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all", "differential_expression": "drop_all", "xref_gene_ensembl": "drop_all", "species": "drop_all", "stage": "drop_all"}, "ground_truth": "SELECT biomarker.gene_symbol, biomarker_description FROM biomarker WHERE test_is_a_panel = 'false'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT biomarker.gene_symbol, biomarker.biomarker_description \nFROM biomarker \nWHERE biomarker.test_is_a_panel = 'false'", "qa_pairs": "```sql\nSELECT biomarker.gene_symbol, biomarker.biomarker_description \nFROM biomarker \nWHERE biomarker.test_is_a_panel = 'false'\n```", "fixed": false, "try_times": 1, "pred": "SELECT biomarker.gene_symbol, biomarker.biomarker_description \nFROM biomarker \nWHERE biomarker.test_is_a_panel = 'false'"}
{"idx": 108, "db_id": "oncomx", "query": "Show all information about diseases where the name contains 'cancer'", "evidence": "", "extracted_schema": {"disease": "keep_all", "disease_mutation": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease_mutation_tissue": "drop_all"}, "ground_truth": "SELECT name FROM disease WHERE name like '%cancer%'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT * FROM disease WHERE name LIKE '%cancer%'", "qa_pairs": "```sql\nSELECT * FROM disease WHERE name LIKE '%cancer%'\n```", "fixed": false, "try_times": 1, "pred": "SELECT * FROM disease WHERE name LIKE '%cancer%'"}
{"idx": 109, "db_id": "oncomx", "query": "Show me all biomarker titles and QA states for biomarker on EDRN in phase Two", "evidence": "", "extracted_schema": {"biomarker_edrn": ["biomarker_title", "qa_state", "phase", "biomarker_type", "uberon_anatomical_id", "id"], "biomarker": "drop_all", "biomarker_alias": "drop_all", "biomarker_article": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_test_use": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease": "drop_all", "xref_gene_ensembl": "drop_all", "species": "drop_all", "stage": "drop_all", "disease_mutation": "drop_all", "healthy_expression": "drop_all", "anatomical_entity": "drop_all", "map_uniprot_canonical_id": "drop_all", "disease_mutation_tissue": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all", "differential_expression": "drop_all"}, "ground_truth": "SELECT biomarker_title, qa_state FROM biomarker_edrn WHERE phase = 'Two'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT biomarker_title, qa_state \nFROM biomarker_edrn \nWHERE phase = 'Two';", "qa_pairs": "```sql\nSELECT biomarker_title, qa_state \nFROM biomarker_edrn \nWHERE phase = 'Two';\n```", "fixed": false, "try_times": 1, "pred": "SELECT biomarker_title, qa_state \nFROM biomarker_edrn \nWHERE phase = 'Two';"}
{"idx": 110, "db_id": "oncomx", "query": "Show me biomarker titles and qa states for biomarker in phase Two", "evidence": "", "extracted_schema": {"biomarker_edrn": ["biomarker_title", "qa_state", "phase", "biomarker_type", "uberon_anatomical_id", "id"], "biomarker": "drop_all", "biomarker_alias": "drop_all", "biomarker_article": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_test_use": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease": "drop_all", "xref_gene_ensembl": "drop_all", "species": "drop_all", "stage": "drop_all", "disease_mutation": "drop_all", "healthy_expression": "drop_all", "anatomical_entity": "drop_all", "map_uniprot_canonical_id": "drop_all", "disease_mutation_tissue": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all", "differential_expression": "drop_all"}, "ground_truth": "SELECT biomarker_title, qa_state FROM biomarker_edrn WHERE phase = 'Two'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT biomarker_title, qa_state \nFROM biomarker_edrn \nWHERE phase = 'Two';", "qa_pairs": "```sql\nSELECT biomarker_title, qa_state \nFROM biomarker_edrn \nWHERE phase = 'Two';\n```", "fixed": false, "try_times": 1, "pred": "SELECT biomarker_title, qa_state \nFROM biomarker_edrn \nWHERE phase = 'Two';"}
{"idx": 111, "db_id": "oncomx", "query": "Show me all gene symbols of biomarkers", "evidence": "", "extracted_schema": {"biomarker": "keep_all", "biomarker_alias": "drop_all", "biomarker_article": "drop_all", "biomarker_edrn": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_use": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease": "drop_all", "xref_gene_ensembl": "drop_all", "species": "drop_all", "stage": "drop_all", "disease_mutation": "drop_all", "healthy_expression": "drop_all", "anatomical_entity": "drop_all", "map_uniprot_canonical_id": "drop_all", "disease_mutation_tissue": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all", "differential_expression": "drop_all"}, "ground_truth": "SELECT gene_symbol FROM biomarker", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT gene_symbol FROM biomarker", "qa_pairs": "```sql\nSELECT gene_symbol FROM biomarker\n```", "fixed": false, "try_times": 1, "pred": "SELECT gene_symbol FROM biomarker"}
{"idx": 112, "db_id": "oncomx", "query": "Show me all biomarkers on the EDRN platform which are not of type protein.", "evidence": "", "extracted_schema": {"biomarker_edrn": ["biomarker_title", "biomarker_type", "qa_state", "phase", "id"], "biomarker": ["biomarker_id", "gene_symbol", "biomarker_description", "id"], "biomarker_fda": ["id", "test_trade_name", "test_submission"]}, "ground_truth": "SELECT biomarker_title FROM biomarker_edrn WHERE biomarker_type != 'Protein'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT * \nFROM biomarker_edrn \nWHERE biomarker_type != 'Protein';", "qa_pairs": "```sql\nSELECT * \nFROM biomarker_edrn \nWHERE biomarker_type != 'Protein';\n```", "fixed": true, "try_times": 2, "pred": "-- SQL Type: SELECT\nSELECT id, biomarker_title, biomarker_type \nFROM biomarker_edrn \nWHERE biomarker_type IS NOT NULL \nAND biomarker_type != 'Protein';"}
{"idx": 113, "db_id": "oncomx", "query": "Show me the title of biomarkers on the EDRN platform with biomarker type different from Protein.", "evidence": "", "extracted_schema": {"biomarker_edrn": ["biomarker_title", "biomarker_type", "qa_state", "phase", "id", "uberon_anatomical_id"], "biomarker": ["biomarker_id", "gene_symbol", "biomarker_description", "id", "test_is_a_panel"], "biomarker_fda": ["id", "test_trade_name", "test_submission"]}, "ground_truth": "SELECT biomarker_title FROM biomarker_edrn WHERE biomarker_type != 'Protein'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT biomarker_title \nFROM biomarker_edrn \nWHERE biomarker_type != 'Protein';", "qa_pairs": "```sql\nSELECT biomarker_title \nFROM biomarker_edrn \nWHERE biomarker_type != 'Protein';\n```", "fixed": false, "try_times": 1, "pred": "SELECT biomarker_title \nFROM biomarker_edrn \nWHERE biomarker_type != 'Protein';"}
{"idx": 114, "db_id": "oncomx", "query": "Identify a list of genes expressed in lung cancer", "evidence": "", "extracted_schema": {"biomarker": "keep_all", "disease": "keep_all", "disease_mutation": "keep_all", "disease_mutation_tissue": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "ground_truth": "SELECT differential_expression.gene_symbol\nFROM differential_expression\n         JOIN disease ON differential_expression.doid = disease.id\nWHERE disease.name = 'lung cancer'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT DISTINCT gene_symbol \nFROM differential_expression \nWHERE doid = (SELECT id FROM disease WHERE name = 'lung cancer');", "qa_pairs": "To identify a list of genes expressed in lung cancer, we need to join the relevant tables that contain information about genes and their association with lung cancer. Based on the provided schema, we can use the `differential_expression` table, which has a `doid` column that can be linked to the `disease` table to filter for lung cancer.\n\nAssuming that the `doid` for lung cancer is known (let's say it is represented by a specific ID, which we will need to look up in the `disease` table), the SQL query would look something like this:\n\n```sql\nSELECT DISTINCT gene_symbol \nFROM differential_expression \nWHERE doid = (SELECT id FROM disease WHERE name = 'lung cancer');\n```\n\nThis query selects distinct gene symbols from the `differential_expression` table where the `doid` matches the ID of lung cancer from the `disease` table. Make sure to replace `'lung cancer'` with the exact name used in the `disease` table if it differs.", "fixed": false, "try_times": 1, "pred": "SELECT DISTINCT gene_symbol \nFROM differential_expression \nWHERE doid = (SELECT id FROM disease WHERE name = 'lung cancer');"}
{"idx": 115, "db_id": "oncomx", "query": "Show biomarker gene symbol and description for 'breast cancer'", "evidence": "", "extracted_schema": {"biomarker": "keep_all", "biomarker_fda": "drop_all", "biomarker_edrn": "drop_all", "disease": ["id", "name"], "biomarker_fda_test": "drop_all", "biomarker_fda_test_use": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_alias": "drop_all", "biomarker_article": "drop_all", "disease_mutation": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease_mutation_tissue": "drop_all", "healthy_expression": "drop_all", "anatomical_entity": "drop_all", "map_uniprot_canonical_id": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all", "differential_expression": "drop_all", "xref_gene_ensembl": "drop_all", "species": "drop_all", "stage": "drop_all"}, "ground_truth": "SELECT biomarker.gene_symbol, biomarker.biomarker_description\nFROM biomarker\n         JOIN biomarker_fda on biomarker.id = biomarker_fda.id\n         JOIN biomarker_fda_test ON biomarker_fda.test_submission = biomarker_fda_test.test_submission and\n                                    biomarker_fda.test_trade_name = biomarker_fda_test.test_trade_name\n         JOIN disease ON disease.id = biomarker_fda_test.doid\nWHERE disease.name = 'breast cancer'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT biomarker.gene_symbol, biomarker.biomarker_description \nFROM biomarker \nJOIN disease_mutation ON biomarker.id = disease_mutation.doid \nJOIN disease ON disease_mutation.doid = disease.id \nWHERE disease.name = 'breast cancer';", "qa_pairs": "```sql\nSELECT biomarker.gene_symbol, biomarker.biomarker_description \nFROM biomarker \nJOIN disease_mutation ON biomarker.id = disease_mutation.doid \nJOIN disease ON disease_mutation.doid = disease.id \nWHERE disease.name = 'breast cancer';\n```", "fixed": true, "try_times": 3, "pred": "SELECT biomarker.gene_symbol, biomarker.biomarker_description \nFROM biomarker \nJOIN biomarker_fda ON biomarker.id = biomarker_fda.id \nJOIN biomarker_fda_test ON biomarker_fda.test_trade_name = biomarker_fda_test.test_trade_name \nJOIN disease ON biomarker_fda_test.doid = disease.id \nWHERE disease.name = 'breast cancer';"}
{"idx": 116, "db_id": "oncomx", "query": "What are the different biomarker EDRN phases?", "evidence": "", "extracted_schema": {"biomarker_edrn": "keep_all", "biomarker": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_test_use": "drop_all", "biomarker_article": "drop_all", "biomarker_alias": "drop_all", "disease": "drop_all", "disease_mutation": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease_mutation_tissue": "drop_all", "differential_expression": "drop_all", "healthy_expression": "drop_all", "map_protein_disease_mutation": "drop_all", "map_uniprot_canonical_id": "drop_all", "species": "drop_all", "xref_gene_ensembl": "drop_all", "anatomical_entity": "drop_all", "stage": "drop_all", "cancer_tissue": "drop_all"}, "ground_truth": "SELECT DISTINCT phase from biomarker_edrn", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT DISTINCT phase FROM biomarker_edrn;", "qa_pairs": "```sql\nSELECT DISTINCT phase FROM biomarker_edrn;\n```", "fixed": true, "try_times": 2, "pred": "-- SQL Type: SELECT\nSELECT DISTINCT phase \nFROM biomarker_edrn \nWHERE phase IS NOT NULL;"}
{"idx": 117, "db_id": "oncomx", "query": "List the platform method an the test study design for FDA tests from test manufacturer Dako Denmark A/S", "evidence": "", "extracted_schema": {"biomarker_fda_test": ["test_trade_name", "test_submission", "platform_method", "test_study_design", "test_manufacturer", "biomarker_origin"], "biomarker_fda": "keep_all", "biomarker_fda_test_trial": "drop_all"}, "ground_truth": "SELECT platform_method, test_study_design\nFROM biomarker_fda_test\nWHERE test_manufacturer = 'Dako Denmark A/S'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "platform_method", "test_study_design"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT test_method.platform_method, test_method.test_study_design\nFROM biomarker_fda_test AS test_method\nWHERE test_method.test_manufacturer = 'Dako Denmark A/S';", "qa_pairs": "To retrieve the platform method and the test study design for FDA tests from the test manufacturer \"Dako Denmark A/S\", you can use the following SQL query:\n\n```sql\nSELECT test_method.platform_method, test_method.test_study_design\nFROM biomarker_fda_test AS test_method\nWHERE test_method.test_manufacturer = 'Dako Denmark A/S';\n```\n\nThis query selects the `platform_method` and `test_study_design` from the `biomarker_fda_test` table where the `test_manufacturer` matches \"Dako Denmark A/S\".", "fixed": true, "try_times": 2, "pred": "SELECT test_method.platform_method, test_method.test_study_design\nFROM biomarker_fda_test AS test_method\nWHERE test_method.test_manufacturer = 'Dako Denmark A/S'\n  AND test_method.platform_method IS NOT NULL\n  AND test_method.test_study_design IS NOT NULL;"}
{"idx": 118, "db_id": "oncomx", "query": "Get the p-value of differential expressions for the disease 'lung cancer'", "evidence": "", "extracted_schema": {"disease": "keep_all", "differential_expression": ["gene_symbol", "doid", "pvalue", "adjpvalue", "log2fc", "statistical_significance"], "biomarker": "drop_all"}, "ground_truth": "SELECT differential_expression.pvalue\nFROM differential_expression\n         JOIN disease ON differential_expression.doid = disease.id\nWHERE disease.name = 'lung cancer'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT de.pvalue \nFROM differential_expression AS de \nJOIN disease AS d ON de.doid = d.id \nWHERE d.name = 'lung cancer';", "qa_pairs": "To retrieve the p-value of differential expressions for the disease 'lung cancer', you need to join the `differential_expression` table with the `disease` table based on the `doid` field. The SQL query will filter the results to only include those related to 'lung cancer'.\n\nHere is the SQL query:\n\n```sql\nSELECT de.pvalue \nFROM differential_expression AS de \nJOIN disease AS d ON de.doid = d.id \nWHERE d.name = 'lung cancer';\n```\n\nThis query selects the `pvalue` from the `differential_expression` table where the associated disease name is 'lung cancer'.", "fixed": false, "try_times": 1, "pred": "SELECT de.pvalue \nFROM differential_expression AS de \nJOIN disease AS d ON de.doid = d.id \nWHERE d.name = 'lung cancer';"}
{"idx": 119, "db_id": "oncomx", "query": "Show disease mutation chromosome positions for skin cancer", "evidence": "", "extracted_schema": {"disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "disease": ["id", "name"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"]}, "ground_truth": "SELECT disease_mutation.chromosome_pos\nFROM disease_mutation\n         JOIN disease ON disease_mutation.doid = disease.id\nWHERE disease.name = 'skin cancer'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT chromosome_pos \nFROM disease_mutation \nWHERE doid = (SELECT id FROM disease WHERE name = 'skin cancer');", "qa_pairs": "To retrieve the chromosome positions for disease mutations specifically related to skin cancer, we need to join the `disease_mutation` table with the `disease` table to filter for skin cancer. The SQL query would look like this:\n\n```sql\nSELECT chromosome_pos \nFROM disease_mutation \nWHERE doid = (SELECT id FROM disease WHERE name = 'skin cancer');\n```\n\nThis query selects the `chromosome_pos` from the `disease_mutation` table where the `doid` matches the ID of the disease named 'skin cancer'.", "fixed": false, "try_times": 1, "pred": "SELECT chromosome_pos \nFROM disease_mutation \nWHERE doid = (SELECT id FROM disease WHERE name = 'skin cancer');"}
{"idx": 120, "db_id": "oncomx", "query": "List all disease mutation chromosome positions data for disease skin cancer", "evidence": "", "extracted_schema": {"disease_mutation": ["id", "chromosome_pos", "chromosome_id", "ref_nt", "alt_nt", "ensembl_transcript_id"], "disease": ["id", "name"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"]}, "ground_truth": "SELECT disease_mutation.chromosome_pos\nFROM disease_mutation\n         JOIN disease ON disease_mutation.doid = disease.id\nWHERE disease.name = 'skin cancer'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT dm.chromosome_pos \nFROM disease_mutation AS dm \nJOIN disease AS d ON dm.doid = d.id \nWHERE d.name = 'skin cancer';", "qa_pairs": "To list all disease mutation chromosome positions data for the disease \"skin cancer,\" we need to join the `disease_mutation` table with the `disease` table to filter for the specific disease. We will then select the relevant columns from the `disease_mutation` table.\n\nHere's the SQL query to achieve this:\n\n```sql\nSELECT dm.chromosome_pos \nFROM disease_mutation AS dm \nJOIN disease AS d ON dm.doid = d.id \nWHERE d.name = 'skin cancer';\n```\n\nThis query selects the chromosome positions from the `disease_mutation` table where the associated disease name is \"skin cancer.\"", "fixed": false, "try_times": 1, "pred": "SELECT dm.chromosome_pos \nFROM disease_mutation AS dm \nJOIN disease AS d ON dm.doid = d.id \nWHERE d.name = 'skin cancer';"}
{"idx": 121, "db_id": "oncomx", "query": "Show me all information about disease mutations with amino acid residue (ref_aa) equal to E", "evidence": "", "extracted_schema": {"disease_mutation": "keep_all", "disease_mutation_site_annotation": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_tissue": "drop_all", "disease": "drop_all", "biomarker": "drop_all", "biomarker_edrn": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_use": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_article": "drop_all", "biomarker_alias": "drop_all", "healthy_expression": "drop_all", "anatomical_entity": "drop_all", "map_uniprot_canonical_id": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all", "differential_expression": "drop_all", "species": "drop_all", "stage": "drop_all"}, "ground_truth": "SELECT * FROM disease_mutation WHERE ref_aa = 'E'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT * FROM disease_mutation WHERE ref_aa = 'E';", "qa_pairs": "To retrieve all information about disease mutations where the amino acid residue (`ref_aa`) is equal to 'E', you would need to query the `disease_mutation` table. The SQL query would look like this:\n\n```sql\nSELECT * FROM disease_mutation WHERE ref_aa = 'E';\n```\n\nHowever, since the `ref_aa` column is not explicitly listed in the provided schema for the `disease_mutation` table, it seems there might be a misunderstanding. The `ref_aa` is mentioned in the context of the `disease_mutation` table, but it is not clear if it is part of the schema you provided. \n\nAssuming `ref_aa` is indeed a column in the `disease_mutation` table, the SQL query would be as shown above. If `ref_aa` is not part of the schema, please clarify or check the schema for the correct column names.", "fixed": false, "try_times": 1, "pred": "SELECT * FROM disease_mutation WHERE ref_aa = 'E';"}
{"idx": 122, "db_id": "oncomx", "query": "How many FDA tests did manufacturer 23andMe?", "evidence": "", "extracted_schema": {"biomarker_fda_test": ["test_trade_name", "test_submission", "test_manufacturer", "biomarker_origin", "doid", "histological_type"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"]}, "ground_truth": "SELECT count(*)\nFROM biomarker_fda_test\nWHERE biomarker_fda_test.test_manufacturer = '23andMe'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT COUNT(*) \nFROM biomarker_fda_test \nWHERE test_manufacturer = '23andMe';", "qa_pairs": "To find out how many FDA tests were conducted by the manufacturer \"23andMe\", we need to query the `biomarker_fda_test` table, which contains information about FDA tests and their manufacturers. We will count the number of entries where the manufacturer is \"23andMe\".\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT COUNT(*) \nFROM biomarker_fda_test \nWHERE test_manufacturer = '23andMe';\n```\n\nThis query counts all rows in the `biomarker_fda_test` table where the `test_manufacturer` is \"23andMe\".", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(*) \nFROM biomarker_fda_test \nWHERE test_manufacturer = '23andMe';"}
{"idx": 123, "db_id": "oncomx", "query": "What are the name of cancer types where the A1BG gene expression is significantly increased (up regulated)", "evidence": "", "extracted_schema": {"disease": "keep_all", "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"], "biomarker": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_use": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_edrn": "drop_all", "biomarker_article": "drop_all", "biomarker_alias": "drop_all", "disease_mutation": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease_mutation_tissue": "drop_all", "healthy_expression": "drop_all", "anatomical_entity": "drop_all", "map_uniprot_canonical_id": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all", "stage": "drop_all", "xref_gene_ensembl": "drop_all", "species": "drop_all"}, "ground_truth": "SELECT disease.name\nFROM differential_expression\n         JOIN disease ON differential_expression.doid = disease.id\nWHERE differential_expression.gene_symbol = 'A1BG'\n  and differential_expression.expression_change_direction = 'up'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT d.name \nFROM disease AS d \nJOIN differential_expression AS de ON d.id = de.doid \nWHERE de.gene_symbol = 'A1BG' AND de.statistical_significance = 'Yes' AND de.log2fc > 0;", "qa_pairs": "To find the names of cancer types where the A1BG gene expression is significantly increased (upregulated), we need to join the `disease` table with the `differential_expression` table. We will filter for the A1BG gene and check for the condition of being significantly increased, which is indicated by the `statistical_significance` column having the value 'Yes' and the `log2fc` column being greater than 0.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT d.name \nFROM disease AS d \nJOIN differential_expression AS de ON d.id = de.doid \nWHERE de.gene_symbol = 'A1BG' AND de.statistical_significance = 'Yes' AND de.log2fc > 0;\n```\n\nThis query selects the names of cancer types from the `disease` table where the A1BG gene expression is significantly increased.", "fixed": false, "try_times": 1, "pred": "SELECT d.name \nFROM disease AS d \nJOIN differential_expression AS de ON d.id = de.doid \nWHERE de.gene_symbol = 'A1BG' AND de.statistical_significance = 'Yes' AND de.log2fc > 0;"}
{"idx": 124, "db_id": "oncomx", "query": "Show me all information about species", "evidence": "", "extracted_schema": {"species": "keep_all", "biomarker": "drop_all", "biomarker_alias": "drop_all", "biomarker_article": "drop_all", "biomarker_edrn": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_use": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease": "drop_all", "xref_gene_ensembl": "drop_all", "stage": "drop_all", "disease_mutation": "drop_all", "healthy_expression": "drop_all", "anatomical_entity": "drop_all", "map_uniprot_canonical_id": "drop_all", "disease_mutation_tissue": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all", "differential_expression": "drop_all"}, "ground_truth": "SELECT * FROM species", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT * FROM species;", "qa_pairs": "```sql\nSELECT * FROM species;\n```", "fixed": false, "try_times": 1, "pred": "SELECT * FROM species;"}
{"idx": 125, "db_id": "oncomx", "query": "Return the symbol and p-value for the expression of EGFR in lung cancer ", "evidence": "", "extracted_schema": {"biomarker": ["biomarker_id", "gene_symbol", "biomarker_description"], "disease": ["id", "name"], "differential_expression": ["gene_symbol", "doid", "pvalue", "log2fc", "adjpvalue", "statistical_significance"]}, "ground_truth": "SELECT differential_expression.gene_symbol,\n       differential_expression.pvalue\nFROM differential_expression JOIN disease ON differential_expression.doid = disease.id\nWHERE differential_expression.gene_symbol = 'EGFR' AND disease.name = 'lung cancer'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["gene_symbol", "biomarker_description", "biomarker_id"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT de.gene_symbol, de.pvalue\nFROM differential_expression AS de\nJOIN disease AS d ON de.doid = d.id\nWHERE de.gene_symbol = 'EGFR' AND d.name = 'lung cancer';", "qa_pairs": "To return the symbol and p-value for the expression of EGFR in lung cancer, we need to join the relevant tables based on the relationships defined in the schema. The `differential_expression` table contains the gene symbols and their associated p-values, while the `disease` table contains the disease names, including lung cancer.\n\nAssuming \"lung cancer\" corresponds to a specific `doid` in the `disease` table, we will first need to find the `doid` for lung cancer and then filter the `differential_expression` table for the gene symbol \"EGFR\" and the corresponding `doid`.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT de.gene_symbol, de.pvalue\nFROM differential_expression AS de\nJOIN disease AS d ON de.doid = d.id\nWHERE de.gene_symbol = 'EGFR' AND d.name = 'lung cancer';\n```\n\nThis query selects the `gene_symbol` and `pvalue` from the `differential_expression` table, joining it with the `disease` table to filter for lung cancer.", "fixed": false, "try_times": 1, "pred": "SELECT de.gene_symbol, de.pvalue\nFROM differential_expression AS de\nJOIN disease AS d ON de.doid = d.id\nWHERE de.gene_symbol = 'EGFR' AND d.name = 'lung cancer';"}
{"idx": 126, "db_id": "oncomx", "query": "Return gen symbol and pvalue for the expression of gene with symbol 'EGFR' in lung cancer ", "evidence": "", "extracted_schema": {"biomarker": ["gene_symbol", "biomarker_id", "biomarker_description"], "disease": ["id", "name"], "differential_expression": ["gene_symbol", "doid", "pvalue", "log2fc", "adjpvalue", "statistical_significance"]}, "ground_truth": "SELECT differential_expression.gene_symbol,\n       differential_expression.pvalue\nFROM differential_expression JOIN disease ON differential_expression.doid = disease.id\nWHERE differential_expression.gene_symbol = 'EGFR' AND disease.name = 'lung cancer'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["gene_symbol", "biomarker_description", "biomarker_id"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT gene_symbol, pvalue \nFROM differential_expression \nWHERE doid = (SELECT id FROM disease WHERE name = 'lung cancer') \nAND gene_symbol = 'EGFR';", "qa_pairs": "To retrieve the gene symbol and p-value for the expression of the gene with the symbol 'EGFR' in lung cancer, we need to join the `differential_expression` table with the `disease` table to filter for lung cancer. The SQL query would look like this:\n\n```sql\nSELECT gene_symbol, pvalue \nFROM differential_expression \nWHERE doid = (SELECT id FROM disease WHERE name = 'lung cancer') \nAND gene_symbol = 'EGFR';\n```\n\nThis query selects the `gene_symbol` and `pvalue` from the `differential_expression` table where the `doid` matches the ID of lung cancer from the `disease` table and the `gene_symbol` is 'EGFR'.", "fixed": false, "try_times": 1, "pred": "SELECT gene_symbol, pvalue \nFROM differential_expression \nWHERE doid = (SELECT id FROM disease WHERE name = 'lung cancer') \nAND gene_symbol = 'EGFR';"}
{"idx": 127, "db_id": "oncomx", "query": "Show all information about disease mutations", "evidence": "", "extracted_schema": {"disease_mutation": "keep_all", "disease_mutation_article": "keep_all", "disease_mutation_impact_prediction": "keep_all", "disease_mutation_site_annotation": "keep_all", "disease_mutation_tissue": "keep_all"}, "ground_truth": "SELECT * FROM disease_mutation", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT * FROM disease_mutation", "qa_pairs": "```sql\nSELECT * FROM disease_mutation\n```", "fixed": false, "try_times": 1, "pred": "SELECT * FROM disease_mutation"}
{"idx": 128, "db_id": "oncomx", "query": "How many healthy expression are there for 'late adult stage'?", "evidence": "", "extracted_schema": {"healthy_expression": "keep_all", "stage": "keep_all", "anatomical_entity": "drop_all", "biomarker": "drop_all"}, "ground_truth": "SELECT COUNT(*) FROM healthy_expression JOIN stage ON healthy_expression.uberon_developmental_id = stage.id WHERE stage.name = 'late adult stage'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT COUNT(*) \nFROM healthy_expression AS HE \nJOIN stage AS S ON HE.uberon_developmental_id = S.id \nWHERE S.name = 'late adult stage';", "qa_pairs": "To find out how many healthy expressions there are for the 'late adult stage', we need to join the `healthy_expression` table with the `stage` table based on the `uberon_developmental_id` in the `healthy_expression` table and the `id` in the `stage` table. We will then filter the results to only include those that match the 'late adult stage' and count the number of entries.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT COUNT(*) \nFROM healthy_expression AS HE \nJOIN stage AS S ON HE.uberon_developmental_id = S.id \nWHERE S.name = 'late adult stage';\n``` \n\nThis query counts the number of healthy expressions associated with the 'late adult stage'.", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(*) \nFROM healthy_expression AS HE \nJOIN stage AS S ON HE.uberon_developmental_id = S.id \nWHERE S.name = 'late adult stage';"}
{"idx": 129, "db_id": "oncomx", "query": "Show name of diseases where the A1BG gene expression is statistically significant", "evidence": "", "extracted_schema": {"disease": "keep_all", "differential_expression": ["doid", "gene_symbol", "statistical_significance", "log2fc", "pvalue", "adjpvalue"], "biomarker": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_use": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_edrn": "drop_all", "biomarker_article": "drop_all", "biomarker_alias": "drop_all", "disease_mutation": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease_mutation_tissue": "drop_all", "healthy_expression": "drop_all", "anatomical_entity": "drop_all", "map_uniprot_canonical_id": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all", "stage": "drop_all", "xref_gene_ensembl": "drop_all", "species": "drop_all"}, "ground_truth": "SELECT disease.name\nFROM differential_expression\n         JOIN disease ON differential_expression.doid = disease.id\nWHERE differential_expression.gene_symbol = 'A1BG'\n  and differential_expression.statistical_significance = 'Yes'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT d.name \nFROM differential_expression AS de \nJOIN disease AS d ON de.doid = d.id \nWHERE de.gene_symbol = 'A1BG' AND de.statistical_significance = 'Yes';", "qa_pairs": "To retrieve the names of diseases where the A1BG gene expression is statistically significant, we need to join the `differential_expression` table with the `disease` table based on the `doid` field. We will filter the results to include only those records where the `gene_symbol` is 'A1BG' and the `statistical_significance` is 'Yes'.\n\nHere is the corresponding SQL query:\n\n```sql\nSELECT d.name \nFROM differential_expression AS de \nJOIN disease AS d ON de.doid = d.id \nWHERE de.gene_symbol = 'A1BG' AND de.statistical_significance = 'Yes';\n```", "fixed": false, "try_times": 1, "pred": "SELECT d.name \nFROM differential_expression AS de \nJOIN disease AS d ON de.doid = d.id \nWHERE de.gene_symbol = 'A1BG' AND de.statistical_significance = 'Yes';"}
{"idx": 130, "db_id": "oncomx", "query": "Show name of diseases where the gene expression with symbol A1BG has a statistical significance of 'Yes'", "evidence": "", "extracted_schema": {"disease": "keep_all", "differential_expression": ["doid", "gene_symbol", "statistical_significance", "log2fc", "pvalue", "adjpvalue"], "biomarker": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_use": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_edrn": "drop_all", "biomarker_article": "drop_all", "biomarker_alias": "drop_all", "disease_mutation": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease_mutation_tissue": "drop_all", "healthy_expression": "drop_all", "anatomical_entity": "drop_all", "map_uniprot_canonical_id": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all", "stage": "drop_all", "xref_gene_ensembl": "drop_all", "species": "drop_all"}, "ground_truth": "SELECT disease.name\nFROM differential_expression\n         JOIN disease ON differential_expression.doid = disease.id\nWHERE differential_expression.gene_symbol = 'A1BG'\n  and differential_expression.statistical_significance = 'Yes'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT d.name \nFROM differential_expression AS de \nJOIN disease AS d ON de.doid = d.id \nWHERE de.gene_symbol = 'A1BG' AND de.statistical_significance = 'Yes';", "qa_pairs": "To retrieve the names of diseases where the gene expression with the symbol 'A1BG' has a statistical significance of 'Yes', we need to join the `differential_expression` table with the `disease` table based on the `doid` field. Here is the SQL query that accomplishes this:\n\n```sql\nSELECT d.name \nFROM differential_expression AS de \nJOIN disease AS d ON de.doid = d.id \nWHERE de.gene_symbol = 'A1BG' AND de.statistical_significance = 'Yes';\n```\n\nThis query selects the names of diseases from the `disease` table where the corresponding entries in the `differential_expression` table have the gene symbol 'A1BG' and a statistical significance of 'Yes'.", "fixed": false, "try_times": 1, "pred": "SELECT d.name \nFROM differential_expression AS de \nJOIN disease AS d ON de.doid = d.id \nWHERE de.gene_symbol = 'A1BG' AND de.statistical_significance = 'Yes';"}
{"idx": 131, "db_id": "oncomx", "query": "Show me the description of all biomarkers", "evidence": "", "extracted_schema": {"biomarker": "keep_all", "biomarker_alias": "keep_all", "biomarker_article": "drop_all", "biomarker_edrn": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_use": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease": "drop_all", "xref_gene_ensembl": "drop_all", "species": "drop_all", "stage": "drop_all", "disease_mutation": "drop_all", "healthy_expression": "drop_all", "anatomical_entity": "drop_all", "map_uniprot_canonical_id": "drop_all", "disease_mutation_tissue": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all", "differential_expression": "drop_all"}, "ground_truth": "SELECT biomarker_description FROM biomarker", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT biomarker_description FROM biomarker;", "qa_pairs": "```sql\nSELECT biomarker_description FROM biomarker;\n```", "fixed": false, "try_times": 1, "pred": "SELECT biomarker_description FROM biomarker;"}
{"idx": 132, "db_id": "oncomx", "query": "Show the gene symbol and the description of cancer biomarkers which are not in a panel", "evidence": "", "extracted_schema": {"biomarker": ["gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_edrn": "drop_all"}, "ground_truth": "SELECT biomarker.gene_symbol, biomarker_description FROM biomarker WHERE test_is_a_panel = 'false'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT biomarker.gene_symbol, biomarker.biomarker_description \nFROM biomarker \nWHERE biomarker.test_is_a_panel = 'false';", "qa_pairs": "```sql\nSELECT biomarker.gene_symbol, biomarker.biomarker_description \nFROM biomarker \nWHERE biomarker.test_is_a_panel = 'false';\n```", "fixed": false, "try_times": 1, "pred": "SELECT biomarker.gene_symbol, biomarker.biomarker_description \nFROM biomarker \nWHERE biomarker.test_is_a_panel = 'false';"}
{"idx": 133, "db_id": "oncomx", "query": "What is the test trade name for FDA tests which are actually used for predisposition?", "evidence": "", "extracted_schema": {"biomarker_fda_test_use": "keep_all", "biomarker_fda_test": "keep_all", "biomarker_fda": "keep_all"}, "ground_truth": "SELECT test_trade_name FROM biomarker_fda_test_use WHERE actual_use = 'predisposition'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT test_trade_name \nFROM biomarker_fda_test_use \nWHERE actual_use = 'predisposition';", "qa_pairs": "```sql\nSELECT test_trade_name \nFROM biomarker_fda_test_use \nWHERE actual_use = 'predisposition';\n```", "fixed": false, "try_times": 1, "pred": "SELECT test_trade_name \nFROM biomarker_fda_test_use \nWHERE actual_use = 'predisposition';"}
{"idx": 134, "db_id": "oncomx", "query": "Show me the gene symbol of biomarkers", "evidence": "", "extracted_schema": {"biomarker": "keep_all", "biomarker_alias": "drop_all", "biomarker_article": "drop_all", "biomarker_edrn": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_use": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease": "drop_all", "xref_gene_ensembl": "drop_all", "species": "drop_all", "stage": "drop_all", "disease_mutation": "drop_all", "healthy_expression": "drop_all", "anatomical_entity": "drop_all", "map_uniprot_canonical_id": "drop_all", "disease_mutation_tissue": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all", "differential_expression": "drop_all"}, "ground_truth": "SELECT gene_symbol FROM biomarker", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT gene_symbol FROM biomarker;", "qa_pairs": "```sql\nSELECT gene_symbol FROM biomarker;\n```", "fixed": false, "try_times": 1, "pred": "SELECT gene_symbol FROM biomarker;"}
{"idx": 135, "db_id": "oncomx", "query": "Show me all biomarkers on the EDRN platform with type protein in phase two.", "evidence": "", "extracted_schema": {"biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "phase"], "biomarker": "drop_all", "biomarker_alias": "drop_all", "biomarker_article": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_test_use": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease": "drop_all", "xref_gene_ensembl": "drop_all", "species": "drop_all", "stage": "drop_all", "disease_mutation": "drop_all", "healthy_expression": "drop_all", "anatomical_entity": "drop_all", "map_uniprot_canonical_id": "drop_all", "disease_mutation_tissue": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all", "differential_expression": "drop_all"}, "ground_truth": "SELECT biomarker_title FROM biomarker_edrn WHERE biomarker_type = 'Protein' AND phase = 'Two'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT * FROM biomarker_edrn WHERE biomarker_type = 'Protein' AND phase = 'Two'", "qa_pairs": "```sql\nSELECT * FROM biomarker_edrn WHERE biomarker_type = 'Protein' AND phase = 'Two'\n```", "fixed": false, "try_times": 1, "pred": "SELECT * FROM biomarker_edrn WHERE biomarker_type = 'Protein' AND phase = 'Two'"}
{"idx": 136, "db_id": "oncomx", "query": "Show me the title of all biomarkers on the EDRN platform with biomarker type Protein in phase Two.", "evidence": "", "extracted_schema": {"biomarker_edrn": ["biomarker_title", "biomarker_type", "phase", "qa_state", "id", "uberon_anatomical_id"], "biomarker": ["biomarker_id", "gene_symbol", "biomarker_description", "id", "test_is_a_panel"], "biomarker_fda": ["id", "test_trade_name", "test_submission"]}, "ground_truth": "SELECT biomarker_title FROM biomarker_edrn WHERE biomarker_type = 'Protein' AND phase = 'Two'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT biomarker_edrn.biomarker_title \nFROM biomarker_edrn \nWHERE biomarker_edrn.biomarker_type = 'Protein' \nAND biomarker_edrn.phase = 'Two';", "qa_pairs": "```sql\nSELECT biomarker_edrn.biomarker_title \nFROM biomarker_edrn \nWHERE biomarker_edrn.biomarker_type = 'Protein' \nAND biomarker_edrn.phase = 'Two';\n```", "fixed": false, "try_times": 1, "pred": "SELECT biomarker_edrn.biomarker_title \nFROM biomarker_edrn \nWHERE biomarker_edrn.biomarker_type = 'Protein' \nAND biomarker_edrn.phase = 'Two';"}
{"idx": 137, "db_id": "oncomx", "query": "Get the biomarker gene symbol and biomarker description for disease with name 'breast cancer'", "evidence": "", "extracted_schema": {"biomarker": "keep_all", "biomarker_fda": "drop_all", "biomarker_edrn": "drop_all", "disease": ["id", "name"], "biomarker_article": "drop_all", "biomarker_alias": "drop_all"}, "ground_truth": "SELECT biomarker.gene_symbol, biomarker.biomarker_description\nFROM biomarker\n         JOIN biomarker_fda on biomarker.id = biomarker_fda.id\n         JOIN biomarker_fda_test ON biomarker_fda.test_submission = biomarker_fda_test.test_submission and\n                                    biomarker_fda.test_trade_name = biomarker_fda_test.test_trade_name\n         JOIN disease ON disease.id = biomarker_fda_test.doid\nWHERE disease.name = 'breast cancer'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT b.gene_symbol, b.biomarker_description\nFROM biomarker AS b\nJOIN biomarker_fda_test AS bf ON b.biomarker_id = bf.doid\nJOIN disease AS d ON bf.doid = d.id\nWHERE d.name = 'breast cancer';", "qa_pairs": "To retrieve the biomarker gene symbol and biomarker description for the disease with the name 'breast cancer', you will need to join the `biomarker` table with the `disease` table based on the `doid` (disease ID). However, since the `disease` table does not have a direct relationship with the `biomarker` table, you will need to use the `biomarker_fda_test` table to connect them through the `doid`.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT b.gene_symbol, b.biomarker_description\nFROM biomarker AS b\nJOIN biomarker_fda_test AS bf ON b.biomarker_id = bf.doid\nJOIN disease AS d ON bf.doid = d.id\nWHERE d.name = 'breast cancer';\n```\n\nThis query selects the `gene_symbol` and `biomarker_description` from the `biomarker` table where the disease name is 'breast cancer'. Make sure to adjust the joins based on the actual relationships in your database schema if necessary.", "fixed": true, "try_times": 3, "pred": "SELECT b.gene_symbol, b.biomarker_description\nFROM biomarker AS b\nJOIN biomarker_fda_test AS bf ON b.id = bf.doid\nJOIN disease AS d ON bf.doid = d.id\nWHERE d.name = 'breast cancer';"}
{"idx": 138, "db_id": "oncomx", "query": "Get all distinct biomarker EDRN phases", "evidence": "", "extracted_schema": {"biomarker_edrn": "keep_all", "biomarker": "drop_all", "biomarker_alias": "drop_all", "biomarker_article": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_test_use": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease": "drop_all", "xref_gene_ensembl": "drop_all", "species": "drop_all", "stage": "drop_all", "disease_mutation": "drop_all", "healthy_expression": "drop_all", "anatomical_entity": "drop_all", "map_uniprot_canonical_id": "drop_all", "disease_mutation_tissue": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all", "differential_expression": "drop_all"}, "ground_truth": "SELECT DISTINCT phase from biomarker_edrn", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT DISTINCT phase FROM biomarker_edrn;", "qa_pairs": "```sql\nSELECT DISTINCT phase FROM biomarker_edrn;\n```", "fixed": true, "try_times": 2, "pred": "-- SQL Type: SELECT\nSELECT DISTINCT phase \nFROM biomarker_edrn \nWHERE phase IS NOT NULL;"}
{"idx": 139, "db_id": "oncomx", "query": "Show the pvalue of differential expression of lung cancer", "evidence": "", "extracted_schema": {"differential_expression": "keep_all", "disease": "keep_all", "biomarker": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_test": "drop_all"}, "ground_truth": "SELECT differential_expression.pvalue\nFROM differential_expression\n         JOIN disease ON differential_expression.doid = disease.id\nWHERE disease.name = 'lung cancer'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT pvalue \nFROM differential_expression \nWHERE doid = (SELECT id FROM disease WHERE name = 'lung cancer');", "qa_pairs": "To retrieve the p-value of differential expression specifically for lung cancer, we need to identify the `doid` associated with lung cancer from the `disease` table and then use that `doid` to filter the results in the `differential_expression` table.\n\nHere’s the SQL query to achieve that:\n\n```sql\nSELECT pvalue \nFROM differential_expression \nWHERE doid = (SELECT id FROM disease WHERE name = 'lung cancer');\n```\n\nThis query first finds the `id` (doid) for lung cancer from the `disease` table and then uses that `doid` to select the corresponding `pvalue` from the `differential_expression` table.", "fixed": false, "try_times": 1, "pred": "SELECT pvalue \nFROM differential_expression \nWHERE doid = (SELECT id FROM disease WHERE name = 'lung cancer');"}
{"idx": 140, "db_id": "oncomx", "query": "How many genes are there for species Homo?", "evidence": "", "extracted_schema": {"species": "keep_all", "xref_gene_ensembl": "keep_all", "biomarker": "drop_all", "biomarker_alias": "drop_all", "biomarker_article": "drop_all", "biomarker_edrn": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_use": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease": "drop_all", "stage": "drop_all", "disease_mutation": "drop_all", "healthy_expression": "drop_all", "anatomical_entity": "drop_all", "map_uniprot_canonical_id": "drop_all", "disease_mutation_tissue": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all", "differential_expression": "drop_all"}, "ground_truth": "SELECT count(*) FROM xref_gene_ensembl JOIN species ON xref_gene_ensembl.speciesid = species.speciesid WHERE species.genus = 'Homo'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT COUNT(DISTINCT xref_gene_ensembl.gene_symbol) \nFROM xref_gene_ensembl \nJOIN species ON xref_gene_ensembl.speciesid = species.speciesid \nWHERE species.genus = 'Homo';", "qa_pairs": "To find out how many genes there are for the species \"Homo,\" we need to query the `xref_gene_ensembl` table, which contains the `gene_symbol` and `speciesid`. We will join this table with the `species` table to filter for the species \"Homo.\"\n\nHere's the SQL query to achieve this:\n\n```sql\nSELECT COUNT(DISTINCT xref_gene_ensembl.gene_symbol) \nFROM xref_gene_ensembl \nJOIN species ON xref_gene_ensembl.speciesid = species.speciesid \nWHERE species.genus = 'Homo';\n```\n\nThis query counts the distinct gene symbols associated with the species \"Homo\" by joining the `xref_gene_ensembl` table with the `species` table based on the `speciesid`.", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(DISTINCT xref_gene_ensembl.gene_symbol) \nFROM xref_gene_ensembl \nJOIN species ON xref_gene_ensembl.speciesid = species.speciesid \nWHERE species.genus = 'Homo';"}
{"idx": 141, "db_id": "oncomx", "query": "How many genes ensembles are there for species with genus Homo?", "evidence": "", "extracted_schema": {"xref_gene_ensembl": "keep_all", "species": ["speciesid", "genus", "species", "speciescommonname"], "biomarker": "drop_all"}, "ground_truth": "SELECT count(*) FROM xref_gene_ensembl JOIN species ON xref_gene_ensembl.speciesid = species.speciesid WHERE species.genus = 'Homo'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT COUNT(DISTINCT xref_gene_ensembl.ensembl_gene_id) AS gene_ensemble_count\nFROM xref_gene_ensembl\nJOIN species ON xref_gene_ensembl.speciesid = species.speciesid\nWHERE species.genus = 'Homo';", "qa_pairs": "To find the number of gene ensembles for species with the genus \"Homo\", you can use the following SQL query. This query counts the distinct `ensembl_gene_id` entries from the `xref_gene_ensembl` table, joining it with the `species` table to filter for the genus \"Homo\".\n\n```sql\nSELECT COUNT(DISTINCT xref_gene_ensembl.ensembl_gene_id) AS gene_ensemble_count\nFROM xref_gene_ensembl\nJOIN species ON xref_gene_ensembl.speciesid = species.speciesid\nWHERE species.genus = 'Homo';\n```\n\nThis SQL statement will return the count of unique gene ensembles associated with species that belong to the genus \"Homo\".", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(DISTINCT xref_gene_ensembl.ensembl_gene_id) AS gene_ensemble_count\nFROM xref_gene_ensembl\nJOIN species ON xref_gene_ensembl.speciesid = species.speciesid\nWHERE species.genus = 'Homo';"}
{"idx": 142, "db_id": "oncomx", "query": "Show tests built by a manufacturer starting with 'Roche' ", "evidence": "", "extracted_schema": {"biomarker_fda_test": "keep_all", "biomarker_fda": "keep_all", "biomarker": "drop_all", "biomarker_fda_test_use": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_test_trial": "drop_all"}, "ground_truth": "SELECT *\nFROM biomarker_fda_test\nWHERE test_manufacturer like 'Roche%'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT DISTINCT test_trade_name \nFROM biomarker_fda_test \nWHERE test_manufacturer LIKE 'Roche%'", "qa_pairs": "```sql\nSELECT DISTINCT test_trade_name \nFROM biomarker_fda_test \nWHERE test_manufacturer LIKE 'Roche%'\n```", "fixed": false, "try_times": 1, "pred": "SELECT DISTINCT test_trade_name \nFROM biomarker_fda_test \nWHERE test_manufacturer LIKE 'Roche%'"}
{"idx": 143, "db_id": "oncomx", "query": "Show submissions of biomarker FDA tests from test manufacturer starting with 'Roche' ", "evidence": "", "extracted_schema": {"biomarker_fda_test": ["test_trade_name", "test_submission", "test_manufacturer", "biomarker_origin", "doid", "histological_type"], "biomarker_fda": "keep_all", "biomarker": "keep_all", "biomarker_fda_test_use": "drop_all"}, "ground_truth": "SELECT test_submission\nFROM biomarker_fda_test\nWHERE test_manufacturer like 'Roche%'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT test_trade_name, test_submission \nFROM biomarker_fda_test \nWHERE test_manufacturer LIKE 'Roche%'", "qa_pairs": "```sql\nSELECT test_trade_name, test_submission \nFROM biomarker_fda_test \nWHERE test_manufacturer LIKE 'Roche%'\n```", "fixed": false, "try_times": 1, "pred": "SELECT test_trade_name, test_submission \nFROM biomarker_fda_test \nWHERE test_manufacturer LIKE 'Roche%'"}
{"idx": 144, "db_id": "oncomx", "query": "Which diseases (name) have a mutation with a coding sequence position of 102997?", "evidence": "", "extracted_schema": {"disease": "keep_all", "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "cds_pos", "ref_nt", "alt_nt"], "disease_mutation_site_annotation": "drop_all"}, "ground_truth": "SELECT disease.name\nFROM disease JOIN disease_mutation ON disease.id = disease_mutation.doid\nWHERE disease_mutation.cds_pos = 102997", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT d.name \nFROM disease AS d \nJOIN disease_mutation AS dm ON d.id = dm.doid \nWHERE dm.cds_pos = 102997;", "qa_pairs": "To find the diseases that have a mutation with a coding sequence position of 102997, we need to join the `disease_mutation` table with the `disease` table based on the `doid` field. The `disease_mutation` table contains the `cds_pos` field, which we will filter for the value 102997.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT d.name \nFROM disease AS d \nJOIN disease_mutation AS dm ON d.id = dm.doid \nWHERE dm.cds_pos = 102997;\n```\n\nThis query selects the names of diseases from the `disease` table that have a corresponding mutation in the `disease_mutation` table with a coding sequence position of 102997.", "fixed": true, "try_times": 2, "pred": "SELECT DISTINCT cds_pos \nFROM disease_mutation \nWHERE cds_pos IS NOT NULL;"}
{"idx": 145, "db_id": "oncomx", "query": "Show me all diseases having a mutation with a coding sequence position (cds_pos) of 102997?", "evidence": "", "extracted_schema": {"disease": "keep_all", "disease_mutation": ["id", "cds_pos", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt"], "disease_mutation_site_annotation": "drop_all"}, "ground_truth": "SELECT disease.name\nFROM disease JOIN disease_mutation ON disease.id = disease_mutation.doid\nWHERE disease_mutation.cds_pos = 102997", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT d.name \nFROM disease AS d \nJOIN disease_mutation AS dm ON d.id = dm.doid \nWHERE dm.cds_pos = 102997;", "qa_pairs": "To retrieve all diseases that have a mutation with a coding sequence position (`cds_pos`) of 102997, you will need to join the `disease_mutation` table with the `disease` table based on the `doid` field. Here’s the SQL query that accomplishes this:\n\n```sql\nSELECT d.name \nFROM disease AS d \nJOIN disease_mutation AS dm ON d.id = dm.doid \nWHERE dm.cds_pos = 102997;\n```\n\nThis query selects the names of diseases from the `disease` table that are associated with mutations in the `disease_mutation` table where the `cds_pos` is equal to 102997.", "fixed": true, "try_times": 3, "pred": "SELECT COUNT(*) \nFROM disease_mutation \nWHERE cds_pos = 102997;"}
{"idx": 146, "db_id": "oncomx", "query": "Show me all gene symbols expressed with a pvalue between 0.39 and 0.41", "evidence": "", "extracted_schema": {"differential_expression": "keep_all", "biomarker": "drop_all", "biomarker_alias": "drop_all", "biomarker_article": "drop_all", "biomarker_edrn": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_use": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease": "drop_all", "xref_gene_ensembl": "drop_all", "species": "drop_all", "stage": "drop_all", "disease_mutation": "drop_all", "healthy_expression": "drop_all", "anatomical_entity": "drop_all", "map_uniprot_canonical_id": "drop_all", "disease_mutation_tissue": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all"}, "ground_truth": "SELECT gene_symbol FROM differential_expression WHERE pvalue > 0.39 AND pvalue < 0.41", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT gene_symbol \nFROM differential_expression \nWHERE pvalue BETWEEN 0.39 AND 0.41;", "qa_pairs": "```sql\nSELECT gene_symbol \nFROM differential_expression \nWHERE pvalue BETWEEN 0.39 AND 0.41;\n```", "fixed": false, "try_times": 1, "pred": "SELECT gene_symbol \nFROM differential_expression \nWHERE pvalue BETWEEN 0.39 AND 0.41;"}
{"idx": 147, "db_id": "oncomx", "query": "Get all gene symbols from expressions with a p-value between 0.39 and 0.41", "evidence": "", "extracted_schema": {"differential_expression": "keep_all", "healthy_expression": "drop_all", "biomarker": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_test": "drop_all"}, "ground_truth": "SELECT gene_symbol FROM differential_expression WHERE pvalue > 0.39 AND pvalue < 0.41", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT gene_symbol \nFROM differential_expression \nWHERE pvalue BETWEEN 0.39 AND 0.41;", "qa_pairs": "```sql\nSELECT gene_symbol \nFROM differential_expression \nWHERE pvalue BETWEEN 0.39 AND 0.41;\n```", "fixed": false, "try_times": 1, "pred": "SELECT gene_symbol \nFROM differential_expression \nWHERE pvalue BETWEEN 0.39 AND 0.41;"}
{"idx": 148, "db_id": "oncomx", "query": "Show the distinct chromosome id's in mutations of breast cancer", "evidence": "", "extracted_schema": {"disease_mutation": ["chromosome_id", "id", "chromosome_pos", "ref_nt", "alt_nt", "mutation_freq"], "disease": ["id", "name"], "biomarker": "drop_all", "biomarker_fda": "drop_all", "disease_mutation_tissue": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_fda": "drop_all", "disease_mutation_fda_test": "drop_all", "disease_mutation_fda_test_use": "drop_all", "disease_mutation_fda_test_trial": "drop_all", "disease_mutation_fda_drug": "drop_all", "disease_mutation_fda_ncit_term": "drop_all", "biomarker_alias": "drop_all", "biomarker_article": "drop_all", "biomarker_edrn": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_use": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "healthy_expression": "drop_all", "anatomical_entity": "drop_all", "map_uniprot_canonical_id": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all", "differential_expression": "drop_all", "xref_gene_ensembl": "drop_all", "species": "drop_all", "stage": "drop_all"}, "ground_truth": "SELECT DISTINCT disease_mutation.chromosome_id\nFROM disease_mutation\n         JOIN disease ON disease_mutation.doid = disease.id\nWHERE disease.name = 'breast cancer'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "mutation_freq", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT DISTINCT dm.chromosome_id\nFROM disease_mutation AS dm\nJOIN disease AS d ON dm.doid = d.id\nWHERE d.name = 'breast cancer';", "qa_pairs": "To retrieve the distinct chromosome IDs in mutations of breast cancer, we need to join the relevant tables that contain information about mutations and the specific disease (breast cancer). Based on the provided schema, we can identify that the `disease` table contains the disease names, and the `disease_mutation` table contains the mutation details including the chromosome ID.\n\nAssuming that \"breast cancer\" is represented in the `disease` table, we can write the SQL query as follows:\n\n```sql\nSELECT DISTINCT dm.chromosome_id\nFROM disease_mutation AS dm\nJOIN disease AS d ON dm.doid = d.id\nWHERE d.name = 'breast cancer';\n```\n\nThis query selects distinct chromosome IDs from the `disease_mutation` table where the associated disease name is \"breast cancer\".", "fixed": false, "try_times": 1, "pred": "SELECT DISTINCT dm.chromosome_id\nFROM disease_mutation AS dm\nJOIN disease AS d ON dm.doid = d.id\nWHERE d.name = 'breast cancer';"}
{"idx": 149, "db_id": "oncomx", "query": "Show the different chromosome id's in mutations of disease 'breast cancer'", "evidence": "", "extracted_schema": {"disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "data_source"], "disease": "keep_all", "disease_mutation_tissue": "drop_all"}, "ground_truth": "SELECT DISTINCT disease_mutation.chromosome_id\nFROM disease_mutation\n         JOIN disease ON disease_mutation.doid = disease.id\nWHERE disease.name = 'breast cancer'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT DISTINCT dm.chromosome_id\nFROM disease AS d\nJOIN disease_mutation AS dm ON d.id = dm.doid\nWHERE d.name = 'breast cancer';", "qa_pairs": "To show the different chromosome IDs in mutations of the disease 'breast cancer', we need to join the `disease` table with the `disease_mutation` table based on the `doid` (disease ID) and then select the distinct `chromosome_id` from the `disease_mutation` table.\n\nHere is the corresponding SQL query:\n\n```sql\nSELECT DISTINCT dm.chromosome_id\nFROM disease AS d\nJOIN disease_mutation AS dm ON d.id = dm.doid\nWHERE d.name = 'breast cancer';\n```\n\nThis query retrieves the unique chromosome IDs associated with mutations related to 'breast cancer'.", "fixed": false, "try_times": 1, "pred": "SELECT DISTINCT dm.chromosome_id\nFROM disease AS d\nJOIN disease_mutation AS dm ON d.id = dm.doid\nWHERE d.name = 'breast cancer';"}
{"idx": 150, "db_id": "oncomx", "query": "Show me the names of all anatomical entities which have a healthy expression with relative gene expression level LOW and a relative anatomical expression level of HIGH", "evidence": "", "extracted_schema": {"healthy_expression": "keep_all", "anatomical_entity": "keep_all", "biomarker": "drop_all", "biomarker_alias": "drop_all", "biomarker_article": "drop_all", "biomarker_edrn": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_use": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease": "drop_all", "xref_gene_ensembl": "drop_all", "species": "drop_all", "stage": "drop_all", "disease_mutation": "drop_all", "disease_mutation_tissue": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all", "differential_expression": "drop_all"}, "ground_truth": "SELECT anatomical_entity.name\nFROM anatomical_entity\n         JOIN healthy_expression ON anatomical_entity.id = healthy_expression.uberon_anatomical_id\nWHERE expression_level_gene_relative = 'LOW'\n  AND expression_level_anatomical_relative = 'HIGH'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT ae.name \nFROM anatomical_entity AS ae \nJOIN healthy_expression AS he ON ae.id = he.uberon_anatomical_id \nWHERE he.expression_level_gene_relative = 'LOW' \nAND he.expression_level_anatomical_relative = 'HIGH';", "qa_pairs": "```sql\nSELECT ae.name \nFROM anatomical_entity AS ae \nJOIN healthy_expression AS he ON ae.id = he.uberon_anatomical_id \nWHERE he.expression_level_gene_relative = 'LOW' \nAND he.expression_level_anatomical_relative = 'HIGH';\n```", "fixed": false, "try_times": 1, "pred": "SELECT ae.name \nFROM anatomical_entity AS ae \nJOIN healthy_expression AS he ON ae.id = he.uberon_anatomical_id \nWHERE he.expression_level_gene_relative = 'LOW' \nAND he.expression_level_anatomical_relative = 'HIGH';"}
{"idx": 151, "db_id": "oncomx", "query": "List the names of anatomical entities having an expression with relative gene expression level LOW and a relative anatomical expression level of HIGH", "evidence": "", "extracted_schema": {"healthy_expression": "keep_all", "anatomical_entity": ["id", "name", "description"], "biomarker": "drop_all", "biomarker_alias": "drop_all", "biomarker_article": "drop_all", "biomarker_edrn": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_use": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease": "drop_all", "xref_gene_ensembl": "drop_all", "species": "drop_all", "stage": "drop_all", "disease_mutation": "drop_all", "disease_mutation_tissue": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all", "differential_expression": "drop_all"}, "ground_truth": "SELECT anatomical_entity.name\nFROM anatomical_entity\n         JOIN healthy_expression ON anatomical_entity.id = healthy_expression.uberon_anatomical_id\nWHERE expression_level_gene_relative = 'LOW'\n  AND expression_level_anatomical_relative = 'HIGH'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT name \nFROM anatomical_entity \nWHERE id IN (\n    SELECT uberon_anatomical_id \n    FROM healthy_expression \n    WHERE expression_level_gene_relative = 'LOW' \n      AND expression_level_anatomical_relative = 'HIGH'\n);", "qa_pairs": "```sql\nSELECT name \nFROM anatomical_entity \nWHERE id IN (\n    SELECT uberon_anatomical_id \n    FROM healthy_expression \n    WHERE expression_level_gene_relative = 'LOW' \n      AND expression_level_anatomical_relative = 'HIGH'\n);\n```", "fixed": false, "try_times": 1, "pred": "SELECT name \nFROM anatomical_entity \nWHERE id IN (\n    SELECT uberon_anatomical_id \n    FROM healthy_expression \n    WHERE expression_level_gene_relative = 'LOW' \n      AND expression_level_anatomical_relative = 'HIGH'\n);"}
{"idx": 152, "db_id": "oncomx", "query": "Get the name of all anatomical entities starting with 'bone'", "evidence": "", "extracted_schema": {"anatomical_entity": "keep_all", "biomarker": "drop_all", "biomarker_alias": "drop_all", "biomarker_article": "drop_all", "biomarker_edrn": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_use": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease": "drop_all", "xref_gene_ensembl": "drop_all", "species": "drop_all", "stage": "drop_all", "disease_mutation": "drop_all", "healthy_expression": "drop_all", "map_uniprot_canonical_id": "drop_all", "disease_mutation_tissue": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all", "differential_expression": "drop_all"}, "ground_truth": "SELECT name FROM anatomical_entity WHERE name LIKE 'bone%'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT name FROM anatomical_entity WHERE name LIKE 'bone%'", "qa_pairs": "```sql\nSELECT name FROM anatomical_entity WHERE name LIKE 'bone%'\n```", "fixed": false, "try_times": 1, "pred": "SELECT name FROM anatomical_entity WHERE name LIKE 'bone%'"}
{"idx": 153, "db_id": "oncomx", "query": "What is the common name for species with genus Mus?", "evidence": "", "extracted_schema": {"species": "keep_all", "xref_gene_ensembl": "drop_all", "biomarker": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_test": "drop_all"}, "ground_truth": "SELECT speciescommonname\nFROM species\nWHERE genus = 'Mus'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT speciescommonname FROM species WHERE genus = 'Mus';", "qa_pairs": "```sql\nSELECT speciescommonname FROM species WHERE genus = 'Mus';\n```", "fixed": false, "try_times": 1, "pred": "SELECT speciescommonname FROM species WHERE genus = 'Mus';"}
{"idx": 154, "db_id": "oncomx", "query": "What are the name of diseases where the expression of gene with symbol A1BG is up regulated (expression change direction)", "evidence": "", "extracted_schema": {"disease": "keep_all", "differential_expression": ["doid", "gene_symbol", "expression_change_direction", "log2fc", "pvalue", "adjpvalue"], "biomarker": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_use": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_edrn": "drop_all", "biomarker_article": "drop_all", "biomarker_alias": "drop_all", "disease_mutation": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease_mutation_tissue": "drop_all", "healthy_expression": "drop_all", "anatomical_entity": "drop_all", "map_uniprot_canonical_id": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all", "stage": "drop_all", "xref_gene_ensembl": "drop_all", "species": "drop_all"}, "ground_truth": "SELECT disease.name\nFROM differential_expression\n         JOIN disease ON differential_expression.doid = disease.id\nWHERE differential_expression.gene_symbol = 'A1BG'\n  and differential_expression.expression_change_direction = 'up'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "expression_change_direction"]}, "pruned": true, "final_sql": "SELECT d.name \nFROM differential_expression AS de \nJOIN disease AS d ON de.doid = d.id \nWHERE de.gene_symbol = 'A1BG' AND de.expression_change_direction = 'up';", "qa_pairs": "To find the names of diseases where the expression of the gene with the symbol \"A1BG\" is upregulated, we need to join the `differential_expression` table with the `disease` table based on the `doid` field. The `differential_expression` table contains the information about the gene expression changes, including the direction of change. \n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT d.name \nFROM differential_expression AS de \nJOIN disease AS d ON de.doid = d.id \nWHERE de.gene_symbol = 'A1BG' AND de.expression_change_direction = 'up';\n```\n\nThis query selects the names of diseases from the `disease` table where the gene symbol is \"A1BG\" and the expression change direction is \"up\".", "fixed": false, "try_times": 1, "pred": "SELECT d.name \nFROM differential_expression AS de \nJOIN disease AS d ON de.doid = d.id \nWHERE de.gene_symbol = 'A1BG' AND de.expression_change_direction = 'up';"}
{"idx": 155, "db_id": "oncomx", "query": "How many healthy expression are there for stage name starting with 'late adult'?", "evidence": "", "extracted_schema": {"healthy_expression": "keep_all", "stage": "keep_all", "biomarker": "drop_all", "disease": "drop_all"}, "ground_truth": "SELECT COUNT(*) FROM healthy_expression JOIN stage ON healthy_expression.uberon_developmental_id = stage.id WHERE stage.name LIKE 'late adult%'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT COUNT(*) \nFROM healthy_expression AS HE \nJOIN stage AS S ON HE.uberon_developmental_id = S.id \nWHERE S.name LIKE 'late adult%'", "qa_pairs": "To count the number of healthy expressions for stage names starting with 'late adult', you can use the following SQL query. This query joins the `healthy_expression` table with the `stage` table to filter based on the stage name and then counts the results.\n\n```sql\nSELECT COUNT(*) \nFROM healthy_expression AS HE \nJOIN stage AS S ON HE.uberon_developmental_id = S.id \nWHERE S.name LIKE 'late adult%'\n```\n\nThis SQL statement will return the total number of healthy expressions associated with stages whose names start with 'late adult'.", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(*) \nFROM healthy_expression AS HE \nJOIN stage AS S ON HE.uberon_developmental_id = S.id \nWHERE S.name LIKE 'late adult%'"}
{"idx": 156, "db_id": "oncomx", "query": "Show number of fda test trials with test manufacturer 'ABBOTT MOLECULAR INC'", "evidence": "", "extracted_schema": {"biomarker_fda_test_trial": "keep_all", "biomarker_fda_test": "keep_all", "biomarker_fda": "keep_all"}, "ground_truth": "SELECT count(*)\nFROM biomarker_fda_test\n         JOIN biomarker_fda_test_trial\n              ON biomarker_fda_test.test_submission = biomarker_fda_test_trial.test_submission and\n                 biomarker_fda_test.test_trade_name = biomarker_fda_test_trial.test_trade_name\nWHERE test_manufacturer = 'ABBOTT MOLECULAR INC'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT COUNT(*) \nFROM biomarker_fda_test_trial AS T1 \nJOIN biomarker_fda_test AS T2 \nON T1.test_trade_name = T2.test_trade_name \nAND T1.test_submission = T2.test_submission \nWHERE T2.test_manufacturer = 'ABBOTT MOLECULAR INC';", "qa_pairs": "To count the number of FDA test trials with the test manufacturer 'ABBOTT MOLECULAR INC', you will need to join the `biomarker_fda_test` and `biomarker_fda_test_trial` tables based on the `test_trade_name` and `test_submission` fields. Then, you can filter the results by the specified manufacturer and count the trials.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT COUNT(*) \nFROM biomarker_fda_test_trial AS T1 \nJOIN biomarker_fda_test AS T2 \nON T1.test_trade_name = T2.test_trade_name \nAND T1.test_submission = T2.test_submission \nWHERE T2.test_manufacturer = 'ABBOTT MOLECULAR INC';\n```\n\nThis query counts the number of entries in the `biomarker_fda_test_trial` table that correspond to tests manufactured by 'ABBOTT MOLECULAR INC'.", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(*) \nFROM biomarker_fda_test_trial AS T1 \nJOIN biomarker_fda_test AS T2 \nON T1.test_trade_name = T2.test_trade_name \nAND T1.test_submission = T2.test_submission \nWHERE T2.test_manufacturer = 'ABBOTT MOLECULAR INC';"}
{"idx": 157, "db_id": "oncomx", "query": "What is the test trade name for FDA tests where actual use is 'predisposition'?", "evidence": "", "extracted_schema": {"biomarker_fda_test_use": "keep_all", "biomarker_fda_test": "keep_all", "biomarker_fda": "keep_all"}, "ground_truth": "SELECT test_trade_name FROM biomarker_fda_test_use WHERE actual_use = 'predisposition'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT test_trade_name \nFROM biomarker_fda_test_use \nWHERE actual_use = 'predisposition';", "qa_pairs": "```sql\nSELECT test_trade_name \nFROM biomarker_fda_test_use \nWHERE actual_use = 'predisposition';\n```", "fixed": false, "try_times": 1, "pred": "SELECT test_trade_name \nFROM biomarker_fda_test_use \nWHERE actual_use = 'predisposition';"}
{"idx": 158, "db_id": "oncomx", "query": "Show all symbols of genes expressed in the disease 'lung cancer'", "evidence": "", "extracted_schema": {"biomarker": ["gene_symbol", "biomarker_description", "biomarker_id", "id"], "disease": ["id", "name"], "disease_mutation": ["id", "doid", "ensembl_transcript_id"]}, "ground_truth": "SELECT differential_expression.gene_symbol\nFROM differential_expression\n         JOIN disease ON differential_expression.doid = disease.id\nWHERE disease.name = 'lung cancer'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "ensembl_transcript_id", "doid", "chromosome_id", "chromosome_pos", "ref_nt"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT DISTINCT de.gene_symbol\nFROM differential_expression AS de\nJOIN disease AS d ON de.doid = d.id\nWHERE d.name = 'lung cancer';", "qa_pairs": "To show all symbols of genes expressed in the disease 'lung cancer', we need to join the relevant tables that connect gene symbols to the disease. The `disease` table contains the disease names, and the `differential_expression` table contains gene symbols associated with diseases.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT DISTINCT de.gene_symbol\nFROM differential_expression AS de\nJOIN disease AS d ON de.doid = d.id\nWHERE d.name = 'lung cancer';\n```\n\nThis query selects distinct gene symbols from the `differential_expression` table where the associated disease name is 'lung cancer'.", "fixed": false, "try_times": 1, "pred": "SELECT DISTINCT de.gene_symbol\nFROM differential_expression AS de\nJOIN disease AS d ON de.doid = d.id\nWHERE d.name = 'lung cancer';"}
{"idx": 159, "db_id": "oncomx", "query": "Show me the platform method an the study design for FDA tests from manufacturer 'Dako Denmark A/S'", "evidence": "", "extracted_schema": {"biomarker_fda_test": ["test_trade_name", "test_submission", "platform_method", "test_study_design", "test_manufacturer", "biomarker_origin"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"]}, "ground_truth": "SELECT platform_method, test_study_design\nFROM biomarker_fda_test\nWHERE test_manufacturer = 'Dako Denmark A/S'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "platform_method", "test_study_design"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT platform_method, test_study_design \nFROM biomarker_fda_test \nWHERE test_manufacturer = 'Dako Denmark A/S'", "qa_pairs": "```sql\nSELECT platform_method, test_study_design \nFROM biomarker_fda_test \nWHERE test_manufacturer = 'Dako Denmark A/S'\n```", "fixed": true, "try_times": 2, "pred": "SELECT platform_method, test_study_design \nFROM biomarker_fda_test \nWHERE test_manufacturer = 'Dako Denmark A/S' \nAND platform_method IS NOT NULL \nAND test_study_design IS NOT NULL"}
{"idx": 160, "db_id": "oncomx", "query": "Show me the description for FDA approved biomarkers with test approval status 'class II'", "evidence": "", "extracted_schema": {"biomarker_fda_test": "keep_all", "biomarker_fda": "keep_all", "biomarker": "drop_all", "biomarker_fda_test_use": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all"}, "ground_truth": "SELECT biomarker.biomarker_description\nFROM biomarker\n         JOIN biomarker_fda ON biomarker.id = biomarker_fda.id\n         JOIN biomarker_fda_test on biomarker_fda.test_submission = biomarker_fda_test.test_submission\nWHERE biomarker_fda_test.test_approval_status = 'class II'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT biomarker.biomarker_description \nFROM biomarker \nJOIN biomarker_fda_test ON biomarker.biomarker_id = biomarker_fda_test.doid \nWHERE biomarker_fda_test.test_approval_status = 'class II';", "qa_pairs": "```sql\nSELECT biomarker.biomarker_description \nFROM biomarker \nJOIN biomarker_fda_test ON biomarker.biomarker_id = biomarker_fda_test.doid \nWHERE biomarker_fda_test.test_approval_status = 'class II';\n```", "fixed": true, "try_times": 3, "pred": "SELECT biomarker.biomarker_description \nFROM biomarker \nJOIN biomarker_fda_test ON biomarker.id = biomarker_fda_test.doid \nWHERE biomarker_fda_test.test_approval_status = 'class II';"}
{"idx": 161, "db_id": "oncomx", "query": "List the descriptions of biomarkers for fda tests with approval status 'class II'", "evidence": "", "extracted_schema": {"biomarker_fda_test": ["test_trade_name", "test_submission", "test_approval_status", "test_adoption_evidence", "test_study_design", "clinical_significance"], "biomarker": ["biomarker_id", "gene_symbol", "biomarker_description", "biomarker_internal_id", "test_is_a_panel"], "biomarker_fda": ["id", "test_trade_name", "test_submission"]}, "ground_truth": "SELECT biomarker.biomarker_description\nFROM biomarker\n         JOIN biomarker_fda ON biomarker.id = biomarker_fda.id\n         JOIN biomarker_fda_test on biomarker_fda.test_submission = biomarker_fda_test.test_submission\nWHERE biomarker_fda_test.test_approval_status = 'class II'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_submission", "doid", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT b.biomarker_description \nFROM biomarker AS b \nJOIN biomarker_fda AS bf ON b.biomarker_id = bf.id \nJOIN biomarker_fda_test AS bft ON bf.id = bft.doid \nWHERE bft.test_approval_status = 'class II';", "qa_pairs": "To list the descriptions of biomarkers for FDA tests with an approval status of 'class II', we need to join the `biomarker`, `biomarker_fda_test`, and `biomarker_fda` tables based on their relationships. The `biomarker_fda_test` table contains the approval status, and we will filter for those with the status 'class II'. \n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT b.biomarker_description \nFROM biomarker AS b \nJOIN biomarker_fda AS bf ON b.biomarker_id = bf.id \nJOIN biomarker_fda_test AS bft ON bf.id = bft.doid \nWHERE bft.test_approval_status = 'class II';\n```\n\nThis query selects the `biomarker_description` from the `biomarker` table where the corresponding FDA test has an approval status of 'class II'.", "fixed": true, "try_times": 3, "pred": "SELECT b.biomarker_description \nFROM biomarker AS b \nJOIN biomarker_fda AS bf ON b.biomarker_id = bf.id \nJOIN biomarker_fda_test AS bft ON bf.test_trade_name = bft.test_trade_name AND bf.test_submission = bft.test_submission \nWHERE bft.test_approval_status = 'class II';"}
{"idx": 162, "db_id": "oncomx", "query": "Return all information from healthy expressions which have an expression score above the average.", "evidence": "", "extracted_schema": {"healthy_expression": "keep_all", "biomarker": "drop_all", "biomarker_alias": "drop_all", "biomarker_article": "drop_all", "biomarker_edrn": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_use": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease": "drop_all", "xref_gene_ensembl": "drop_all", "species": "drop_all", "stage": "drop_all", "disease_mutation": "drop_all", "anatomical_entity": "drop_all", "map_uniprot_canonical_id": "drop_all", "disease_mutation_tissue": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all", "differential_expression": "drop_all"}, "ground_truth": "SELECT * FROM healthy_expression WHERE expression_score > (SELECT AVG(expression_score) FROM healthy_expression)", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT * FROM healthy_expression \nWHERE expression_score > (SELECT AVG(expression_score) FROM healthy_expression);", "qa_pairs": "To return all information from the `healthy_expression` table where the `expression_score` is above the average, you can use the following SQL query:\n\n```sql\nSELECT * FROM healthy_expression \nWHERE expression_score > (SELECT AVG(expression_score) FROM healthy_expression);\n```\n\nThis query selects all columns from the `healthy_expression` table and filters the results to include only those rows where the `expression_score` is greater than the average `expression_score` calculated from the same table.", "fixed": false, "try_times": 1, "pred": "SELECT * FROM healthy_expression \nWHERE expression_score > (SELECT AVG(expression_score) FROM healthy_expression);"}
{"idx": 163, "db_id": "oncomx", "query": "Return all expressions which have an expression score higher than the average expression score.", "evidence": "", "extracted_schema": {"healthy_expression": "keep_all", "differential_expression": "keep_all", "biomarker": "drop_all", "biomarker_fda": "drop_all"}, "ground_truth": "SELECT * FROM healthy_expression WHERE expression_score > (SELECT AVG(expression_score) FROM healthy_expression)", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT * \nFROM healthy_expression \nWHERE expression_score > (SELECT AVG(expression_score) FROM healthy_expression);", "qa_pairs": "To return all expressions that have an expression score higher than the average expression score, you can use the following SQL query:\n\n```sql\nSELECT * \nFROM healthy_expression \nWHERE expression_score > (SELECT AVG(expression_score) FROM healthy_expression);\n```\n\nThis query selects all columns from the `healthy_expression` table where the `expression_score` is greater than the average `expression_score` calculated from the same table.", "fixed": false, "try_times": 1, "pred": "SELECT * \nFROM healthy_expression \nWHERE expression_score > (SELECT AVG(expression_score) FROM healthy_expression);"}
{"idx": 164, "db_id": "oncomx", "query": "What are the symbols for biomarkers with type genomic for anatomical entity breast?", "evidence": "", "extracted_schema": {"biomarker": "keep_all", "biomarker_edrn": ["biomarker_title", "biomarker_type", "qa_state", "phase", "uberon_anatomical_id", "id"], "anatomical_entity": ["id", "name", "description"]}, "ground_truth": "SELECT gene_symbol\nFROM biomarker\n         JOIN biomarker_edrn ON biomarker.id = biomarker_edrn.id\n         JOIN anatomical_entity ON biomarker_edrn.uberon_anatomical_id = anatomical_entity.id\nWHERE anatomical_entity.name = 'breast'\n  and biomarker_edrn.biomarker_type = 'Genomic'\n", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT b.gene_symbol \nFROM biomarker AS b\nJOIN biomarker_edrn AS e ON b.id = e.id\nJOIN anatomical_entity AS a ON e.uberon_anatomical_id = a.id\nWHERE e.biomarker_type = 'Genomic' AND a.name = 'breast';", "qa_pairs": "To find the symbols for biomarkers with the type \"genomic\" for the anatomical entity \"breast,\" we need to join the relevant tables based on the relationships defined in the schema. The steps are as follows:\n\n1. Identify the anatomical entity ID for \"breast\" from the `anatomical_entity` table.\n2. Find the biomarkers that are of type \"genomic\" from the `biomarker_edrn` table.\n3. Join these results with the `biomarker` table to get the biomarker symbols.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT b.gene_symbol \nFROM biomarker AS b\nJOIN biomarker_edrn AS e ON b.id = e.id\nJOIN anatomical_entity AS a ON e.uberon_anatomical_id = a.id\nWHERE e.biomarker_type = 'Genomic' AND a.name = 'breast';\n```\n\nThis query retrieves the gene symbols for biomarkers that are classified as \"genomic\" and are associated with the anatomical entity \"breast.\"", "fixed": false, "try_times": 1, "pred": "SELECT b.gene_symbol \nFROM biomarker AS b\nJOIN biomarker_edrn AS e ON b.id = e.id\nJOIN anatomical_entity AS a ON e.uberon_anatomical_id = a.id\nWHERE e.biomarker_type = 'Genomic' AND a.name = 'breast';"}
{"idx": 165, "db_id": "oncomx", "query": "What are the symbols for biomarkers on the EDRN platform with biomarker type Genomic for anatomical entity 'breast'?", "evidence": "", "extracted_schema": {"biomarker": "keep_all", "biomarker_edrn": ["biomarker_title", "biomarker_type", "qa_state", "phase", "uberon_anatomical_id"], "anatomical_entity": ["id", "name", "description"]}, "ground_truth": "SELECT gene_symbol\nFROM biomarker\n         JOIN biomarker_edrn ON biomarker.id = biomarker_edrn.id\n         JOIN anatomical_entity ON biomarker_edrn.uberon_anatomical_id = anatomical_entity.id\nWHERE anatomical_entity.name = 'breast'\n  and biomarker_edrn.biomarker_type = 'Genomic'\n", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT b.gene_symbol \nFROM biomarker_edrn AS edrn \nJOIN biomarker AS b ON edrn.id = b.id \nJOIN anatomical_entity AS ae ON edrn.uberon_anatomical_id = ae.id \nWHERE edrn.biormarker_type = 'Genomic' \nAND ae.name = 'breast';", "qa_pairs": "To retrieve the symbols for biomarkers on the EDRN platform with the biomarker type 'Genomic' for the anatomical entity 'breast', we need to join several tables based on the relationships defined in the schema. Specifically, we will need to join the `biomarker_edrn`, `biomarker`, and `anatomical_entity` tables.\n\nHere's the SQL query that accomplishes this:\n\n```sql\nSELECT b.gene_symbol \nFROM biomarker_edrn AS edrn \nJOIN biomarker AS b ON edrn.id = b.id \nJOIN anatomical_entity AS ae ON edrn.uberon_anatomical_id = ae.id \nWHERE edrn.biormarker_type = 'Genomic' \nAND ae.name = 'breast';\n```\n\n### Explanation:\n1. **SELECT b.gene_symbol**: We are selecting the gene symbols from the `biomarker` table.\n2. **FROM biomarker_edrn AS edrn**: We start from the `biomarker_edrn` table, which contains information about biomarkers on the EDRN platform.\n3. **JOIN biomarker AS b ON edrn.id = b.id**: We join the `biomarker` table to get the gene symbols corresponding to the biomarkers.\n4. **JOIN anatomical_entity AS ae ON edrn.uberon_anatomical_id = ae.id**: We join the `anatomical_entity` table to filter by anatomical entity.\n5. **WHERE edrn.biormarker_type = 'Genomic'**: We filter for biomarkers of type 'Genomic'.\n6. **AND ae.name = 'breast'**: We filter for the anatomical entity named 'breast'.\n\nThis query will return the gene symbols for the specified criteria.", "fixed": true, "try_times": 2, "pred": "SELECT b.gene_symbol \nFROM biomarker_edrn AS edrn \nJOIN biomarker AS b ON edrn.id = b.id \nJOIN anatomical_entity AS ae ON edrn.uberon_anatomical_id = ae.id \nWHERE edrn.biomarker_type = 'Genomic' \nAND ae.name = 'breast';"}
{"idx": 166, "db_id": "oncomx", "query": "What disease can occur in the liver?", "evidence": "", "extracted_schema": {"disease": "keep_all", "disease_mutation": "drop_all", "biomarker": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_fda_test_use": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_edrn": "drop_all", "biomarker_article": "drop_all", "biomarker_alias": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease_mutation_tissue": "drop_all", "differential_expression": "drop_all", "healthy_expression": "drop_all", "anatomical_entity": "drop_all", "map_uniprot_canonical_id": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all", "stage": "drop_all", "species": "drop_all", "xref_gene_ensembl": "drop_all"}, "ground_truth": "SELECT disease.name\nFROM anatomical_entity\n         JOIN cancer_tissue ON anatomical_entity.id = cancer_tissue.uberon_anatomical_id\n         JOIN disease ON cancer_tissue.doid = disease.id\nWHERE anatomical_entity.name = 'liver'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT d.name \nFROM disease AS d \nJOIN disease_mutation AS dm ON d.id = dm.doid \nJOIN disease_mutation_tissue AS dmt ON dm.id = dmt.disease_mutation_id \nWHERE dmt.uberon_anatomical_id = (SELECT id FROM anatomical_entity WHERE name = 'liver');", "qa_pairs": "To find out what diseases can occur in the liver, we need to identify the diseases associated with the anatomical entity that corresponds to the liver. However, the provided schema does not explicitly list an anatomical entity for the liver. Assuming that the liver is represented in the `anatomical_entity` table, we would first need to find the `id` for the liver and then query the `disease_mutation` table to find associated diseases.\n\nHere’s how you can construct the SQL query:\n\n1. Identify the anatomical entity ID for the liver.\n2. Use that ID to find diseases associated with it.\n\nAssuming the liver has an entry in the `anatomical_entity` table, the SQL query would look like this:\n\n```sql\nSELECT d.name \nFROM disease AS d \nJOIN disease_mutation AS dm ON d.id = dm.doid \nJOIN disease_mutation_tissue AS dmt ON dm.id = dmt.disease_mutation_id \nWHERE dmt.uberon_anatomical_id = (SELECT id FROM anatomical_entity WHERE name = 'liver');\n```\n\nThis query does the following:\n- Selects the names of diseases from the `disease` table.\n- Joins the `disease_mutation` table to link diseases with mutations.\n- Joins the `disease_mutation_tissue` table to find mutations associated with specific tissues.\n- Filters the results to only include those associated with the liver by using a subquery to find the anatomical entity ID for the liver. \n\nMake sure to replace `'liver'` with the exact name used in the `anatomical_entity` table if it differs.", "fixed": false, "try_times": 1, "pred": "SELECT d.name \nFROM disease AS d \nJOIN disease_mutation AS dm ON d.id = dm.doid \nJOIN disease_mutation_tissue AS dmt ON dm.id = dmt.disease_mutation_id \nWHERE dmt.uberon_anatomical_id = (SELECT id FROM anatomical_entity WHERE name = 'liver');"}
{"idx": 167, "db_id": "oncomx", "query": "List the name of diseases that can occur in the anatomical entity 'liver'", "evidence": "", "extracted_schema": {"disease": "keep_all", "anatomical_entity": ["id", "name", "description"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"]}, "ground_truth": "SELECT disease.name\nFROM anatomical_entity\n         JOIN cancer_tissue ON anatomical_entity.id = cancer_tissue.uberon_anatomical_id\n         JOIN disease ON cancer_tissue.doid = disease.id\nWHERE anatomical_entity.name = 'liver'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT DISTINCT d.name\nFROM disease AS d\nJOIN disease_mutation AS dm ON d.id = dm.doid\nJOIN disease_mutation_tissue AS dmt ON dm.id = dmt.disease_mutation_id\nJOIN anatomical_entity AS ae ON dmt.uberon_anatomical_id = ae.id\nWHERE ae.name = 'liver';", "qa_pairs": "To list the names of diseases that can occur in the anatomical entity 'liver', we need to join the `disease`, `disease_mutation`, and `disease_mutation_tissue` tables. The `disease_mutation_tissue` table links diseases to anatomical entities, and we will filter for the anatomical entity with the name 'liver'.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT DISTINCT d.name\nFROM disease AS d\nJOIN disease_mutation AS dm ON d.id = dm.doid\nJOIN disease_mutation_tissue AS dmt ON dm.id = dmt.disease_mutation_id\nJOIN anatomical_entity AS ae ON dmt.uberon_anatomical_id = ae.id\nWHERE ae.name = 'liver';\n```\n\nThis query selects distinct disease names from the `disease` table where there is a corresponding entry in the `disease_mutation` and `disease_mutation_tissue` tables for the anatomical entity 'liver'.", "fixed": false, "try_times": 1, "pred": "SELECT DISTINCT d.name\nFROM disease AS d\nJOIN disease_mutation AS dm ON d.id = dm.doid\nJOIN disease_mutation_tissue AS dmt ON dm.id = dmt.disease_mutation_id\nJOIN anatomical_entity AS ae ON dmt.uberon_anatomical_id = ae.id\nWHERE ae.name = 'liver';"}
{"idx": 168, "db_id": "oncomx", "query": "Show distinct manufacturer of tests for gene BRAF ", "evidence": "", "extracted_schema": {"biomarker_fda_test": "keep_all", "biomarker": "keep_all", "biomarker_fda": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_test_use": "drop_all"}, "ground_truth": "SELECT DISTINCT biomarker_fda_test.test_manufacturer\nFROM biomarker\n         JOIN biomarker_fda on biomarker.id = biomarker_fda.id\n         JOIN biomarker_fda_test\n              ON biomarker_fda.test_trade_name = biomarker_fda_test.test_trade_name AND biomarker_fda.test_submission = biomarker_fda_test.test_submission\nWHERE biomarker.gene_symbol = 'BRAF'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT DISTINCT bft.test_manufacturer\nFROM biomarker AS bm\nJOIN biomarker_fda_test AS bft ON bm.biomarker_id = bft.doid\nWHERE bm.gene_symbol = 'BRAF';", "qa_pairs": "To retrieve the distinct manufacturers of tests for the gene BRAF, we need to join the relevant tables that contain information about the tests and their associated biomarkers. The `biomarker` table will provide the gene symbol, and the `biomarker_fda_test` table will provide the manufacturer information.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT DISTINCT bft.test_manufacturer\nFROM biomarker AS bm\nJOIN biomarker_fda_test AS bft ON bm.biomarker_id = bft.doid\nWHERE bm.gene_symbol = 'BRAF';\n```\n\nIn this query:\n- We select distinct manufacturers from the `biomarker_fda_test` table.\n- We join the `biomarker` table with the `biomarker_fda_test` table on the `biomarker_id`.\n- We filter the results to include only those records where the `gene_symbol` is 'BRAF'. \n\nMake sure to adjust the join condition if the relationship between the tables is different based on the actual schema.", "fixed": true, "try_times": 3, "pred": "SELECT DISTINCT bft.test_manufacturer\nFROM biomarker AS bm\nJOIN biomarker_fda AS bf ON bm.id = bf.id\nJOIN biomarker_fda_test AS bft ON bf.id = bft.biomarker_fda_id\nWHERE bm.gene_symbol = 'BRAF' AND bft.test_manufacturer IS NOT NULL;"}
{"idx": 169, "db_id": "oncomx", "query": "Show all FDA test manufacturer for biomarkers of gene BRAF ", "evidence": "", "extracted_schema": {"biomarker_fda_test": "keep_all", "biomarker": "keep_all", "biomarker_fda": "keep_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_test_use": "drop_all", "biomarker_alias": "drop_all", "biomarker_article": "drop_all", "biomarker_edrn": "drop_all", "disease_mutation": "drop_all", "disease": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease_mutation_tissue": "drop_all", "healthy_expression": "drop_all", "anatomical_entity": "drop_all", "map_uniprot_canonical_id": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all", "differential_expression": "drop_all", "xref_gene_ensembl": "drop_all", "species": "drop_all", "stage": "drop_all"}, "ground_truth": "SELECT biomarker_fda_test.test_manufacturer\nFROM biomarker\n         JOIN biomarker_fda on biomarker.id = biomarker_fda.id\n         JOIN biomarker_fda_test\n              ON biomarker_fda.test_trade_name = biomarker_fda_test.test_trade_name AND biomarker_fda.test_submission = biomarker_fda_test.test_submission\nWHERE biomarker.gene_symbol = 'BRAF'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT DISTINCT bft.test_manufacturer\nFROM biomarker AS b\nJOIN biomarker_fda AS bf ON b.biomarker_id = bf.id\nJOIN biomarker_fda_test AS bft ON bf.id = bft.test_trade_name\nWHERE b.gene_symbol = 'BRAF';", "qa_pairs": "To retrieve all FDA test manufacturers for biomarkers of the gene BRAF, we need to join several tables based on the relationships defined in the schema. Specifically, we will need to find the biomarker associated with the gene BRAF, then find the corresponding FDA tests and their manufacturers.\n\nHere’s the SQL query that accomplishes this:\n\n```sql\nSELECT DISTINCT bft.test_manufacturer\nFROM biomarker AS b\nJOIN biomarker_fda AS bf ON b.biomarker_id = bf.id\nJOIN biomarker_fda_test AS bft ON bf.id = bft.test_trade_name\nWHERE b.gene_symbol = 'BRAF';\n```\n\n### Explanation:\n1. **FROM biomarker AS b**: Start with the `biomarker` table to filter by the gene symbol.\n2. **JOIN biomarker_fda AS bf ON b.biomarker_id = bf.id**: Join with the `biomarker_fda` table to get the FDA-related information for the biomarkers.\n3. **JOIN biomarker_fda_test AS bft ON bf.id = bft.test_trade_name**: Join with the `biomarker_fda_test` table to get the test manufacturers.\n4. **WHERE b.gene_symbol = 'BRAF'**: Filter the results to only include biomarkers for the gene BRAF.\n5. **SELECT DISTINCT bft.test_manufacturer**: Select the distinct manufacturers to avoid duplicates.\n\nThis query will return a list of all unique FDA test manufacturers associated with biomarkers for the gene BRAF.", "fixed": true, "try_times": 3, "pred": "SELECT DISTINCT bft.test_manufacturer\nFROM biomarker AS b\nJOIN biomarker_fda AS bf ON b.id = bf.id\nJOIN biomarker_fda_test AS bft ON bf.id = bft.test_submission\nWHERE b.gene_symbol = 'BRAF';"}
{"idx": 170, "db_id": "oncomx", "query": "Show me the name of anatomical entities and species for all species", "evidence": "", "extracted_schema": {"anatomical_entity": "keep_all", "species": "keep_all", "biomarker": "drop_all", "biomarker_alias": "drop_all", "biomarker_article": "drop_all", "biomarker_edrn": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_use": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease": "drop_all", "xref_gene_ensembl": "drop_all", "stage": "drop_all", "disease_mutation": "drop_all", "healthy_expression": "drop_all", "map_uniprot_canonical_id": "drop_all", "disease_mutation_tissue": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all", "differential_expression": "drop_all"}, "ground_truth": "SELECT anatomical_entity.name, species.speciescommonname\nFROM anatomical_entity\n         JOIN healthy_expression ON anatomical_entity.id = healthy_expression.uberon_anatomical_id\n         JOIN xref_gene_ensembl ON healthy_expression.ensembl_gene_id = xref_gene_ensembl.ensembl_gene_id\n         JOIN species ON xref_gene_ensembl.speciesid = species.speciesid", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT anatomical_entity.name AS anatomical_entity_name, species.speciescommonname AS species_name\nFROM anatomical_entity\nCROSS JOIN species;", "qa_pairs": "To retrieve the names of anatomical entities along with their corresponding species, you will need to join the `anatomical_entity` table with the `species` table. However, since there is no direct relationship between these two tables in the provided schema, we can only list them separately. \n\nIf you want to show all anatomical entities along with all species, you can use a cross join. Here’s the SQL query for that:\n\n```sql\nSELECT anatomical_entity.name AS anatomical_entity_name, species.speciescommonname AS species_name\nFROM anatomical_entity\nCROSS JOIN species;\n```\n\nThis query will return a Cartesian product of all anatomical entities and all species, showing every combination of anatomical entity names and species common names.", "fixed": false, "try_times": 1, "pred": "SELECT anatomical_entity.name AS anatomical_entity_name, species.speciescommonname AS species_name\nFROM anatomical_entity\nCROSS JOIN species;"}
{"idx": 171, "db_id": "oncomx", "query": "What are the distinct healthy organs where the gene A1BG is expressed.", "evidence": "", "extracted_schema": {"biomarker": "keep_all", "healthy_expression": "keep_all", "anatomical_entity": "keep_all"}, "ground_truth": "SELECT distinct anatomical_entity.name\nFROM healthy_expression\n         JOIN xref_gene_ensembl ON healthy_expression.ensembl_gene_id = xref_gene_ensembl.ensembl_gene_id\n         JOIN anatomical_entity ON healthy_expression.uberon_anatomical_id = anatomical_entity.id\nWHERE xref_gene_ensembl.gene_symbol = 'A1BG'\n  and healthy_expression.expression_level_anatomical_relative != 'ABSENT'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT DISTINCT he.uberon_anatomical_id\nFROM healthy_expression AS he\nJOIN xref_gene_ensembl AS xg ON he.ensembl_gene_id = xg.ensembl_gene_id\nWHERE xg.gene_symbol = 'A1BG';", "qa_pairs": "To find the distinct healthy organs where the gene A1BG is expressed, we need to query the `healthy_expression` table, joining it with the `xref_gene_ensembl` table to get the corresponding `ensembl_gene_id` for the gene symbol A1BG. We will then select the distinct `uberon_anatomical_id` from the `healthy_expression` table.\n\nHere is the SQL query:\n\n```sql\nSELECT DISTINCT he.uberon_anatomical_id\nFROM healthy_expression AS he\nJOIN xref_gene_ensembl AS xg ON he.ensembl_gene_id = xg.ensembl_gene_id\nWHERE xg.gene_symbol = 'A1BG';\n```\n\nThis query retrieves the unique anatomical IDs where the gene A1BG is expressed in healthy tissues.", "fixed": false, "try_times": 1, "pred": "SELECT DISTINCT he.uberon_anatomical_id\nFROM healthy_expression AS he\nJOIN xref_gene_ensembl AS xg ON he.ensembl_gene_id = xg.ensembl_gene_id\nWHERE xg.gene_symbol = 'A1BG';"}
{"idx": 172, "db_id": "oncomx", "query": "Give me symbol and description of biomarkers related to breast at the EDRN phase one", "evidence": "", "extracted_schema": {"biomarker_edrn": "keep_all", "biomarker": "keep_all", "biomarker_article": "drop_all", "biomarker_alias": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_drug": "drop_all"}, "ground_truth": "SELECT biomarker.gene_symbol, biomarker.biomarker_description\nFROM biomarker\n         JOIN biomarker_edrn ON biomarker.id = biomarker_edrn.id\n         JOIN anatomical_entity ON biomarker_edrn.uberon_anatomical_id = anatomical_entity.id\nWHERE anatomical_entity.name = 'breast'\n  and biomarker_edrn.phase = 'One'\n", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT b.gene_symbol, b.biomarker_description\nFROM biomarker AS b\nJOIN biomarker_edrn AS e ON b.id = e.id\nWHERE e.phase = 'One' AND (b.biomarker_description LIKE '%breast%' OR e.biomarker_title LIKE '%breast%');", "qa_pairs": "To retrieve the symbol and description of biomarkers related to breast at the EDRN phase one, we need to join the relevant tables based on the provided schema. The `biomarker` table contains the biomarker symbols and descriptions, while the `biomarker_edrn` table contains the phase information.\n\nAssuming that \"breast\" is part of the biomarker title or description, we will filter based on that. Here’s the SQL query that accomplishes this:\n\n```sql\nSELECT b.gene_symbol, b.biomarker_description\nFROM biomarker AS b\nJOIN biomarker_edrn AS e ON b.id = e.id\nWHERE e.phase = 'One' AND (b.biomarker_description LIKE '%breast%' OR e.biomarker_title LIKE '%breast%');\n```\n\nThis query selects the `gene_symbol` and `biomarker_description` from the `biomarker` table, joining it with the `biomarker_edrn` table on the `id` field. It filters the results to include only those entries where the phase is 'One' and the description or title contains the word \"breast\".", "fixed": false, "try_times": 1, "pred": "SELECT b.gene_symbol, b.biomarker_description\nFROM biomarker AS b\nJOIN biomarker_edrn AS e ON b.id = e.id\nWHERE e.phase = 'One' AND (b.biomarker_description LIKE '%breast%' OR e.biomarker_title LIKE '%breast%');"}
{"idx": 173, "db_id": "oncomx", "query": "Show me the name of the anatomical entity and the expression score of where either gene ENSMUSG00000000037 or gene ENSMUSG00000000078 is expressed in.", "evidence": "", "extracted_schema": {"healthy_expression": "keep_all", "anatomical_entity": "keep_all", "biomarker": "drop_all", "biomarker_edrn": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_test": "drop_all"}, "ground_truth": "SELECT anatomical_entity.name, healthy_expression.expression_score\nFROM healthy_expression\n         JOIN anatomical_entity\n              ON healthy_expression.uberon_anatomical_id = anatomical_entity.id\nWHERE healthy_expression.ensembl_gene_id = 'ENSMUSG00000000037'\n   OR healthy_expression.ensembl_gene_id = 'ENSMUSG00000000078'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT ae.name, he.expression_score\nFROM healthy_expression AS he\nJOIN anatomical_entity AS ae ON he.uberon_anatomical_id = ae.id\nWHERE he.ensembl_gene_id IN ('ENSMUSG00000000037', 'ENSMUSG00000000078');", "qa_pairs": "To retrieve the name of the anatomical entity and the expression score for the specified genes (ENSMUSG00000000037 or ENSMUSG00000000078), you will need to join the `healthy_expression` table with the `anatomical_entity` table based on the `uberon_anatomical_id`. The SQL query will filter for the specified gene symbols.\n\nHere is the SQL query:\n\n```sql\nSELECT ae.name, he.expression_score\nFROM healthy_expression AS he\nJOIN anatomical_entity AS ae ON he.uberon_anatomical_id = ae.id\nWHERE he.ensembl_gene_id IN ('ENSMUSG00000000037', 'ENSMUSG00000000078');\n```\n\nThis query selects the name of the anatomical entity and the expression score for the specified genes by joining the relevant tables and applying the necessary filter.", "fixed": false, "try_times": 1, "pred": "SELECT ae.name, he.expression_score\nFROM healthy_expression AS he\nJOIN anatomical_entity AS ae ON he.uberon_anatomical_id = ae.id\nWHERE he.ensembl_gene_id IN ('ENSMUSG00000000037', 'ENSMUSG00000000078');"}
{"idx": 174, "db_id": "oncomx", "query": "What's the NCIt term for biomarker with symbol ALDH4A1?", "evidence": "", "extracted_schema": {"biomarker": "keep_all", "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_alias": "drop_all", "biomarker_article": "drop_all", "biomarker_edrn": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_test_use": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease": "drop_all", "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": "drop_all", "stage": "drop_all", "disease_mutation": "drop_all", "healthy_expression": "drop_all", "anatomical_entity": "drop_all", "map_uniprot_canonical_id": "drop_all", "disease_mutation_tissue": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all", "differential_expression": "drop_all"}, "ground_truth": "SELECT biomarker_fda_ncit_term.ncit_biomarker\nFROM biomarker_fda_ncit_term\n         JOIN biomarker_fda ON biomarker_fda_ncit_term.biomarker_fda_id = biomarker_fda.id\n         JOIN biomarker ON biomarker_fda.id = biomarker.id\nWHERE biomarker.gene_symbol = 'ALDH4A1'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT bft.ncit_biomarker \nFROM biomarker AS b \nJOIN biomarker_fda_ncit_term AS bft ON b.biomarker_id = bft.biomarker_fda_id \nWHERE b.gene_symbol = 'ALDH4A1';", "qa_pairs": "To find the NCIt term for the biomarker with the symbol ALDH4A1, we need to join the relevant tables that contain the biomarker information and the NCIt terms. The `biomarker` table contains the `gene_symbol`, and the `biomarker_fda_ncit_term` table contains the `ncit_biomarker` associated with the `biomarker_fda_id`.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT bft.ncit_biomarker \nFROM biomarker AS b \nJOIN biomarker_fda_ncit_term AS bft ON b.biomarker_id = bft.biomarker_fda_id \nWHERE b.gene_symbol = 'ALDH4A1';\n```\n\nThis query selects the NCIt term for the biomarker with the symbol ALDH4A1 by joining the `biomarker` table with the `biomarker_fda_ncit_term` table on the appropriate foreign key.", "fixed": true, "try_times": 2, "pred": "SELECT bft.ncit_biomarker \nFROM biomarker AS b \nJOIN biomarker_fda AS bf ON b.id = bf.id \nJOIN biomarker_fda_ncit_term AS bft ON bf.id = bft.biomarker_fda_id \nWHERE b.gene_symbol = 'ALDH4A1';"}
{"idx": 175, "db_id": "oncomx", "query": "Show all information about disease mutations of the anatomical entity liver", "evidence": "", "extracted_schema": {"disease_mutation": "keep_all", "disease_mutation_tissue": "keep_all", "anatomical_entity": ["id", "name", "description"], "disease": ["id", "name"]}, "ground_truth": "SELECT *\nFROM disease_mutation\n         JOIN disease_mutation_tissue ON disease_mutation.id = disease_mutation_tissue.disease_mutation_id\n         JOIN anatomical_entity ON disease_mutation_tissue.uberon_anatomical_id = anatomical_entity.id\nWHERE anatomical_entity.name = 'liver'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT dm.*\nFROM disease_mutation AS dm\nJOIN disease_mutation_tissue AS dmt ON dm.id = dmt.disease_mutation_id\nJOIN anatomical_entity AS ae ON dmt.uberon_anatomical_id = ae.id\nWHERE ae.name = 'liver';", "qa_pairs": "To retrieve all information about disease mutations associated with the anatomical entity \"liver,\" we need to join the relevant tables based on their relationships. The `disease_mutation` table is linked to the `disease_mutation_tissue` table, which in turn is linked to the `anatomical_entity` table. We will filter the results based on the name of the anatomical entity.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT dm.*\nFROM disease_mutation AS dm\nJOIN disease_mutation_tissue AS dmt ON dm.id = dmt.disease_mutation_id\nJOIN anatomical_entity AS ae ON dmt.uberon_anatomical_id = ae.id\nWHERE ae.name = 'liver';\n```\n\nThis query selects all columns from the `disease_mutation` table (`dm`) where the anatomical entity name is \"liver.\" It joins the `disease_mutation` table with the `disease_mutation_tissue` table on the `disease_mutation_id`, and then joins with the `anatomical_entity` table on the `uberon_anatomical_id`.", "fixed": false, "try_times": 1, "pred": "SELECT dm.*\nFROM disease_mutation AS dm\nJOIN disease_mutation_tissue AS dmt ON dm.id = dmt.disease_mutation_id\nJOIN anatomical_entity AS ae ON dmt.uberon_anatomical_id = ae.id\nWHERE ae.name = 'liver';"}
{"idx": 176, "db_id": "oncomx", "query": "List all disease mutations which belong to anatomical entity liver.", "evidence": "", "extracted_schema": {"disease_mutation": "keep_all", "anatomical_entity": "keep_all", "disease_mutation_tissue": "drop_all", "disease": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease_mutation_impact_prediction": "drop_all"}, "ground_truth": "SELECT *\nFROM anatomical_entity\n         JOIN disease_mutation_tissue ON anatomical_entity.id = disease_mutation_tissue.uberon_anatomical_id\n         JOIN disease_mutation ON disease_mutation_tissue.disease_mutation_id = disease_mutation.id\nwhere anatomical_entity.name = 'liver'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT dm.*\nFROM disease_mutation AS dm\nJOIN disease_mutation_tissue AS dmt ON dm.id = dmt.disease_mutation_id\nJOIN anatomical_entity AS ae ON dmt.uberon_anatomical_id = ae.id\nWHERE ae.name = 'liver';", "qa_pairs": "To list all disease mutations that belong to the anatomical entity \"liver,\" we need to join the `disease_mutation`, `disease_mutation_tissue`, and `anatomical_entity` tables. We will filter the results based on the name of the anatomical entity.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT dm.*\nFROM disease_mutation AS dm\nJOIN disease_mutation_tissue AS dmt ON dm.id = dmt.disease_mutation_id\nJOIN anatomical_entity AS ae ON dmt.uberon_anatomical_id = ae.id\nWHERE ae.name = 'liver';\n```\n\nThis query selects all columns from the `disease_mutation` table where the associated anatomical entity is \"liver.\"", "fixed": false, "try_times": 1, "pred": "SELECT dm.*\nFROM disease_mutation AS dm\nJOIN disease_mutation_tissue AS dmt ON dm.id = dmt.disease_mutation_id\nJOIN anatomical_entity AS ae ON dmt.uberon_anatomical_id = ae.id\nWHERE ae.name = 'liver';"}
{"idx": 177, "db_id": "oncomx", "query": "Show me the gene symbol of biomarkers that have an approval status of 'PMP' from the FDA", "evidence": "", "extracted_schema": {"biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_test": ["test_trade_name", "test_submission", "test_approval_status", "biomarker_origin", "test_number_genes", "test_adoption_evidence"], "biomarker_fda": "keep_all"}, "ground_truth": "SELECT gene_symbol \nFROM biomarker\nJOIN biomarker_fda ON biomarker.id = biomarker_fda.id\nJOIN biomarker_fda_test ON biomarker_fda.test_submission = biomarker_fda_test.test_submission\nWHERE biomarker_fda_test.test_approval_status = 'PMP'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_submission", "biomarker_origin", "doid", "test_number_genes", "test_adoption_evidence", "test_approval_status"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT gene_symbol \nFROM biomarker \nWHERE biomarker_id IN (\n    SELECT biomarker_fda_id \n    FROM biomarker_fda_test \n    WHERE test_approval_status = 'PMP'\n);", "qa_pairs": "```sql\nSELECT gene_symbol \nFROM biomarker \nWHERE biomarker_id IN (\n    SELECT biomarker_fda_id \n    FROM biomarker_fda_test \n    WHERE test_approval_status = 'PMP'\n);\n```", "fixed": true, "try_times": 2, "pred": "SELECT DISTINCT b.gene_symbol \nFROM biomarker b\nJOIN biomarker_fda bf ON b.id = bf.id\nJOIN biomarker_fda_test bft ON bf.test_trade_name = bft.test_trade_name AND bf.test_submission = bft.test_submission\nWHERE bft.test_approval_status = 'PMP';"}
{"idx": 178, "db_id": "oncomx", "query": "What are the desctiptions of biomarkers related to breast cancer?", "evidence": "", "extracted_schema": {"biomarker": "keep_all", "biomarker_edrn": "keep_all", "biomarker_fda": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_test_use": "drop_all", "disease": ["id", "name"], "disease_mutation": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease_mutation_tissue": "drop_all", "healthy_expression": "drop_all", "anatomical_entity": "drop_all", "differential_expression": "drop_all", "xref_gene_ensembl": "drop_all", "species": "drop_all", "stage": "drop_all", "map_uniprot_canonical_id": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all"}, "ground_truth": "SELECT biomarker.biomarker_description\nFROM biomarker\nJOIN biomarker_edrn ON biomarker.id = biomarker_edrn.id\nJOIN anatomical_entity ON biomarker_edrn.uberon_anatomical_id = anatomical_entity.id\nWHERE anatomical_entity.name = 'breast'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT b.biomarker_description \nFROM biomarker AS b \nJOIN biomarker_fda_test AS fda ON b.biomarker_id = fda.id \nJOIN disease AS d ON fda.doid = d.id \nWHERE d.name = 'breast cancer';", "qa_pairs": "To retrieve the descriptions of biomarkers related to breast cancer, we need to join the relevant tables based on the relationships defined in the schema. Specifically, we will join the `biomarker`, `biomarker_fda_test`, and `disease` tables to filter for breast cancer.\n\nAssuming that \"breast cancer\" corresponds to a specific `doid` in the `disease` table, we will first need to identify the `id` for breast cancer. For this example, let's assume that the `id` for breast cancer is known (you would typically look this up in the `disease` table).\n\nHere is the SQL query to get the descriptions of biomarkers related to breast cancer:\n\n```sql\nSELECT b.biomarker_description \nFROM biomarker AS b \nJOIN biomarker_fda_test AS fda ON b.biomarker_id = fda.id \nJOIN disease AS d ON fda.doid = d.id \nWHERE d.name = 'breast cancer';\n```\n\nIn this query:\n- We select the `biomarker_description` from the `biomarker` table.\n- We join the `biomarker` table with the `biomarker_fda_test` table on the `biomarker_id`.\n- We then join the `biomarker_fda_test` table with the `disease` table on the `doid`.\n- Finally, we filter the results to only include those related to breast cancer by checking the `name` in the `disease` table. \n\nMake sure to replace `'breast cancer'` with the actual name used in your `disease` table if it differs.", "fixed": true, "try_times": 3, "pred": "SELECT b.biomarker_description \nFROM biomarker AS b \nJOIN biomarker_fda AS fda ON b.id = fda.id \nJOIN biomarker_fda_test AS fda_test ON fda.id = fda_test.doid \nJOIN biomarker_fda_test_use AS fda_test_use ON fda_test.test_trade_name = fda_test_use.test_trade_name \nJOIN biomarker_fda_ncit_term AS fda_ncit ON fda.id = fda_ncit.biomarker_fda_id \nJOIN disease AS d ON fda_ncit.ncit_biomarker = d.id \nWHERE d.name = 'breast cancer';"}
{"idx": 179, "db_id": "oncomx", "query": "How many biomarkers are associated with each anatomical entity?", "evidence": "", "extracted_schema": {"biomarker_edrn": "keep_all", "biomarker": "keep_all", "anatomical_entity": "keep_all"}, "ground_truth": "SELECT anatomical_entity.name, COUNT(*)\nFROM biomarker\nJOIN biomarker_edrn ON biomarker.id = biomarker_edrn.id\nJOIN anatomical_entity ON biomarker_edrn.uberon_anatomical_id = anatomical_entity.id\nGROUP BY anatomical_entity.name", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT ae.name AS Anatomical_Entity, COUNT(b.id) AS Biomarker_Count\nFROM anatomical_entity AS ae\nLEFT JOIN biomarker_edrn AS be ON ae.id = be.uberon_anatomical_id\nLEFT JOIN biomarker AS b ON be.id = b.id\nGROUP BY ae.id, ae.name;", "qa_pairs": "```sql\nSELECT ae.name AS Anatomical_Entity, COUNT(b.id) AS Biomarker_Count\nFROM anatomical_entity AS ae\nLEFT JOIN biomarker_edrn AS be ON ae.id = be.uberon_anatomical_id\nLEFT JOIN biomarker AS b ON be.id = b.id\nGROUP BY ae.id, ae.name;\n```", "fixed": false, "try_times": 1, "pred": "SELECT ae.name AS Anatomical_Entity, COUNT(b.id) AS Biomarker_Count\nFROM anatomical_entity AS ae\nLEFT JOIN biomarker_edrn AS be ON ae.id = be.uberon_anatomical_id\nLEFT JOIN biomarker AS b ON be.id = b.id\nGROUP BY ae.id, ae.name;"}
{"idx": 180, "db_id": "oncomx", "query": "Show me all information about disease mutations with ref_aa equal to F", "evidence": "", "extracted_schema": {"disease_mutation": "keep_all", "disease_mutation_site_annotation": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_tissue": "drop_all", "disease": "drop_all", "biomarker": "drop_all"}, "ground_truth": "SELECT * FROM disease_mutation WHERE ref_aa = 'F'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT * FROM disease_mutation WHERE ref_aa = 'F'", "qa_pairs": "```sql\nSELECT * FROM disease_mutation WHERE ref_aa = 'F'\n```", "fixed": false, "try_times": 1, "pred": "SELECT * FROM disease_mutation WHERE ref_aa = 'F'"}
{"idx": 181, "db_id": "oncomx", "query": "Show all information about diseases which contain cancer in the name", "evidence": "", "extracted_schema": {"disease": "keep_all", "disease_mutation": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease_mutation_tissue": "drop_all", "cancer_tissue": "drop_all"}, "ground_truth": "SELECT name FROM disease WHERE name like '%cancer%'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT * FROM disease WHERE name LIKE '%cancer%'", "qa_pairs": "```sql\nSELECT * FROM disease WHERE name LIKE '%cancer%'\n```", "fixed": false, "try_times": 1, "pred": "SELECT * FROM disease WHERE name LIKE '%cancer%'"}
{"idx": 182, "db_id": "oncomx", "query": "Show distinct manufacturer of diagnostic tests for gene BRAF ", "evidence": "", "extracted_schema": {"biomarker_fda_test": "keep_all", "biomarker": "keep_all", "biomarker_fda": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_test_use": "drop_all"}, "ground_truth": "SELECT distinct(biomarker_fda_test.test_manufacturer), biomarker_fda_test_use.actual_use\nFROM biomarker\n         JOIN biomarker_fda on biomarker.id = biomarker_fda.id\n         JOIN biomarker_fda_test\n              ON biomarker_fda.test_trade_name = biomarker_fda_test.test_trade_name AND\n                 biomarker_fda.test_submission = biomarker_fda_test.test_submission\n         JOIN biomarker_fda_test_use ON biomarker_fda_test.test_submission = biomarker_fda_test_use.test_submission and biomarker_fda_test.test_trade_name = biomarker_fda_test_use.test_trade_name\nWHERE biomarker.gene_symbol = 'BRAF'\n  AND biomarker_fda_test_use.actual_use = 'diagnostic'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT DISTINCT bft.test_manufacturer\nFROM biomarker AS bm\nJOIN biomarker_fda AS bfa ON bm.biomarker_id = bfa.id\nJOIN biomarker_fda_test AS bft ON bfa.id = bft.doid\nWHERE bm.gene_symbol = 'BRAF';", "qa_pairs": "To retrieve distinct manufacturers of diagnostic tests for the gene BRAF, we need to join the relevant tables that contain information about biomarkers, FDA tests, and their manufacturers. The `biomarker` table will provide the gene symbol, and the `biomarker_fda_test` table will provide the manufacturer information.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT DISTINCT bft.test_manufacturer\nFROM biomarker AS bm\nJOIN biomarker_fda AS bfa ON bm.biomarker_id = bfa.id\nJOIN biomarker_fda_test AS bft ON bfa.id = bft.doid\nWHERE bm.gene_symbol = 'BRAF';\n```\n\nThis query selects distinct manufacturers from the `biomarker_fda_test` table where the associated biomarker corresponds to the gene symbol 'BRAF'.", "fixed": true, "try_times": 3, "pred": "SELECT DISTINCT bft.test_manufacturer\nFROM biomarker AS bm\nJOIN biomarker_fda AS bfa ON bm.id = bfa.id\nJOIN biomarker_fda_test AS bft ON bfa.id = bft.test_trade_name\nWHERE bm.gene_symbol = 'BRAF' AND bft.test_manufacturer IS NOT NULL;"}
{"idx": 183, "db_id": "oncomx", "query": "Show cancer biomarker panels ", "evidence": "", "extracted_schema": {"biomarker": "keep_all", "biomarker_fda_test": "keep_all", "biomarker_fda": "keep_all", "biomarker_edrn": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_test_use": "drop_all", "biomarker_article": "drop_all", "biomarker_alias": "drop_all", "disease": "drop_all", "disease_mutation": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease_mutation_tissue": "drop_all", "healthy_expression": "drop_all", "anatomical_entity": "drop_all", "map_uniprot_canonical_id": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all", "differential_expression": "drop_all", "stage": "drop_all", "xref_gene_ensembl": "drop_all", "species": "drop_all"}, "ground_truth": "SELECT *\nFROM biomarker\n  JOIN\n     biomarker_edrn ON biomarker.id = biomarker_edrn.id\n    JOIN\n     biomarker_fda on biomarker.id = biomarker_fda.id\n         JOIN\n     biomarker_fda_test ON biomarker_fda.test_submission = biomarker_fda_test.test_submission and biomarker_fda.test_trade_name = biomarker_fda_test.test_trade_name\n         LEFT JOIN anatomical_entity ON anatomical_entity.id = biomarker_edrn.uberon_anatomical_id\n         JOIN cancer_tissue ON cancer_tissue.uberon_anatomical_id = anatomical_entity.id\n         JOIN disease ON disease.id = biomarker_fda_test.doid or disease.id = cancer_tissue.doid\nWHERE biomarker.test_is_a_panel = 'true'\n  AND biomarker.gene_symbol != 'NULL'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT b.gene_symbol, b.biomarker_description, b.biomarker_id\nFROM biomarker AS b\nJOIN biomarker_fda_test AS fda_test ON b.biomarker_id = fda_test.test_trade_name\nWHERE b.test_is_a_panel = 'true'", "qa_pairs": "To show cancer biomarker panels, we need to identify the relevant tables that contain information about biomarkers and their association with cancer. Based on the provided schema, the `biomarker` table contains information about biomarkers, and the `biomarker_fda_test` table includes details about tests related to biomarkers, including whether they are panels.\n\nWe can assume that a \"biomarker panel\" is indicated by the `test_is_a_panel` field in the `biomarker` table being set to 'true'. Additionally, we may want to filter for biomarkers that are specifically related to cancer, which can be inferred from the `biomarker_fda_test` table.\n\nHere is the SQL query to retrieve cancer biomarker panels:\n\n```sql\nSELECT b.gene_symbol, b.biomarker_description, b.biomarker_id\nFROM biomarker AS b\nJOIN biomarker_fda_test AS fda_test ON b.biomarker_id = fda_test.test_trade_name\nWHERE b.test_is_a_panel = 'true'\n```\n\nThis query selects the gene symbol, biomarker description, and biomarker ID from the `biomarker` table where the test is a panel, joining it with the `biomarker_fda_test` table to ensure we are only looking at relevant cancer biomarkers. Adjust the join condition based on the actual relationships in your schema if necessary.", "fixed": true, "try_times": 3, "pred": "SELECT b.gene_symbol, b.biomarker_description, b.biomarker_id\nFROM biomarker AS b\nJOIN biomarker_fda AS fda ON b.id = fda.id\nWHERE b.test_is_a_panel = 'true'\nAND b.biomarker_id IS NOT NULL\nAND b.biomarker_description IS NOT NULL"}
{"idx": 184, "db_id": "oncomx", "query": "Show name of biomarkers with tests from 23andMe", "evidence": "", "extracted_schema": {"biomarker": "keep_all", "biomarker_fda_test": ["test_trade_name", "test_submission", "test_manufacturer", "biomarker_origin", "doid", "histological_type"], "biomarker_fda": ["id", "test_trade_name", "test_submission"]}, "ground_truth": "select * from biomarker as b join  biomarker_fda as bf on b.id = bf.id\njoin biomarker_fda_test as bft on bf.test_trade_name = bft.test_trade_name and bf.test_submission = bft.test_submission\nwhere test_manufacturer like '23andMe'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT b.biomarker_description \nFROM biomarker AS b \nJOIN biomarker_fda_test AS fda_test ON b.biomarker_id = fda_test.test_trade_name \nWHERE fda_test.test_manufacturer = '23andMe';", "qa_pairs": "To show the names of biomarkers with tests from 23andMe, we need to join the relevant tables that contain information about biomarkers and their associated tests. Based on the provided schema, we can infer that the `biomarker` table contains the biomarker names, and the `biomarker_fda_test` table contains information about tests, including the manufacturer.\n\nAssuming that \"23andMe\" is a manufacturer listed in the `test_manufacturer` column of the `biomarker_fda_test` table, the SQL query would look like this:\n\n```sql\nSELECT b.biomarker_description \nFROM biomarker AS b \nJOIN biomarker_fda_test AS fda_test ON b.biomarker_id = fda_test.test_trade_name \nWHERE fda_test.test_manufacturer = '23andMe';\n```\n\nThis query selects the biomarker descriptions from the `biomarker` table that are associated with tests manufactured by \"23andMe\". \n\nPlease adjust the column names and conditions based on the actual structure of your database if necessary.", "fixed": true, "try_times": 3, "pred": "SELECT b.biomarker_description \nFROM biomarker AS b \nJOIN biomarker_fda AS fda ON b.id = fda.id \nJOIN biomarker_fda_test AS fda_test ON fda.test_trade_name = fda_test.test_trade_name \nWHERE fda_test.test_manufacturer = '23andMe' \nAND b.biomarker_description IS NOT NULL;"}
{"idx": 185, "db_id": "oncomx", "query": "Show the name of all manufacturer producing tests for breast cancer biomarkers", "evidence": "", "extracted_schema": {"biomarker_fda_test": "keep_all", "biomarker_fda": "keep_all", "disease": "keep_all", "biomarker": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_test_use": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_article": "drop_all", "biomarker_alias": "drop_all", "biomarker_edrn": "drop_all", "disease_mutation": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease_mutation_tissue": "drop_all", "xref_gene_ensembl": "drop_all", "species": "drop_all", "stage": "drop_all", "healthy_expression": "drop_all", "anatomical_entity": "drop_all", "map_uniprot_canonical_id": "drop_all", "map_protein_disease_mutation": "drop_all", "cancer_tissue": "drop_all", "differential_expression": "drop_all"}, "ground_truth": "select distinct bft.test_manufacturer\nfrom biomarker as  b join\nbiomarker_fda as  bf on b.id = bf.id\njoin biomarker_fda_test as  bft on \nbf.test_trade_name = bft.test_trade_name and bf.test_submission = bft.test_submission\nwhere b.gene_symbol like '%BRCA%'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT DISTINCT bft.test_manufacturer\nFROM biomarker_fda_test AS bft\nJOIN biomarker_fda AS bf ON bft.test_trade_name = bf.test_trade_name AND bft.test_submission = bf.test_submission\nJOIN biomarker AS b ON bf.id = b.biomarker_id\nJOIN biomarker_fda_test_use AS bftu ON bft.test_trade_name = bftu.test_trade_name AND bft.test_submission = bftu.test_submission\nJOIN disease AS d ON bftu.doid = d.id\nWHERE d.name LIKE '%breast cancer%'", "qa_pairs": "To retrieve the names of all manufacturers producing tests for breast cancer biomarkers, we need to join the relevant tables based on the relationships defined in the schema. The key tables involved are `biomarker_fda_test`, `biomarker_fda`, and `disease`. We will filter the results to include only those related to breast cancer.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT DISTINCT bft.test_manufacturer\nFROM biomarker_fda_test AS bft\nJOIN biomarker_fda AS bf ON bft.test_trade_name = bf.test_trade_name AND bft.test_submission = bf.test_submission\nJOIN biomarker AS b ON bf.id = b.biomarker_id\nJOIN biomarker_fda_test_use AS bftu ON bft.test_trade_name = bftu.test_trade_name AND bft.test_submission = bftu.test_submission\nJOIN disease AS d ON bftu.doid = d.id\nWHERE d.name LIKE '%breast cancer%'\n```\n\n### Explanation:\n1. **SELECT DISTINCT**: We use `DISTINCT` to ensure that we get unique manufacturer names.\n2. **FROM biomarker_fda_test AS bft**: We start from the `biomarker_fda_test` table, which contains information about tests.\n3. **JOIN biomarker_fda AS bf**: We join with `biomarker_fda` to get the corresponding biomarker information.\n4. **JOIN biomarker AS b**: We join with the `biomarker` table to link the biomarker details.\n5. **JOIN biomarker_fda_test_use AS bftu**: This join allows us to access the approved indications for the tests.\n6. **JOIN disease AS d**: Finally, we join with the `disease` table to filter for breast cancer biomarkers.\n7. **WHERE d.name LIKE '%breast cancer%'**: This condition filters the results to include only those related to breast cancer.\n\nThis query will return the names of all manufacturers producing tests for breast cancer biomarkers.", "fixed": true, "try_times": 3, "pred": "SELECT DISTINCT bft.test_manufacturer\nFROM biomarker_fda_test AS bft\nJOIN biomarker_fda AS bf ON bft.test_trade_name = bf.test_trade_name AND bft.test_submission = bf.test_submission\nJOIN biomarker AS b ON bf.id = b.biomarker_id\nJOIN disease AS d ON bft.doid = d.id\nWHERE d.name LIKE '%breast cancer%'"}
{"idx": 186, "db_id": "oncomx", "query": "Show all approved tests for breast cancer biomarkers", "evidence": "", "extracted_schema": {"biomarker_fda_test": "keep_all", "biomarker_fda": "keep_all", "biomarker": "keep_all", "disease": "keep_all"}, "ground_truth": "select *\nfrom biomarker as b join\nbiomarker_fda as bf on b.id = bf.id\njoin biomarker_fda_test as bft on \nbf.test_trade_name = bft.test_trade_name and bf.test_submission = bft.test_submission\njoin biomarker_fda_test_use as  bfu on \nbfu.test_trade_name = bft.test_trade_name and bfu.test_submission = bft.test_submission\nwhere b.gene_symbol like '%BRCA%'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT \n    b.biomarker_description, \n    b.biomarker_id, \n    f.test_trade_name, \n    f.test_submission \nFROM \n    biomarker AS b \nJOIN \n    biomarker_fda_test AS f ON b.biomarker_id = f.doid \nJOIN \n    disease AS d ON b.doid = d.id \nWHERE \n    d.name = 'breast cancer' \n    AND f.test_approval_status = 'approved';", "qa_pairs": "To show all approved tests for breast cancer biomarkers, we need to join the relevant tables that contain information about biomarkers, their FDA tests, and the diseases they are associated with. The relevant tables are `biomarker`, `biomarker_fda_test`, and `disease`. \n\nWe will filter the results to include only those biomarkers that are associated with breast cancer. Assuming that \"breast cancer\" corresponds to a specific `doid` in the `disease` table, we will need to identify that `doid` first. For this example, let's assume the `doid` for breast cancer is known (you would replace this with the actual `doid` value for breast cancer).\n\nHere is the SQL query to retrieve the approved tests for breast cancer biomarkers:\n\n```sql\nSELECT \n    b.biomarker_description, \n    b.biomarker_id, \n    f.test_trade_name, \n    f.test_submission \nFROM \n    biomarker AS b \nJOIN \n    biomarker_fda_test AS f ON b.biomarker_id = f.doid \nJOIN \n    disease AS d ON b.doid = d.id \nWHERE \n    d.name = 'breast cancer' \n    AND f.test_approval_status = 'approved';\n```\n\nIn this query:\n- We select the biomarker description, biomarker ID, test trade name, and test submission.\n- We join the `biomarker` table with the `biomarker_fda_test` table on the biomarker ID.\n- We also join with the `disease` table to filter for breast cancer.\n- We filter for tests that have an approval status of 'approved'. \n\nMake sure to replace `'breast cancer'` with the actual name or identifier used in your `disease` table if it differs.", "fixed": true, "try_times": 3, "pred": "SELECT \n    b.biomarker_description, \n    b.biomarker_id, \n    f.test_trade_name, \n    f.test_submission \nFROM \n    biomarker AS b \nJOIN \n    biomarker_edrn AS edrn ON b.id = edrn.id \nJOIN \n    biomarker_fda AS fda ON b.id = fda.id \nJOIN \n    biomarker_fda_test AS f ON fda.test_trade_name = f.test_trade_name AND fda.test_submission = f.test_submission \nWHERE \n    edrn.qa_state = 'Accepted' \n    AND f.test_approval_status = 'Class II 510(k)' \n    AND b.biomarker_description LIKE '%breast cancer%'\n    AND b.biomarker_description IS NOT NULL;"}
{"idx": 187, "db_id": "oncomx", "query": "Return the anatomical entity associated with the most biomarkers", "evidence": "", "extracted_schema": {"biomarker": "keep_all", "biomarker_edrn": "keep_all", "anatomical_entity": ["id", "name", "description"], "biomarker_fda": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_test_use": "drop_all", "biomarker_alias": "drop_all", "biomarker_article": "drop_all", "disease": "drop_all", "disease_mutation": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease_mutation_tissue": "drop_all", "differential_expression": "drop_all", "healthy_expression": "drop_all", "map_protein_disease_mutation": "drop_all", "map_uniprot_canonical_id": "drop_all", "species": "drop_all", "stage": "drop_all", "cancer_tissue": "drop_all"}, "ground_truth": "SELECT anatomical_entity.name\nFROM biomarker\nJOIN biomarker_edrn ON biomarker.id = biomarker_edrn.id\nJOIN anatomical_entity ON biomarker_edrn.uberon_anatomical_id = anatomical_entity.id\nGROUP BY anatomical_entity.name\nORDER BY COUNT(*) DESC\nLIMIT 1\n", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance"]}, "pruned": true, "final_sql": "SELECT ae.name, COUNT(be.id) AS biomarker_count\nFROM anatomical_entity AS ae\nJOIN biomarker_edrn AS be ON ae.id = be.uberon_anatomical_id\nGROUP BY ae.id\nORDER BY biomarker_count DESC\nLIMIT 1;", "qa_pairs": "To find the anatomical entity associated with the most biomarkers, we need to join the `biomarker_edrn` table with the `anatomical_entity` table and count the occurrences of each anatomical entity. We will then order the results by the count in descending order and limit the results to the top one.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT ae.name, COUNT(be.id) AS biomarker_count\nFROM anatomical_entity AS ae\nJOIN biomarker_edrn AS be ON ae.id = be.uberon_anatomical_id\nGROUP BY ae.id\nORDER BY biomarker_count DESC\nLIMIT 1;\n```\n\nThis query selects the name of the anatomical entity and the count of associated biomarkers, groups the results by anatomical entity ID, orders them by the count of biomarkers in descending order, and limits the output to the entity with the highest count.", "fixed": false, "try_times": 1, "pred": "SELECT ae.name, COUNT(be.id) AS biomarker_count\nFROM anatomical_entity AS ae\nJOIN biomarker_edrn AS be ON ae.id = be.uberon_anatomical_id\nGROUP BY ae.id\nORDER BY biomarker_count DESC\nLIMIT 1;"}
{"idx": 189, "db_id": "oncomx", "query": "top 3 cancer types with more differential expression entries ", "evidence": "", "extracted_schema": {"disease": "keep_all", "differential_expression": "keep_all", "biomarker": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_use": "drop_all", "biomarker_fda_test_trial": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_edrn": "drop_all", "biomarker_article": "drop_all", "biomarker_alias": "drop_all", "disease_mutation": "drop_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease_mutation_tissue": "drop_all", "cancer_tissue": "drop_all", "healthy_expression": "drop_all", "anatomical_entity": "drop_all", "map_uniprot_canonical_id": "drop_all", "map_protein_disease_mutation": "drop_all", "xref_gene_ensembl": "drop_all", "species": "drop_all", "stage": "drop_all"}, "ground_truth": "select d.name , count(*)  from differential_expression JOIN disease as d ON d.id = doid \ngroup by d.name order by  count(*) desc limit 3", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT d.name AS cancer_type, COUNT(de.id) AS entry_count\nFROM differential_expression AS de\nJOIN disease AS d ON de.doid = d.id\nGROUP BY d.name\nORDER BY entry_count DESC\nLIMIT 3;", "qa_pairs": "To find the top 3 cancer types with the most differential expression entries, you can use the following SQL query. This query will join the `differential_expression` table with the `disease` table to count the number of entries for each cancer type and then order the results to get the top 3.\n\n```sql\nSELECT d.name AS cancer_type, COUNT(de.id) AS entry_count\nFROM differential_expression AS de\nJOIN disease AS d ON de.doid = d.id\nGROUP BY d.name\nORDER BY entry_count DESC\nLIMIT 3;\n```\n\nThis SQL statement does the following:\n- Selects the name of the cancer type and counts the number of entries in the `differential_expression` table.\n- Joins the `differential_expression` table with the `disease` table on the `doid` field.\n- Groups the results by the cancer type name.\n- Orders the results in descending order based on the count of entries.\n- Limits the results to the top 3 cancer types.", "fixed": true, "try_times": 2, "pred": "SELECT d.name AS cancer_type, COUNT(de.gene_symbol) AS entry_count\nFROM differential_expression AS de\nJOIN disease AS d ON de.doid = d.id\nGROUP BY d.name\nORDER BY entry_count DESC\nLIMIT 3;"}
{"idx": 190, "db_id": "oncomx", "query": "Find all of the edrn biomarkers that have never been approved by the FDA ", "evidence": "", "extracted_schema": {"biomarker_edrn": "keep_all", "biomarker_fda": "drop_all", "biomarker_fda_test": "drop_all", "biomarker_fda_test_use": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all"}, "ground_truth": "SELECT t1.id from biomarker as t1 join biomarker_edrn as t2 on t1.id = t2.id WHERE t1.id NOT IN (SELECT t1.id from biomarker as t1 join biomarker_fda as t2 on t1.id = t2.id join biomarker_fda_test_use as bftu on t2.test_submission = bftu.test_submission)", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT edrn.*\nFROM biomarker_edrn AS edrn\nLEFT JOIN biomarker_fda AS fda ON edrn.id = fda.id\nWHERE fda.id IS NULL;", "qa_pairs": "To find all of the EDRN biomarkers that have never been approved by the FDA, we need to identify biomarkers that exist in the `biomarker_edrn` table but do not have corresponding entries in the `biomarker_fda` table. We can achieve this using a LEFT JOIN and checking for NULL values in the FDA-related fields.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT edrn.*\nFROM biomarker_edrn AS edrn\nLEFT JOIN biomarker_fda AS fda ON edrn.id = fda.id\nWHERE fda.id IS NULL;\n```\n\n### Explanation:\n- We select all columns from the `biomarker_edrn` table (aliased as `edrn`).\n- We perform a LEFT JOIN with the `biomarker_fda` table (aliased as `fda`) on the `id` field.\n- The `WHERE fda.id IS NULL` condition filters the results to include only those EDRN biomarkers that do not have a corresponding entry in the FDA table, indicating that they have never been approved by the FDA.", "fixed": true, "try_times": 2, "pred": "-- SQL Type: SELECT\nSELECT edrn.id, edrn.biomarker_title, edrn.qa_state, edrn.biomarker_type\nFROM biomarker_edrn AS edrn\nLEFT JOIN biomarker_fda AS fda ON edrn.id = fda.id\nWHERE fda.id IS NULL AND edrn.id IS NOT NULL;"}
{"idx": 191, "db_id": "oncomx", "query": "Show all of the edrn biomarkers that have been approved by the FDA ", "evidence": "", "extracted_schema": {"biomarker_edrn": "keep_all", "biomarker_fda": "keep_all", "biomarker_fda_test": "keep_all", "biomarker_fda_test_use": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all"}, "ground_truth": "SELECT t1.id from biomarker as t1 join biomarker_edrn as t2 on t1.id = t2.id WHERE t1.id\nIN (SELECT t1.id from biomarker as t1 join biomarker_fda as t2 on t1.id = t2.id join biomarker_fda_test_use as bftu on t2.test_submission = bftu.test_submission)", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT edrn.biomarker_title, fda.test_trade_name, fda.test_submission\nFROM biomarker_edrn AS edrn\nJOIN biomarker AS bm ON edrn.id = bm.id\nJOIN biomarker_fda AS fda ON bm.biomarker_id = fda.id\nWHERE fda.test_approval_status = 'Approved';", "qa_pairs": "To show all of the EDRN biomarkers that have been approved by the FDA, we need to join the `biomarker_edrn` table with the `biomarker_fda` table based on the `id` field in the `biomarker_edrn` table and the `biomarker` table. We will also filter for biomarkers that have an approval status indicating they are approved.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT edrn.biomarker_title, fda.test_trade_name, fda.test_submission\nFROM biomarker_edrn AS edrn\nJOIN biomarker AS bm ON edrn.id = bm.id\nJOIN biomarker_fda AS fda ON bm.biomarker_id = fda.id\nWHERE fda.test_approval_status = 'Approved';\n```\n\nThis query selects the biomarker title from the `biomarker_edrn` table and the corresponding FDA test trade name and submission from the `biomarker_fda` table, filtering for those that have been approved.", "fixed": true, "try_times": 3, "pred": "SELECT edrn.biomarker_title, fda_test.test_trade_name, fda_test.test_submission\nFROM biomarker_edrn AS edrn\nJOIN biomarker AS bm ON edrn.id = bm.id\nJOIN biomarker_fda AS fda ON bm.id = fda.id\nJOIN biomarker_fda_test AS fda_test ON fda.test_trade_name = fda_test.test_trade_name \n    AND fda.test_submission = fda_test.test_submission\nWHERE fda_test.test_approval_status IN ('Class II 510(k)', 'PMA', '513(f)(2)', 'PMP', 'class II')\nAND fda_test.test_approval_status IS NOT NULL;"}
{"idx": 192, "db_id": "oncomx", "query": "which cosmic data source reported the most mutations for each chromosome?", "evidence": "", "extracted_schema": {"disease_mutation": "keep_all", "disease": "keep_all", "disease_mutation_article": "drop_all", "disease_mutation_impact_prediction": "drop_all", "disease_mutation_site_annotation": "drop_all", "disease_mutation_tissue": "drop_all"}, "ground_truth": "SELECT  chromosome_id, count(*)  FROM disease_mutation where data_source = 'cosmic' group by chromosome_id order by count(*) desc limit 5 ", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT chromosome_id, data_source, COUNT(*) AS mutation_count\nFROM disease_mutation\nWHERE data_source = 'cosmic'\nGROUP BY chromosome_id, data_source\nHAVING mutation_count = (\n    SELECT MAX(mutation_count)\n    FROM (\n        SELECT COUNT(*) AS mutation_count\n        FROM disease_mutation\n        WHERE data_source = 'cosmic'\n        GROUP BY chromosome_id, data_source\n    ) AS subquery\n    WHERE subquery.chromosome_id = disease_mutation.chromosome_id\n)", "qa_pairs": "To find out which COSMIC data source reported the most mutations for each chromosome, we need to analyze the `disease_mutation` table, which contains information about mutations, including the `data_source` field. We will group the results by `chromosome_id` and `data_source`, count the number of mutations for each combination, and then select the maximum count for each chromosome.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT chromosome_id, data_source, COUNT(*) AS mutation_count\nFROM disease_mutation\nWHERE data_source = 'cosmic'\nGROUP BY chromosome_id, data_source\nHAVING mutation_count = (\n    SELECT MAX(mutation_count)\n    FROM (\n        SELECT COUNT(*) AS mutation_count\n        FROM disease_mutation\n        WHERE data_source = 'cosmic'\n        GROUP BY chromosome_id, data_source\n    ) AS subquery\n    WHERE subquery.chromosome_id = disease_mutation.chromosome_id\n)\n```\n\n### Explanation:\n1. **SELECT chromosome_id, data_source, COUNT(*) AS mutation_count**: This selects the chromosome ID, the data source, and counts the number of mutations for each combination.\n2. **FROM disease_mutation**: This specifies the table from which to retrieve the data.\n3. **WHERE data_source = 'cosmic'**: This filters the results to only include mutations reported by the COSMIC data source.\n4. **GROUP BY chromosome_id, data_source**: This groups the results by chromosome ID and data source.\n5. **HAVING mutation_count = (SELECT MAX(mutation_count) ...)**: This subquery finds the maximum mutation count for each chromosome and filters the main query to only include those records that match the maximum count.\n\nThis query will return the chromosome ID, the COSMIC data source, and the count of mutations for each chromosome where the count is the highest for that chromosome.", "fixed": true, "try_times": 2, "pred": "-- SQL Type: SELECT\nSELECT chromosome_id, data_source, COUNT(*) AS mutation_count\nFROM disease_mutation\nWHERE data_source = 'cosmic'\nGROUP BY chromosome_id, data_source\nHAVING COUNT(*) = (\n    SELECT MAX(mutation_count)\n    FROM (\n        SELECT COUNT(*) AS mutation_count\n        FROM disease_mutation\n        WHERE data_source = 'cosmic'\n        GROUP BY chromosome_id\n    )\n)"}
{"idx": 193, "db_id": "oncomx", "query": "show me all the genes that relate to biomarkers of prostate cancer.", "evidence": "", "extracted_schema": {"biomarker": "keep_all", "biomarker_fda": "keep_all", "disease": ["id", "name"], "biomarker_edrn": ["biomarker_title", "biomarker_type", "qa_state"], "biomarker_fda_test": ["test_trade_name", "test_submission", "biomarker_origin", "test_approval_status", "test_adoption_evidence"]}, "ground_truth": "select biomarker.gene_symbol\nfrom disease as dis\njoin biomarker_fda_test as fda on dis.id = fda.doid\njoin biomarker_fda as bio_fda on bio_fda.test_trade_name = fda.test_trade_name\njoin biomarker as bio on bio.id = biomarker_fda.id\nwhere dis.name = \"prostate cancer\"", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_submission", "biomarker_origin", "doid", "test_adoption_evidence", "test_approval_status"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT DISTINCT xref_gene_ensembl.gene_symbol\nFROM disease\nJOIN disease_mutation ON disease.id = disease_mutation.doid\nJOIN biomarker ON disease_mutation.id = biomarker.id\nJOIN xref_gene_ensembl ON biomarker.gene_symbol = xref_gene_ensembl.gene_symbol\nWHERE disease.name = 'prostate cancer';", "qa_pairs": "To find all the genes that relate to biomarkers of prostate cancer, we need to join the relevant tables based on the relationships defined in the schema. The key steps are to identify the disease ID for prostate cancer, find the biomarkers associated with that disease, and then retrieve the gene symbols related to those biomarkers.\n\nHere’s the SQL query to achieve this:\n\n```sql\nSELECT DISTINCT xref_gene_ensembl.gene_symbol\nFROM disease\nJOIN disease_mutation ON disease.id = disease_mutation.doid\nJOIN biomarker ON disease_mutation.id = biomarker.id\nJOIN xref_gene_ensembl ON biomarker.gene_symbol = xref_gene_ensembl.gene_symbol\nWHERE disease.name = 'prostate cancer';\n```\n\n### Explanation:\n1. **FROM disease**: Start with the disease table to filter for prostate cancer.\n2. **JOIN disease_mutation**: Join with the disease_mutation table to get the mutations related to prostate cancer.\n3. **JOIN biomarker**: Join with the biomarker table to find biomarkers associated with those mutations.\n4. **JOIN xref_gene_ensembl**: Finally, join with the xref_gene_ensembl table to get the gene symbols related to those biomarkers.\n5. **WHERE disease.name = 'prostate cancer'**: Filter the results to only include those related to prostate cancer.\n6. **SELECT DISTINCT**: Use DISTINCT to ensure that each gene symbol is listed only once in the results. \n\nThis query will return all unique gene symbols that are associated with biomarkers of prostate cancer.", "fixed": true, "try_times": 3, "pred": "SELECT DISTINCT xref_gene_ensembl.gene_symbol\nFROM disease\nJOIN disease_mutation ON disease.id = disease_mutation.doid\nJOIN biomarker ON disease_mutation.id = biomarker.id\nJOIN xref_gene_ensembl ON biomarker.gene_symbol = xref_gene_ensembl.gene_symbol\nWHERE disease.name = 'prostate cancer' AND xref_gene_ensembl.gene_symbol IS NOT NULL;"}
{"idx": 194, "db_id": "oncomx", "query": "How many fda test have been executed for each biomarker for each test use?", "evidence": "", "extracted_schema": {"biomarker_fda_test": ["test_trade_name", "test_submission", "test_trial_id", "test_adoption_evidence", "test_approval_status", "test_study_design"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "biomarker": "drop_all", "biomarker_fda": "drop_all", "biomarker_fda_drug": "drop_all", "biomarker_fda_ncit_term": "drop_all", "biomarker_fda_test_trial": "drop_all"}, "ground_truth": "select  \n\tbio.biomarker_description ,\n\ttest_use.actual_use,\n\tcount(*)\nfrom biomarker_edrn as edrn\njoin anatomical_entity as anat_ent on edrn.uberon_anatomical_id = anat_ent.id\njoin biomarker as bio on bio.id = edrn.id\njoin biomarker_fda as bio_fda on bio_fda.id = bio.id\njoin biomarker_fda_test as fda_test on bio_fda.test_trade_name = fda_test.test_trade_name\njoin biomarker_fda_test_use as test_use on test_use.test_trade_name = fda_test.test_trade_name\nGROUP BY test_use.actual_use, bio.biomarker_description", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_submission", "doid", "test_adoption_evidence", "test_approval_status", "test_study_design"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT \n    bftu.approved_indication,\n    COUNT(bft.test_trade_name) AS test_count\nFROM \n    biomarker_fda_test_use AS bftu\nJOIN \n    biomarker_fda_test AS bft ON bftu.test_trade_name = bft.test_trade_name AND bftu.test_submission = bft.test_submission\nJOIN \n    biomarker AS b ON bftu.id = b.id\nGROUP BY \n    bftu.approved_indication, bftu.test_trade_name, bftu.test_submission", "qa_pairs": "To answer the question \"How many FDA tests have been executed for each biomarker for each test use?\", we need to join the relevant tables and count the number of FDA tests associated with each biomarker and test use.\n\nThe relevant tables are:\n- `biomarker_fda_test_use` (which contains the test trade name, submission, and approved indication)\n- `biomarker_fda_test` (which contains the test trade name and submission)\n\nWe will group the results by the biomarker and test use to get the count of executed tests.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT \n    bftu.approved_indication,\n    COUNT(bft.test_trade_name) AS test_count\nFROM \n    biomarker_fda_test_use AS bftu\nJOIN \n    biomarker_fda_test AS bft ON bftu.test_trade_name = bft.test_trade_name AND bftu.test_submission = bft.test_submission\nJOIN \n    biomarker AS b ON bftu.id = b.id\nGROUP BY \n    bftu.approved_indication, bftu.test_trade_name, bftu.test_submission\n```\n\nThis query does the following:\n1. Joins the `biomarker_fda_test_use` table with the `biomarker_fda_test` table on the `test_trade_name` and `test_submission` fields.\n2. It also joins with the `biomarker` table to ensure we are counting tests for each biomarker.\n3. It groups the results by `approved_indication`, `test_trade_name`, and `test_submission` to count the number of tests executed for each biomarker for each test use.\n4. Finally, it selects the `approved_indication` and the count of tests as `test_count`.", "fixed": true, "try_times": 3, "pred": "SELECT \n    bftu.approved_indication,\n    COUNT(DISTINCT bft.test_trade_name) AS test_count\nFROM \n    biomarker_fda_test_use AS bftu\nJOIN \n    biomarker_fda_test AS bft ON bftu.test_trade_name = bft.test_trade_name AND bftu.test_submission = bft.test_submission\nJOIN \n    biomarker AS b ON bftu.id = b.id\nWHERE \n    bftu.approved_indication IS NOT NULL\nGROUP BY \n    bftu.approved_indication\nHAVING \n    COUNT(DISTINCT bft.test_trade_name) > 0"}
{"idx": 195, "db_id": "oncomx", "query": "What are the test names that have been approved by the FDA for diagnosis", "evidence": "", "extracted_schema": {"biomarker_fda_test": "keep_all", "biomarker_fda": "keep_all", "biomarker_fda_test_use": "keep_all", "biomarker_fda_drug": "drop_all"}, "ground_truth": "SELECT distinct(bft.test_trade_name) FROM biomarker_fda_test_use as bftu JOIN biomarker_fda_test  as bft \nON bft.test_trade_name = bftu.test_trade_name \nAND bft.test_submission = bftu.test_submission \nWHERE bftu.approved_indication LIKE '%diagnosis%'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT test_trade_name \nFROM biomarker_fda_test \nWHERE test_approval_status = 'PMA' OR test_approval_status = 'Class II 510(k)' \nAND approved_indication = 'diagnosis';", "qa_pairs": "```sql\nSELECT test_trade_name \nFROM biomarker_fda_test \nWHERE test_approval_status = 'PMA' OR test_approval_status = 'Class II 510(k)' \nAND approved_indication = 'diagnosis';\n```", "fixed": true, "try_times": 2, "pred": "-- SQL Query to find FDA approved test names for diagnosis\nSELECT bft.test_trade_name \nFROM biomarker_fda_test bft\nJOIN biomarker_fda_test_use bftu ON bft.test_trade_name = bftu.test_trade_name AND bft.test_submission = bftu.test_submission\nWHERE (bft.test_approval_status = 'PMA' OR bft.test_approval_status = 'Class II 510(k)') \nAND bftu.approved_indication = 'diagnosis';"}
{"idx": 196, "db_id": "oncomx", "query": "Who manufactures lung cancer prognosis tests that are approved by the FDA?", "evidence": "", "extracted_schema": {"biomarker_fda_test": ["test_trade_name", "test_submission", "test_manufacturer", "biomarker_origin", "test_approval_status", "test_adoption_evidence"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"]}, "ground_truth": "SELECT distinct(d.name), bft.test_trade_name, bft.test_manufacturer\nFROM biomarker_fda_test_use as bftu JOIN biomarker_fda_test as bft \n        ON bft.test_trade_name = bftu.test_trade_name \n        AND bft.test_submission = bftu.test_submission \nJOIN biomarker_fda as bf ON bft.test_trade_name = bf.test_trade_name \n        AND bft.test_submission = bf.test_submission \nJOIN biomarker as b ON bf.id = b.id\nJOIN disease AS d ON d.id = bft.doid\nWHERE\n        bftu.approved_indication LIKE '%prognosis%'\n                AND d.name LIKE '%lung%'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "test_adoption_evidence", "test_approval_status"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT DISTINCT bft.test_manufacturer\nFROM biomarker_fda_test AS bft\nJOIN biomarker_fda AS bf ON bft.test_trade_name = bf.test_trade_name AND bft.test_submission = bf.test_submission\nJOIN biomarker_fda_test_use AS bftu ON bft.test_trade_name = bftu.test_trade_name AND bft.test_submission = bftu.test_submission\nJOIN disease AS d ON bftu.doid = d.id\nWHERE d.name = 'lung cancer' AND bft.test_approval_status = 'approved';", "qa_pairs": "To find out who manufactures lung cancer prognosis tests that are approved by the FDA, we need to join several tables based on the relationships defined in the schema. Specifically, we will focus on the `biomarker_fda_test`, `biomarker_fda`, and `disease` tables.\n\nHere's the SQL query that accomplishes this:\n\n```sql\nSELECT DISTINCT bft.test_manufacturer\nFROM biomarker_fda_test AS bft\nJOIN biomarker_fda AS bf ON bft.test_trade_name = bf.test_trade_name AND bft.test_submission = bf.test_submission\nJOIN biomarker_fda_test_use AS bftu ON bft.test_trade_name = bftu.test_trade_name AND bft.test_submission = bftu.test_submission\nJOIN disease AS d ON bftu.doid = d.id\nWHERE d.name = 'lung cancer' AND bft.test_approval_status = 'approved';\n```\n\n### Explanation:\n1. **Selecting Distinct Manufacturers**: We use `SELECT DISTINCT` to ensure we get unique manufacturers.\n2. **Joining Tables**:\n   - `biomarker_fda_test` (aliased as `bft`) contains information about the tests.\n   - `biomarker_fda` (aliased as `bf`) links the tests to their FDA approval status.\n   - `biomarker_fda_test_use` (aliased as `bftu`) connects the tests to their approved indications.\n   - `disease` (aliased as `d`) provides the disease name, which we filter for \"lung cancer\".\n3. **Filtering Conditions**: We filter for tests that are specifically for lung cancer and have an approval status of 'approved'.\n\nThis query will return the names of manufacturers who produce lung cancer prognosis tests that are approved by the FDA.", "fixed": true, "try_times": 3, "pred": "SELECT DISTINCT bft.test_manufacturer\nFROM biomarker_fda_test AS bft\nJOIN biomarker_fda AS bf ON bft.test_trade_name = bf.test_trade_name AND bft.test_submission = bf.test_submission\nJOIN disease AS d ON bft.doid = d.id\nWHERE d.name = 'lung cancer' \nAND bft.test_approval_status IN ('Class II 510(k)', 'PMA', '513(f)(2)', 'PMP', 'class II')\nAND bft.test_trade_name IS NOT NULL;  -- Ensuring we only get tests that have a name"}
{"idx": 197, "db_id": "oncomx", "query": "Which diseases can be diagnosed with a blood test?", "evidence": "", "extracted_schema": {"biomarker_fda_test": "keep_all", "biomarker_fda_test_use": "keep_all", "biomarker": "keep_all", "disease": "keep_all"}, "ground_truth": "SELECT distinct(d.name) \nFROM biomarker_fda_test_use as bftu JOIN biomarker_fda_test as bft \n        ON bft.test_trade_name = bftu.test_trade_name \n        AND bft.test_submission = bftu.test_submission \nJOIN biomarker_fda as bf ON bft.test_trade_name = bf.test_trade_name \n        AND bft.test_submission = bf.test_submission \nJOIN biomarker as b ON bf.id = b.id\nJOIN disease AS d ON d.id = bft.doid\nWHERE\n        bftu.approved_indication LIKE '%diagnosis%' \n        AND bft.specimen_type LIKE 'blood'", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT DISTINCT d.name\nFROM disease AS d\nJOIN biomarker_fda_test_use AS bftu ON d.id = bftu.id\nJOIN biomarker_fda_test AS bft ON bftu.test_trade_name = bft.test_trade_name\nWHERE bft.specimen_type = 'blood';", "qa_pairs": "To determine which diseases can be diagnosed with a blood test, we need to look for diseases that are associated with tests that have a specimen type of \"blood\". However, the provided schema does not directly link diseases to specific tests or their specimen types. \n\nAssuming that the `biomarker_fda_test` table contains information about tests and their specimen types, we can join this table with the `disease` table through the `biomarker_fda_test_use` table, which connects tests to diseases.\n\nHere’s the SQL query that retrieves the names of diseases that can be diagnosed with a blood test:\n\n```sql\nSELECT DISTINCT d.name\nFROM disease AS d\nJOIN biomarker_fda_test_use AS bftu ON d.id = bftu.id\nJOIN biomarker_fda_test AS bft ON bftu.test_trade_name = bft.test_trade_name\nWHERE bft.specimen_type = 'blood';\n```\n\nThis query selects distinct disease names from the `disease` table where there is a corresponding entry in the `biomarker_fda_test_use` table that links to a test in the `biomarker_fda_test` table, filtering for tests that specify \"blood\" as the specimen type.", "fixed": true, "try_times": 2, "pred": "SELECT DISTINCT d.name\nFROM disease AS d\nJOIN biomarker_fda_test AS bft ON d.id = bft.doid\nJOIN biomarker_fda_test_use AS bftu ON bft.test_trade_name = bftu.test_trade_name AND bft.test_submission = bftu.test_submission\nWHERE bft.specimen_type = 'blood';"}
{"idx": 198, "db_id": "oncomx", "query": "Show all the information about biomarkers and the species for which they are healthy expressed", "evidence": "", "extracted_schema": {"biomarker": "keep_all", "healthy_expression": "keep_all", "species": "keep_all"}, "ground_truth": "select bio.biomarker_description, species.species\nfrom biomarker as bio\n    join biomarker_edrn as be on bio.id = be.id\n    join anatomical_entity as ae on be.uberon_anatomical_id = ae.id\n    join healthy_expression as he on ae.id = he.uberon_anatomical_id\n    join xref_gene_ensembl as xge on he.ensembl_gene_id = xge.ensembl_gene_id\n    join species as s on xge.speciesid = s.speciesid", "difficulty": "oncomx", "chosen_db_schem_dict": {"biomarker_alias": ["biomarker_internal_id", "alias"], "biomarker_article": ["biomarker_internal_id", "pmid"], "biomarker_edrn": ["id", "qa_state", "biomarker_title", "biomarker_type", "uberon_anatomical_id", "phase"], "biomarker_fda_drug": ["biomarker_fda_id", "biomarker_drug"], "biomarker": ["id", "gene_symbol", "biomarker_description", "biomarker_id", "test_is_a_panel"], "biomarker_fda_ncit_term": ["biomarker_fda_id", "ncit_biomarker"], "biomarker_fda": ["id", "test_trade_name", "test_submission"], "biomarker_fda_test_trial": ["test_trade_name", "test_submission", "test_trial_id"], "biomarker_fda_test": ["test_trade_name", "test_manufacturer", "test_submission", "biomarker_origin", "doid", "histological_type", "specimen_type", "platform_method", "test_number_genes", "test_adoption_evidence", "test_approval_status", "test_study_design", "clinical_significance"], "biomarker_fda_test_use": ["id", "test_trade_name", "test_submission", "approved_indication", "actual_use"], "disease_mutation_article": ["pmid", "disease_mutation_id"], "disease_mutation_impact_prediction": ["id", "disease_mutation_id", "site_prediction", "probability", "tool"], "disease_mutation_site_annotation": ["id", "disease_mutation_id", "description", "feature_key"], "disease": ["id", "name"], "xref_gene_ensembl": ["gene_symbol", "ensembl_gene_id", "speciesid"], "species": ["speciesid", "genus", "species", "speciescommonname"], "stage": ["id", "name"], "disease_mutation": ["id", "chromosome_id", "chromosome_pos", "ref_nt", "alt_nt", "ensembl_transcript_id", "cds_pos", "peptide_pos", "aa_pos_uniprotkb", "ref_aa", "alt_aa", "mutation_freq", "data_source", "doid"], "healthy_expression": ["ensembl_gene_id", "uberon_anatomical_id", "uberon_developmental_id", "expression_level_gene_relative", "expression_level_anatomical_relative", "call_quality", "expression_rank_score", "expression_score"], "anatomical_entity": ["id", "name", "description"], "map_uniprot_canonical_id": ["uniprotkb_ac", "uniprotkb_canonical_ac"], "disease_mutation_tissue": ["uberon_anatomical_id", "disease_mutation_id"], "map_protein_disease_mutation": ["peptide_id", "ensembl_transcript_id", "uniprotkb_ac"], "cancer_tissue": ["doid", "uberon_anatomical_id"], "differential_expression": ["gene_symbol", "doid", "log2fc", "pvalue", "adjpvalue", "statistical_significance", "expression_change_direction", "subjects_up", "subjects_down", "subjects_nochange", "subjects_nocoverage", "subjects_total"]}, "pruned": true, "final_sql": "SELECT \n    biomarker.*, \n    species.*\nFROM \n    biomarker\nJOIN \n    healthy_expression ON biomarker.biomarker_id = healthy_expression.ensembl_gene_id\nJOIN \n    xref_gene_ensembl ON healthy_expression.ensembl_gene_id = xref_gene_ensembl.ensembl_gene_id\nJOIN \n    species ON xref_gene_ensembl.speciesid = species.speciesid\nWHERE \n    healthy_expression.expression_level_gene_relative != 'ABSENT';", "qa_pairs": "To retrieve all the information about biomarkers and the species for which they are healthy expressed, we need to join the `biomarker` table with the `healthy_expression` table and the `xref_gene_ensembl` table, which links gene symbols to species. The `species` table will also be joined to get the species information.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT \n    biomarker.*, \n    species.*\nFROM \n    biomarker\nJOIN \n    healthy_expression ON biomarker.biomarker_id = healthy_expression.ensembl_gene_id\nJOIN \n    xref_gene_ensembl ON healthy_expression.ensembl_gene_id = xref_gene_ensembl.ensembl_gene_id\nJOIN \n    species ON xref_gene_ensembl.speciesid = species.speciesid\nWHERE \n    healthy_expression.expression_level_gene_relative != 'ABSENT';\n```\n\n### Explanation:\n- We select all columns from the `biomarker` and `species` tables.\n- We join the `biomarker` table with the `healthy_expression` table on the `biomarker_id` and `ensembl_gene_id`.\n- We then join the `healthy_expression` table with the `xref_gene_ensembl` table to link gene symbols to species.\n- Finally, we join the `xref_gene_ensembl` table with the `species` table to get the species information.\n- The `WHERE` clause filters out any entries where the expression level is 'ABSENT', ensuring we only get biomarkers that are healthy expressed.", "fixed": true, "try_times": 3, "pred": "-- SQL Type: SELECT\nSELECT \n    DISTINCT biomarker.id AS biomarker_id, \n    biomarker.gene_symbol, \n    biomarker.biomarker_description, \n    species.genus, \n    species.species, \n    species.speciescommonname\nFROM \n    biomarker\nJOIN \n    healthy_expression ON biomarker.id = healthy_expression.ensembl_gene_id\nJOIN \n    xref_gene_ensembl ON biomarker.gene_symbol = xref_gene_ensembl.gene_symbol\nJOIN \n    species ON xref_gene_ensembl.speciesid = species.speciesid\nWHERE \n    healthy_expression.expression_level_gene_relative != 'ABSENT'\n    AND healthy_expression.ensembl_gene_id IS NOT NULL;"}
{"idx": 199, "db_id": "sdss", "query": "What is photometrically observed star", "evidence": "", "extracted_schema": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "field", "mode", "type", "clean"], "specobj": ["specobjid", "bestobjid", "class", "subclass", "ra", "dec"]}, "ground_truth": "select p.objid from photoobj as p JOIN photo_type as pt on p.type = pt.value where pt.name = 'STAR' ", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "field", "mode", "type", "clean"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.objid, p.run, p.field, pt.name AS photo_type_name\nFROM photoobj AS p\nJOIN photo_type AS pt ON p.type = pt.value\nWHERE pt.name = 'STAR';", "qa_pairs": "To find photometrically observed stars, we need to query the `photoobj` table to identify objects classified as stars. We can do this by filtering the `type` column in the `photoobj` table for entries that correspond to stars. Additionally, we can join with the `photo_type` table to get a more descriptive name for the type of observation.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT p.objid, p.run, p.field, pt.name AS photo_type_name\nFROM photoobj AS p\nJOIN photo_type AS pt ON p.type = pt.value\nWHERE pt.name = 'STAR';\n```\n\nThis query selects the object ID, run number, field number, and the name of the photo type for all entries in the `photoobj` table where the type corresponds to 'STAR' in the `photo_type` table.", "fixed": false, "try_times": 1, "pred": "SELECT p.objid, p.run, p.field, pt.name AS photo_type_name\nFROM photoobj AS p\nJOIN photo_type AS pt ON p.type = pt.value\nWHERE pt.name = 'STAR';"}
{"idx": 200, "db_id": "sdss", "query": "Show me all photometrically observable star", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": "keep_all", "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "class", "subclass", "bestobjid", "survey", "mjd"], "photo_type": ["value", "name", "description"]}, "ground_truth": "select p.objid from photoobj as p JOIN photo_type as pt on p.type = pt.value where pt.name = 'STAR' ", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type", "clean", "flags", "rowc", "colc", "cmodelmag_u", "cmodelmag_g", "cmodelmag_r", "ra", "dec", "b", "l", "extinction_r", "mjd", "loadversion", "u", "g", "r", "i", "z"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "survey", "mjd", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT * \nFROM photoobj AS p \nJOIN photo_type AS pt ON p.type = pt.value \nWHERE pt.name = 'STAR';", "qa_pairs": "To retrieve all photometrically observable stars from the database, we need to join the `photoobj` table with the `photo_type` table to filter for entries where the type corresponds to 'STAR'. \n\nHere’s the SQL query that accomplishes this:\n\n```sql\nSELECT * \nFROM photoobj AS p \nJOIN photo_type AS pt ON p.type = pt.value \nWHERE pt.name = 'STAR';\n```\n\nThis query selects all columns from the `photoobj` table where the type matches the value associated with 'STAR' in the `photo_type` table.", "fixed": false, "try_times": 1, "pred": "SELECT * \nFROM photoobj AS p \nJOIN photo_type AS pt ON p.type = pt.value \nWHERE pt.name = 'STAR';"}
{"idx": 201, "db_id": "sdss", "query": "Find all photometrically observable star that have spectral observations. Retrieve the object id, right ascension, and declination. ", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": "keep_all", "galspecline": "keep_all", "spplines": "keep_all", "specobj": "keep_all", "photo_type": "drop_all"}, "ground_truth": "select p.objid, p.ra, p.dec from photoobj as p join specobj as s on s.bestobjid = p.objid join photo_type as pt on p.type = pt.value where pt.name = 'STAR'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type", "clean", "flags", "rowc", "colc", "cmodelmag_u", "cmodelmag_g", "cmodelmag_r", "ra", "dec", "b", "l", "extinction_r", "mjd", "loadversion", "u", "g", "r", "i", "z"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "segue2primary", "survey", "programname", "mjd", "plate", "fiberid", "special_target1", "segue2_target1", "segue2_target2", "ancillary_target1", "ra", "dec", "z", "zerr", "zwarning", "class", "subclass", "veldisp", "veldisperr", "loadversion"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.objid, p.ra, p.dec\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE p.type = (SELECT value FROM photo_type WHERE name = 'STAR');", "qa_pairs": "To find all photometrically observable stars that have spectral observations, we need to join the relevant tables based on the provided schema. Specifically, we will join the `photoobj` table (which contains photometric observations) with the `specobj` table (which contains spectral observations) and filter for objects that are classified as stars.\n\nHere's the SQL query to achieve this:\n\n```sql\nSELECT p.objid, p.ra, p.dec\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE p.type = (SELECT value FROM photo_type WHERE name = 'STAR');\n```\n\n### Explanation:\n1. **SELECT p.objid, p.ra, p.dec**: We are selecting the object ID, right ascension, and declination from the `photoobj` table.\n2. **FROM photoobj AS p**: We are using the `photoobj` table and aliasing it as `p`.\n3. **JOIN specobj AS s ON p.objid = s.bestobjid**: We are joining the `specobj` table (aliased as `s`) on the condition that the `objid` from `photoobj` matches the `bestobjid` from `specobj`, which indicates that there are spectral observations for that object.\n4. **WHERE p.type = (SELECT value FROM photo_type WHERE name = 'STAR')**: We filter the results to include only those objects that are classified as stars by checking the `type` in the `photoobj` table against the `photo_type` table to get the corresponding value for 'STAR'.\n\nThis query will return the desired information about photometrically observable stars that have spectral observations.", "fixed": false, "try_times": 1, "pred": "SELECT p.objid, p.ra, p.dec\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE p.type = (SELECT value FROM photo_type WHERE name = 'STAR');"}
{"idx": 202, "db_id": "sdss", "query": "Show me the object id, right ascension, and declination of photometrically observed star that have spectral observations.", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "ra", "dec", "type", "mode", "clean"], "galspecline": "keep_all", "spplines": "keep_all", "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class"], "photo_type": "drop_all"}, "ground_truth": "select p.objid, p.ra, p.dec from photoobj as p join specobj as s on s.bestobjid = p.objid join photo_type as pt on p.type = pt.value where pt.name = 'STAR'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "mode", "type", "clean", "ra", "dec"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.objid, p.ra, p.dec \nFROM photoobj AS p \nJOIN specobj AS s ON p.objid = s.bestobjid \nWHERE p.type = 'STAR';", "qa_pairs": "To retrieve the object ID, right ascension, and declination of photometrically observed stars that have spectral observations, we need to join the relevant tables based on the provided foreign key relationships. Specifically, we will join the `photoobj` table with the `specobj` table to filter for stars and ensure that they have spectral observations.\n\nHere's the SQL query that accomplishes this:\n\n```sql\nSELECT p.objid, p.ra, p.dec \nFROM photoobj AS p \nJOIN specobj AS s ON p.objid = s.bestobjid \nWHERE p.type = 'STAR';\n```\n\n### Explanation:\n- We select the `objid`, `ra`, and `dec` from the `photoobj` table (aliased as `p`).\n- We join the `photoobj` table with the `specobj` table (aliased as `s`) on the condition that `p.objid` matches `s.bestobjid`, ensuring that we only get objects that have spectral observations.\n- We filter the results to include only those entries in the `photoobj` table where the `type` is 'STAR', which indicates that we are interested in photometrically observed stars.", "fixed": true, "try_times": 3, "pred": "SELECT p.objid, p.ra, p.dec \nFROM photoobj AS p \nJOIN specobj AS s ON p.objid = s.bestobjid \nWHERE p.type = 'STAR' AND s.specobjid IS NOT NULL;"}
{"idx": 203, "db_id": "sdss", "query": "What is photometrically observed Galaxy", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "galspecline": "keep_all", "spplines": "drop_all", "specobj": ["specobjid", "bestobjid", "class", "subclass", "ra", "dec"], "photo_type": "drop_all"}, "ground_truth": "select p.objid from photoobj as p JOIN photo_type as pt on p.type = pt.value where pt.name = 'GALAXY'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT DISTINCT p.objid \nFROM photoobj AS p \nJOIN specobj AS s ON p.objid = s.specobjid \nWHERE s.class = 'GALAXY';", "qa_pairs": "To find photometrically observed galaxies, we need to join the relevant tables based on the foreign key relationships and filter for the objects classified as galaxies. The relevant tables are `photoobj`, `specobj`, and `neighbors`. \n\nHere's the SQL query to achieve that:\n\n```sql\nSELECT DISTINCT p.objid \nFROM photoobj AS p \nJOIN specobj AS s ON p.objid = s.specobjid \nWHERE s.class = 'GALAXY';\n```\n\nThis query selects distinct object IDs from the `photoobj` table that are classified as galaxies in the `specobj` table.", "fixed": true, "try_times": 2, "pred": "-- SQL Query to find photometrically observed galaxies\nSELECT DISTINCT p.objid \nFROM photoobj AS p \nJOIN specobj AS s ON p.objid = s.bestobjid \nWHERE s.class = 'GALAXY';"}
{"idx": 204, "db_id": "sdss", "query": "Find Galaxy that are photometrically observable", "evidence": "", "extracted_schema": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "field", "mode", "type", "clean"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "survey", "class"]}, "ground_truth": "select p.objid from photoobj as p JOIN photo_type as pt on p.type = pt.value where pt.name = 'GALAXY'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "field", "mode", "type", "clean"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "survey", "class"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT DISTINCT specobj.specobjid \nFROM specobj \nJOIN photoobj ON specobj.bestobjid = photoobj.objid \nWHERE specobj.class = 'GALAXY';", "qa_pairs": "To find galaxies that are photometrically observable, we need to join the relevant tables and filter for the appropriate conditions. Specifically, we will look for entries in the `specobj` table where the class is 'GALAXY' and ensure that these galaxies are linked to the `photoobj` table, which indicates they are photometrically observable.\n\nHere's the SQL query to achieve that:\n\n```sql\nSELECT DISTINCT specobj.specobjid \nFROM specobj \nJOIN photoobj ON specobj.bestobjid = photoobj.objid \nWHERE specobj.class = 'GALAXY';\n```\n\n### Explanation:\n- We select the distinct `specobjid` from the `specobj` table.\n- We join the `specobj` table with the `photoobj` table on the condition that `specobj.bestobjid` matches `photoobj.objid`. This ensures we are only considering objects that have a corresponding photometric observation.\n- We filter the results to include only those entries where the `class` in the `specobj` table is 'GALAXY', indicating that we are interested in galaxies specifically. \n\nThis query will return the IDs of galaxies that are photometrically observable.", "fixed": false, "try_times": 1, "pred": "SELECT DISTINCT specobj.specobjid \nFROM specobj \nJOIN photoobj ON specobj.bestobjid = photoobj.objid \nWHERE specobj.class = 'GALAXY';"}
{"idx": 205, "db_id": "sdss", "query": "Find all photometrically observable Galaxy that have spectral observations. Retrieve the object id, right ascension, and declination. ", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "ra", "dec", "run", "rerun", "field"], "galspecline": "keep_all", "spplines": "drop_all", "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class"], "photo_type": "drop_all"}, "ground_truth": "select p.objid, p.ra, p.dec from photoobj as p join specobj as s on s.bestobjid = p.objid join photo_type as pt on p.type = pt.value where  pt.name = 'GALAXY'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "ra", "dec"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.objid, p.ra, p.dec \nFROM specobj AS s \nJOIN photoobj AS p ON s.bestobjid = p.objid \nWHERE s.class = 'GALAXY' \nAND s.specobjid IN (SELECT specobjid FROM galspecline)", "qa_pairs": "To find all photometrically observable galaxies that have spectral observations, we need to join the relevant tables based on the relationships defined in the schema. Specifically, we will join the `specobj`, `photoobj`, and `neighbors` tables to filter for galaxies and ensure they have spectral observations.\n\nHere's the SQL query to achieve this:\n\n```sql\nSELECT p.objid, p.ra, p.dec \nFROM specobj AS s \nJOIN photoobj AS p ON s.bestobjid = p.objid \nWHERE s.class = 'GALAXY' \nAND s.specobjid IN (SELECT specobjid FROM galspecline)\n```\n\n### Explanation:\n1. **FROM specobj AS s**: We start with the `specobj` table, which contains the spectral observations.\n2. **JOIN photoobj AS p ON s.bestobjid = p.objid**: We join the `photoobj` table to get the corresponding object details (like right ascension and declination) for each spectral object.\n3. **WHERE s.class = 'GALAXY'**: We filter the results to include only those objects classified as 'GALAXY'.\n4. **AND s.specobjid IN (SELECT specobjid FROM galspecline)**: We ensure that the galaxies have spectral observations by checking if their `specobjid` exists in the `galspecline` table.\n\nThis query will return the object ID, right ascension, and declination of all photometrically observable galaxies that have spectral observations.", "fixed": false, "try_times": 1, "pred": "SELECT p.objid, p.ra, p.dec \nFROM specobj AS s \nJOIN photoobj AS p ON s.bestobjid = p.objid \nWHERE s.class = 'GALAXY' \nAND s.specobjid IN (SELECT specobjid FROM galspecline)"}
{"idx": 206, "db_id": "sdss", "query": "Show me the object id, right ascension and declination of photometrically observable Galaxy that have spectral observations.", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "ra", "dec", "type", "mode", "clean"], "galspecline": "keep_all", "spplines": "drop_all", "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class"], "photo_type": "drop_all"}, "ground_truth": "select p.objid, p.ra, p.dec from photoobj as p join specobj as s on s.bestobjid = p.objid join photo_type as pt on p.type = pt.value where  pt.name = 'GALAXY'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "mode", "type", "clean", "ra", "dec"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.objid, p.ra, p.dec\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'GALAXY' AND p.clean = 1;", "qa_pairs": "To retrieve the object ID, right ascension, and declination of photometrically observable galaxies that have spectral observations, we need to join the relevant tables based on their relationships. Specifically, we will join the `photoobj`, `specobj`, and `neighbors` tables to filter for galaxies and ensure they have spectral observations.\n\nHere's the SQL query that accomplishes this:\n\n```sql\nSELECT p.objid, p.ra, p.dec\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'GALAXY' AND p.clean = 1;\n```\n\n### Explanation:\n- We select the `objid`, `ra`, and `dec` from the `photoobj` table (aliased as `p`).\n- We join the `specobj` table (aliased as `s`) on the condition that the `objid` from `photoobj` matches the `bestobjid` from `specobj`.\n- We filter the results to include only those entries where the `class` in the `specobj` table is 'GALAXY' and the `clean` flag in the `photoobj` table is set to 1 (indicating that it is photometrically observable). \n\nThis query will return the desired information for photometrically observable galaxies that have spectral observations.", "fixed": false, "try_times": 1, "pred": "SELECT p.objid, p.ra, p.dec\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'GALAXY' AND p.clean = 1;"}
{"idx": 207, "db_id": "sdss", "query": "Find the object ids, right ascensions and declinations of photometrically observable galaxy whose right ascension is greater than 185, right ascension is less than 186, declination is greater than 15, declination is less than 16.", "evidence": "", "extracted_schema": {"photoobj": ["objid", "ra", "dec", "run", "rerun", "field"], "specobj": ["specobjid", "ra", "dec", "class", "z", "zerr"], "neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"]}, "ground_truth": "select p.objid, p.ra, p.dec from photoobj as p JOIN photo_type as pt on p.type = pt.value where p.ra > 185 and p.ra < 186 and p.dec > 15 and p.dec < 16 and pt.name = 'GALAXY'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "ra", "dec"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "zerr", "class"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.objid, p.ra, p.dec \nFROM photoobj AS p \nJOIN specobj AS s ON p.objid = s.bestobjid \nWHERE s.class = 'GALAXY' \nAND p.ra > 185 \nAND p.ra < 186 \nAND p.dec > 15 \nAND p.dec < 16;", "qa_pairs": "```sql\nSELECT p.objid, p.ra, p.dec \nFROM photoobj AS p \nJOIN specobj AS s ON p.objid = s.bestobjid \nWHERE s.class = 'GALAXY' \nAND p.ra > 185 \nAND p.ra < 186 \nAND p.dec > 15 \nAND p.dec < 16;\n```", "fixed": false, "try_times": 1, "pred": "SELECT p.objid, p.ra, p.dec \nFROM photoobj AS p \nJOIN specobj AS s ON p.objid = s.bestobjid \nWHERE s.class = 'GALAXY' \nAND p.ra > 185 \nAND p.ra < 186 \nAND p.dec > 15 \nAND p.dec < 16;"}
{"idx": 208, "db_id": "sdss", "query": "Show me object id, right ascensions and declinations of photometrically observed galaxy in a certain area, of which the right ascension is between 185 and 186, declination is bertween 15 and 16.", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "ra", "dec", "run", "field", "type"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "ra", "dec", "class", "subclass", "z"], "photo_type": "drop_all"}, "ground_truth": "select p.objid, p.ra, p.dec from photoobj as p JOIN photo_type as pt on p.type = pt.value where p.ra > 185 and p.ra < 186 and p.dec > 15 and p.dec < 16 and pt.name = 'GALAXY'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "field", "type", "ra", "dec"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.objid, p.ra, p.dec \nFROM photoobj AS p \nJOIN specobj AS s ON p.objid = s.bestobjid \nWHERE s.class = 'GALAXY' \nAND p.ra BETWEEN 185 AND 186 \nAND p.dec BETWEEN 15 AND 16;", "qa_pairs": "To retrieve the object ID, right ascensions, and declinations of photometrically observed galaxies within the specified right ascension and declination ranges, you can use the following SQL query. This query joins the `photoobj` and `specobj` tables to filter for galaxies and apply the specified conditions on right ascension and declination.\n\n```sql\nSELECT p.objid, p.ra, p.dec \nFROM photoobj AS p \nJOIN specobj AS s ON p.objid = s.bestobjid \nWHERE s.class = 'GALAXY' \nAND p.ra BETWEEN 185 AND 186 \nAND p.dec BETWEEN 15 AND 16;\n```\n\n### Explanation:\n- `SELECT p.objid, p.ra, p.dec`: This selects the object ID, right ascension, and declination from the `photoobj` table.\n- `FROM photoobj AS p`: This specifies the `photoobj` table and gives it an alias `p`.\n- `JOIN specobj AS s ON p.objid = s.bestobjid`: This joins the `specobj` table (aliased as `s`) on the condition that the `objid` in `photoobj` matches the `bestobjid` in `specobj`.\n- `WHERE s.class = 'GALAXY'`: This filters the results to include only those entries where the class is 'GALAXY'.\n- `AND p.ra BETWEEN 185 AND 186`: This condition filters the right ascension to be between 185 and 186.\n- `AND p.dec BETWEEN 15 AND 16`: This condition filters the declination to be between 15 and 16. \n\nThis query will return the desired results based on the specified criteria.", "fixed": false, "try_times": 1, "pred": "SELECT p.objid, p.ra, p.dec \nFROM photoobj AS p \nJOIN specobj AS s ON p.objid = s.bestobjid \nWHERE s.class = 'GALAXY' \nAND p.ra BETWEEN 185 AND 186 \nAND p.dec BETWEEN 15 AND 16;"}
{"idx": 209, "db_id": "sdss", "query": "Find the object ids, right ascensions and declinations of photometrically observable star whose right ascension is greater than 185, right ascension is less than 186, declination is greater than 15, declination is less than 16.", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "ra", "dec", "type", "mode", "clean"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": "drop_all", "photo_type": "drop_all"}, "ground_truth": "select p.objid, p.ra, p.dec from photoobj as p JOIN photo_type as pt on p.type = pt.value where p.ra > 185 and p.ra < 186 and p.dec > 15 and p.dec < 16 and pt.name = 'STAR'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "mode", "type", "clean", "ra", "dec"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "segue2primary", "survey"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT objid, ra, dec \nFROM photoobj \nWHERE type = 'STAR' \nAND ra > 185 \nAND ra < 186 \nAND dec > 15 \nAND dec < 16 \nAND clean = 1;", "qa_pairs": "```sql\nSELECT objid, ra, dec \nFROM photoobj \nWHERE type = 'STAR' \nAND ra > 185 \nAND ra < 186 \nAND dec > 15 \nAND dec < 16 \nAND clean = 1;\n```", "fixed": true, "try_times": 2, "pred": "-- SQL Type: SELECT\nSELECT p.objid, p.ra, p.dec \nFROM photoobj p\nJOIN photo_type pt ON p.type = pt.value\nWHERE pt.name = 'STAR' \nAND p.ra > 185 \nAND p.ra < 186 \nAND p.dec > 15 \nAND p.dec < 16 \nAND p.clean = 1;"}
{"idx": 210, "db_id": "sdss", "query": "Show me object id, right ascensions and declinations of photometrically observed star in a certain area, of which the right ascension is between 185 and 186, declination is bertween 15 and 16.", "evidence": "", "extracted_schema": {"photoobj": ["objid", "ra", "dec", "type", "mode", "clean"], "neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "class", "subclass"]}, "ground_truth": "select p.objid, p.ra, p.dec from photoobj as p JOIN photo_type as pt on p.type = pt.value where p.ra > 185 and p.ra < 186 and p.dec > 15 and p.dec < 16 and pt.name = 'STAR'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "mode", "type", "clean", "ra", "dec"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT objid, ra, dec \nFROM photoobj \nWHERE type = 'STAR' \nAND ra BETWEEN 185 AND 186 \nAND dec BETWEEN 15 AND 16;", "qa_pairs": "```sql\nSELECT objid, ra, dec \nFROM photoobj \nWHERE type = 'STAR' \nAND ra BETWEEN 185 AND 186 \nAND dec BETWEEN 15 AND 16;\n```", "fixed": true, "try_times": 3, "pred": "-- SQL Type: SELECT\nSELECT DISTINCT p.objid, p.ra, p.dec \nFROM photoobj p\nJOIN neighbors n ON p.objid = n.objid\nWHERE n.mode = 1  -- Assuming '1' corresponds to photometric observation\nAND p.ra BETWEEN 185 AND 186 \nAND p.dec BETWEEN 15 AND 16\nAND p.ra IS NOT NULL\nAND p.dec IS NOT NULL;"}
{"idx": 211, "db_id": "sdss", "query": "Find all spectroscopic observed star,  whose right ascension is greater than 185 and less than 186, declination is greater than 15 and less than 16. Retrieve their object id, right ascension, declination, and photometric object type", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "ra", "dec", "type", "mode", "clean"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "ra", "dec", "class", "subclass", "bestobjid"], "photo_type": "drop_all"}, "ground_truth": "select p.objid, p.ra, p.dec, s.z from Photoobj as p join specobj as s on s.bestobjid = p.objid where s.ra > 185 and s.ra < 186 AND s.dec > 15 and s.dec < 16 and s.class = 'STAR'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "mode", "type", "clean", "ra", "dec"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT \n    so.specobjid AS object_id, \n    so.ra AS right_ascension, \n    so.dec AS declination, \n    po.type AS photometric_object_type\nFROM \n    specobj AS so\nJOIN \n    photoobj AS po ON so.bestobjid = po.objid\nWHERE \n    so.class = 'STAR' \n    AND so.ra > 185 \n    AND so.ra < 186 \n    AND so.dec > 15 \n    AND so.dec < 16;", "qa_pairs": "To find all spectroscopic observed stars with the specified conditions on right ascension and declination, and to retrieve their object id, right ascension, declination, and photometric object type, you can use the following SQL query:\n\n```sql\nSELECT \n    so.specobjid AS object_id, \n    so.ra AS right_ascension, \n    so.dec AS declination, \n    po.type AS photometric_object_type\nFROM \n    specobj AS so\nJOIN \n    photoobj AS po ON so.bestobjid = po.objid\nWHERE \n    so.class = 'STAR' \n    AND so.ra > 185 \n    AND so.ra < 186 \n    AND so.dec > 15 \n    AND so.dec < 16;\n```\n\n### Explanation:\n1. **SELECT Clause**: We select the `specobjid` from the `specobj` table as `object_id`, the `ra` (right ascension), the `dec` (declination), and the `type` from the `photoobj` table as `photometric_object_type`.\n2. **FROM Clause**: We are querying from the `specobj` table (aliased as `so`).\n3. **JOIN Clause**: We join the `photoobj` table (aliased as `po`) on the condition that the `bestobjid` in `specobj` matches the `objid` in `photoobj`.\n4. **WHERE Clause**: We filter the results to include only those records where the `class` is 'STAR' and the specified conditions for right ascension and declination are met. \n\nThis query will return the desired information for all stars that meet the specified criteria.", "fixed": false, "try_times": 1, "pred": "SELECT \n    so.specobjid AS object_id, \n    so.ra AS right_ascension, \n    so.dec AS declination, \n    po.type AS photometric_object_type\nFROM \n    specobj AS so\nJOIN \n    photoobj AS po ON so.bestobjid = po.objid\nWHERE \n    so.class = 'STAR' \n    AND so.ra > 185 \n    AND so.ra < 186 \n    AND so.dec > 15 \n    AND so.dec < 16;"}
{"idx": 212, "db_id": "sdss", "query": "Fetch me the object id, right ascension, declination, and redshift of spectroscopic observed star in a certain area, of which the right ascension is in an unbouded interval of 185 and 186, declination is in an unbouded interval of 15 and 16.", "evidence": "", "extracted_schema": {"photoobj": ["objid", "ra", "dec", "type", "mode", "clean"], "specobj": ["specobjid", "ra", "dec", "z", "class", "subclass"], "neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"]}, "ground_truth": "select p.objid, p.ra, p.dec, s.z from Photoobj as p join specobj as s on s.bestobjid = p.objid where s.ra > 185 and s.ra < 186 AND s.dec > 15 and s.dec < 16 and s.class = 'STAR'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "mode", "type", "clean", "ra", "dec"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT objid, ra, dec, z \nFROM specobj \nWHERE class = 'STAR' \nAND ra BETWEEN 185 AND 186 \nAND dec BETWEEN 15 AND 16;", "qa_pairs": "```sql\nSELECT objid, ra, dec, z \nFROM specobj \nWHERE class = 'STAR' \nAND ra BETWEEN 185 AND 186 \nAND dec BETWEEN 15 AND 16;\n```", "fixed": true, "try_times": 2, "pred": "-- SQL Type: SELECT\nSELECT photoobj.objid, specobj.ra, specobj.dec, specobj.z \nFROM specobj \nJOIN photoobj ON specobj.bestobjid = photoobj.objid \nWHERE specobj.class = 'STAR' \nAND specobj.ra BETWEEN 185 AND 186 \nAND specobj.dec BETWEEN 15 AND 16;"}
{"idx": 213, "db_id": "sdss", "query": "Find properties of all spectroscopic observed galaxy,  whose right ascension is greater than 185 and less than 186, declination is greater than 15 and less than 16.", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": "drop_all", "galspecline": "drop_all", "spplines": "drop_all", "specobj": "keep_all", "photo_type": "drop_all"}, "ground_truth": "select p.objID, p.ra, p.dec, s.z from Photoobj as p join specobj as s on s.bestobjid = p.objid where s.ra > 185 and s.ra < 186 AND s.dec > 15 and s.dec < 16 and s.class = 'GALAXY'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "segue2primary", "survey", "programname", "mjd", "plate", "fiberid", "special_target1", "segue2_target1", "segue2_target2", "ancillary_target1", "ra", "dec", "z", "zerr", "zwarning", "class", "subclass", "veldisp", "veldisperr", "loadversion"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT * \nFROM specobj \nWHERE class = 'GALAXY' \nAND ra > 185 \nAND ra < 186 \nAND dec > 15 \nAND dec < 16;", "qa_pairs": "To find the properties of all spectroscopically observed galaxies with the specified conditions on right ascension and declination, you can use the following SQL query:\n\n```sql\nSELECT * \nFROM specobj \nWHERE class = 'GALAXY' \nAND ra > 185 \nAND ra < 186 \nAND dec > 15 \nAND dec < 16;\n```\n\nThis query selects all columns from the `specobj` table where the `class` is 'GALAXY' and the `ra` (right ascension) and `dec` (declination) fall within the specified ranges.", "fixed": false, "try_times": 1, "pred": "SELECT * \nFROM specobj \nWHERE class = 'GALAXY' \nAND ra > 185 \nAND ra < 186 \nAND dec > 15 \nAND dec < 16;"}
{"idx": 214, "db_id": "sdss", "query": "Show me the object id, right ascension, declination, and redshift of spectroscopic observed galaxy in a certain area, of which the right ascension is in an unbouded interval of 185 and 186, declination is in an unbouded interval of 15 and 16.", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "ra", "dec", "type", "mode", "clean"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "ra", "dec", "z", "class", "subclass"], "photo_type": "drop_all"}, "ground_truth": "select p.objID, p.ra, p.dec, s.z from Photoobj as p join specobj as s on s.bestobjid = p.objid where s.ra > 185 and s.ra < 186 AND s.dec > 15 and s.dec < 16 and s.class = 'GALAXY'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "mode", "type", "clean", "ra", "dec"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT \n    so.specobjid AS object_id, \n    so.ra AS right_ascension, \n    so.dec AS declination, \n    so.z AS redshift \nFROM \n    specobj AS so \nWHERE \n    so.class = 'GALAXY' \n    AND so.ra > 185 AND so.ra < 186 \n    AND so.dec > 15 AND so.dec < 16;", "qa_pairs": "To retrieve the object id, right ascension, declination, and redshift of spectroscopic observed galaxies within the specified right ascension and declination intervals, you can use the following SQL query:\n\n```sql\nSELECT \n    so.specobjid AS object_id, \n    so.ra AS right_ascension, \n    so.dec AS declination, \n    so.z AS redshift \nFROM \n    specobj AS so \nWHERE \n    so.class = 'GALAXY' \n    AND so.ra > 185 AND so.ra < 186 \n    AND so.dec > 15 AND so.dec < 16;\n```\n\n### Explanation:\n- We are selecting the `specobjid` (object id), `ra` (right ascension), `dec` (declination), and `z` (redshift) from the `specobj` table.\n- We filter the results to include only those records where the `class` is 'GALAXY'.\n- The conditions for right ascension (`ra`) and declination (`dec`) are set to be within the specified unbounded intervals (greater than 185 and less than 186 for `ra`, and greater than 15 and less than 16 for `dec`).", "fixed": false, "try_times": 1, "pred": "SELECT \n    so.specobjid AS object_id, \n    so.ra AS right_ascension, \n    so.dec AS declination, \n    so.z AS redshift \nFROM \n    specobj AS so \nWHERE \n    so.class = 'GALAXY' \n    AND so.ra > 185 AND so.ra < 186 \n    AND so.dec > 15 AND so.dec < 16;"}
{"idx": 215, "db_id": "sdss", "query": "Find all photometrically observable star with a difference of magnitude u and magnitude g is less than 0.4,  the difference between magnitude g and magnitude r is less than 0.7, the difference between magnitude r and magnitude i is greater than 0.4 and the difference between magnitude i and magnitude z is greater than 0.4", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "u", "g", "r", "i", "z"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "class", "subclass", "ra", "dec", "z"], "photo_type": "drop_all"}, "ground_truth": "select p.objid from photoobj as p JOIN photo_type as pt on p.type = pt.value where pt.name = 'STAR' and p.u - p.g < 0.4  and p.g - p.r < 0.7 and p.r - p.i > 0.4 and p.i - p.z > 0.4", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "u", "g", "r", "i", "z"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT * \nFROM photoobj \nWHERE ABS(u - g) < 0.4 \n  AND ABS(g - r) < 0.7 \n  AND ABS(r - i) > 0.4 \n  AND ABS(i - z) > 0.4 \n  AND objid IN (SELECT objid FROM neighbors WHERE type = 3)  -- Assuming type 3 corresponds to stars", "qa_pairs": "To find all photometrically observable stars that meet the specified conditions regarding the differences in magnitudes, we can construct an SQL query that filters the `photoobj` table based on the given criteria. The conditions are as follows:\n\n1. The difference between magnitude `u` and magnitude `g` is less than 0.4.\n2. The difference between magnitude `g` and magnitude `r` is less than 0.7.\n3. The difference between magnitude `r` and magnitude `i` is greater than 0.4.\n4. The difference between magnitude `i` and magnitude `z` is greater than 0.4.\n5. The object type must be a star.\n\nAssuming that the `photoobj` table has a column that indicates the type of object (which is not explicitly mentioned in the schema but is implied), we will filter for stars. \n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT * \nFROM photoobj \nWHERE ABS(u - g) < 0.4 \n  AND ABS(g - r) < 0.7 \n  AND ABS(r - i) > 0.4 \n  AND ABS(i - z) > 0.4 \n  AND objid IN (SELECT objid FROM neighbors WHERE type = 3)  -- Assuming type 3 corresponds to stars\n```\n\nIn this query:\n- We use `ABS()` to calculate the absolute differences between the magnitudes.\n- We filter the `photoobj` table based on the specified conditions.\n- We assume that the `type` column in the `neighbors` table indicates the type of object, and we filter for stars (assuming type 3 corresponds to stars). Adjust the type value as necessary based on your actual data.", "fixed": false, "try_times": 1, "pred": "SELECT * \nFROM photoobj \nWHERE ABS(u - g) < 0.4 \n  AND ABS(g - r) < 0.7 \n  AND ABS(r - i) > 0.4 \n  AND ABS(i - z) > 0.4 \n  AND objid IN (SELECT objid FROM neighbors WHERE type = 3)  -- Assuming type 3 corresponds to stars"}
{"idx": 216, "db_id": "sdss", "query": "Show me the photometrically observed star with the following constraints in its color bands, u - g < 0.4, g - r < 0.7, r - i > 0.4 and i - z > 0.4", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "bestobjid", "class", "subclass", "ra", "dec"], "photo_type": "drop_all"}, "ground_truth": "select p.objid from photoobj as p JOIN photo_type as pt on p.type = pt.value where pt.name = 'STAR' and p.u - p.g < 0.4  and p.g - p.r < 0.7 and p.r - p.i > 0.4 and p.i - p.z > 0.4", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.*\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'STAR'\nAND (p.u - p.g) < 0.4\nAND (p.g - p.r) < 0.7\nAND (p.r - p.i) > 0.4\nAND (p.i - p.z) > 0.4;", "qa_pairs": "To retrieve the photometrically observed stars that meet the specified color band constraints, we need to join the relevant tables and apply the necessary conditions. However, the provided schema does not explicitly include color band measurements. Assuming that the color bands (u, g, r, i, z) are derived from the `photoobj` table or related tables, we will need to make some assumptions about how these values are stored.\n\nFor the sake of this query, let's assume that the `photoobj` table has columns for the color bands (u, g, r, i, z) that we can use to apply the constraints. If these columns do not exist, you would need to adjust the query based on the actual schema.\n\nHere’s how the SQL query would look based on the constraints provided:\n\n```sql\nSELECT p.*\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'STAR'\nAND (p.u - p.g) < 0.4\nAND (p.g - p.r) < 0.7\nAND (p.r - p.i) > 0.4\nAND (p.i - p.z) > 0.4;\n```\n\n### Explanation:\n1. **SELECT p.***: This selects all columns from the `photoobj` table.\n2. **FROM photoobj AS p**: This specifies the `photoobj` table as the main table.\n3. **JOIN specobj AS s ON p.objid = s.bestobjid**: This joins the `specobj` table to filter for stars.\n4. **WHERE s.class = 'STAR'**: This condition filters the results to include only stars.\n5. **AND (p.u - p.g) < 0.4**: This applies the first color band constraint.\n6. **AND (p.g - p.r) < 0.7**: This applies the second color band constraint.\n7. **AND (p.r - p.i) > 0.4**: This applies the third color band constraint.\n8. **AND (p.i - p.z) > 0.4**: This applies the fourth color band constraint.\n\nMake sure to adjust the column names and logic based on the actual structure of your database if the color bands are stored differently.", "fixed": false, "try_times": 1, "pred": "SELECT p.*\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'STAR'\nAND (p.u - p.g) < 0.4\nAND (p.g - p.r) < 0.7\nAND (p.r - p.i) > 0.4\nAND (p.i - p.z) > 0.4;"}
{"idx": 217, "db_id": "sdss", "query": "Find all star in photometrically observable binary star system, of which the neighbor's distance less than 0.05,  the difference of magnitude u and magnitude g is lower than 0.4, the difference of magnitude g and magnitude r is lower than 0.7, the difference of magnitude r and magnitude i is higher than 0.4 and the difference of magnitude i and magnitude z is higher than 0.4", "evidence": "", "extracted_schema": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "u", "g", "r", "i", "z"], "specobj": ["specobjid", "class", "subclass", "ra", "dec", "z"]}, "ground_truth": "select p.objid from photoobj as p join photo_type as pt on p.type = pt.value where pt.name = 'STAR' and (p.u - p.g) < 0.4 and (p.g - p.r) < 0.7 and  (p.r - p.i) > 0.4 and (p.i - p.z) > 0.4 and p.objid in (select n.objid from neighbors as n join photo_type as pt on n.neighbortype = pt.value where n.distance < 0.05 and pt.name = 'STAR');", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "u", "g", "r", "i", "z"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.objid\nFROM photoobj AS p\nJOIN neighbors AS n ON p.objid = n.objid\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE n.distance < 0.05\n  AND ABS(p.u - p.g) < 0.4\n  AND ABS(p.g - p.r) < 0.7\n  AND ABS(p.r - p.i) > 0.4\n  AND ABS(p.i - p.z) > 0.4\n  AND s.class = 'STAR';", "qa_pairs": "To find all stars in photometrically observable binary star systems that meet the specified criteria, we will need to join the relevant tables and apply the necessary filters based on the conditions provided. \n\nHere's the SQL query that accomplishes this:\n\n```sql\nSELECT p.objid\nFROM photoobj AS p\nJOIN neighbors AS n ON p.objid = n.objid\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE n.distance < 0.05\n  AND ABS(p.u - p.g) < 0.4\n  AND ABS(p.g - p.r) < 0.7\n  AND ABS(p.r - p.i) > 0.4\n  AND ABS(p.i - p.z) > 0.4\n  AND s.class = 'STAR';\n```\n\n### Explanation:\n1. **Table Joins**:\n   - We join `photoobj` (aliased as `p`) with `neighbors` (aliased as `n`) on the `objid` to get the distances to neighbors.\n   - We also join `specobj` (aliased as `s`) to filter for stars.\n\n2. **Conditions**:\n   - We filter for neighbors with a distance of less than 0.05.\n   - We check the differences in magnitudes:\n     - The difference between `u` and `g` is less than 0.4.\n     - The difference between `g` and `r` is less than 0.7.\n     - The difference between `r` and `i` is greater than 0.4.\n     - The difference between `i` and `z` is greater than 0.4.\n   - Finally, we ensure that the object is classified as a 'STAR'.\n\nThis query will return the `objid` of all stars that meet the specified criteria in photometrically observable binary star systems.", "fixed": false, "try_times": 1, "pred": "SELECT p.objid\nFROM photoobj AS p\nJOIN neighbors AS n ON p.objid = n.objid\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE n.distance < 0.05\n  AND ABS(p.u - p.g) < 0.4\n  AND ABS(p.g - p.r) < 0.7\n  AND ABS(p.r - p.i) > 0.4\n  AND ABS(p.i - p.z) > 0.4\n  AND s.class = 'STAR';"}
{"idx": 219, "db_id": "sdss", "query": "Find the number of photometrically observed GALAXY whose magnitude r is less than 17, extinction r is greater than 0.2.", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "mode", "type", "clean", "flags", "cmodelmag_r"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "class", "ra", "dec", "z", "mjd"], "photo_type": "drop_all"}, "ground_truth": "select count(*) from photoobj as p join photo_type as pt on p.type = pt.value where p.r < 17 and p.extinction_r > 0.2 and pt.name = 'GALAXY'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "mode", "type", "clean", "flags", "cmodelmag_r"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "mjd", "ra", "dec", "z", "class"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT COUNT(*) \nFROM specobj AS S \nJOIN photoobj AS P ON S.bestobjid = P.objid \nWHERE S.class = 'GALAXY' \nAND P.cmodelmag_r < 17 \nAND P.clean = 1;  -- Assuming clean flag indicates valid photometry", "qa_pairs": "To find the number of photometrically observed GALAXY objects whose magnitude `cmodelmag_r` is less than 17 and extinction `r` is greater than 0.2, we need to join the relevant tables and apply the necessary filters. However, the schema provided does not explicitly mention an extinction value. Assuming that the extinction value is represented in some way in the `photoobj` table or is derived from another table, we will proceed with the assumption that we can filter based on the `cmodelmag_r` value.\n\nHere’s the SQL query that accomplishes this:\n\n```sql\nSELECT COUNT(*) \nFROM specobj AS S \nJOIN photoobj AS P ON S.bestobjid = P.objid \nWHERE S.class = 'GALAXY' \nAND P.cmodelmag_r < 17 \nAND P.clean = 1;  -- Assuming clean flag indicates valid photometry\n```\n\n### Explanation:\n1. **Join Tables**: We join the `specobj` table with the `photoobj` table on the `bestobjid` to get the photometric data for each spectroscopic object.\n2. **Filter by Class**: We filter for objects where the `class` is 'GALAXY'.\n3. **Magnitude Condition**: We check that the `cmodelmag_r` is less than 17.\n4. **Count**: Finally, we count the number of records that meet these criteria.\n\nNote: If there is a specific table or column that contains the extinction value, you would need to adjust the query accordingly to include that condition.", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(*) \nFROM specobj AS S \nJOIN photoobj AS P ON S.bestobjid = P.objid \nWHERE S.class = 'GALAXY' \nAND P.cmodelmag_r < 17 \nAND P.clean = 1;  -- Assuming clean flag indicates valid photometry"}
{"idx": 220, "db_id": "sdss", "query": "How many photometrically observable GALAXY of which magnitude r is lower than 17 and extinction r is higher than 0.2.", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "mode", "type", "clean", "flags", "cmodelmag_r"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "class", "ra", "dec", "z", "zerr"], "photo_type": "drop_all"}, "ground_truth": "select count(*) from photoobj as p join photo_type as pt on p.type = pt.value where p.r < 17 and p.extinction_r > 0.2 and pt.name = 'GALAXY'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "mode", "type", "clean", "flags", "cmodelmag_r"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "zerr", "class"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT COUNT(*) \nFROM specobj AS S \nJOIN photoobj AS P ON S.bestobjid = P.objid \nWHERE S.class = 'GALAXY' \nAND P.cmodelmag_r < 17 \nAND P.clean = 1;  -- Assuming clean = 1 indicates photometrically observable", "qa_pairs": "To answer the question about how many photometrically observable GALAXY objects have a composite model magnitude \\( r \\) lower than 17 and an extinction \\( r \\) higher than 0.2, we need to join the relevant tables and apply the necessary filters.\n\nGiven the schema, we can assume that the extinction information is not explicitly provided in the tables. However, if we assume that the `cmodelmag_r` in the `photoobj` table represents the composite model magnitude \\( r \\), we can proceed with the following SQL query:\n\n```sql\nSELECT COUNT(*) \nFROM specobj AS S \nJOIN photoobj AS P ON S.bestobjid = P.objid \nWHERE S.class = 'GALAXY' \nAND P.cmodelmag_r < 17 \nAND P.clean = 1;  -- Assuming clean = 1 indicates photometrically observable\n```\n\n### Explanation:\n1. **Join Tables**: We join the `specobj` table (which contains the classification of objects) with the `photoobj` table (which contains photometric data) on the `bestobjid`.\n2. **Filter for GALAXY**: We filter the results to include only those entries where the `class` is 'GALAXY'.\n3. **Magnitude Condition**: We check that the `cmodelmag_r` is less than 17.\n4. **Photometric Observability**: We assume that a `clean` flag of 1 indicates that the object is photometrically observable. If there is a specific column for extinction, it should be included in the WHERE clause as well.\n\nIf there is a specific column for extinction in the schema that was not mentioned, you would need to adjust the query to include that condition.", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(*) \nFROM specobj AS S \nJOIN photoobj AS P ON S.bestobjid = P.objid \nWHERE S.class = 'GALAXY' \nAND P.cmodelmag_r < 17 \nAND P.clean = 1;  -- Assuming clean = 1 indicates photometrically observable"}
{"idx": 221, "db_id": "sdss", "query": "Find all photometric observable GALAXY whose magnitude g is brighter than 22, the difference of magnitude u and magnitude g is between -0.27 and 0.71, the difference of magnitude g and magnitude r is between -0.24 and 0.35, the difference of magnitude r and magnitude i is between -0.27 and 0.57 and the difference of magnitude i and magnitude z is between -0.35 and 0.7. Retrieve the object id and magnitude g with descent order by magnitude g. ", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "g", "u", "r", "i", "z"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "class", "ra", "dec", "z", "zerr"], "photo_type": "drop_all"}, "ground_truth": "select p.objid, p.g from photoobj as p join photo_type as pt on p.type = pt.value where pt.name = 'GALAXY' and p.g <= 22 and p.u - p.g >= -0.27 and p.u - p.g < 0.71 and p.g - p.r  >= -0.24 and p.g - p.r < 0.35 and p.r - p.i >= -0.27 and p.r - p.i < 0.57 and p.i - p.z  >= -0.35 and p.i - p.z < 0.7 order by p.g desc", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "u", "g", "r", "i", "z"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "zerr", "class"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.objid, p.g\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'GALAXY'\n  AND p.g < 22\n  AND (p.u - p.g) BETWEEN -0.27 AND 0.71\n  AND (p.g - p.r) BETWEEN -0.24 AND 0.35\n  AND (p.r - p.i) BETWEEN -0.27 AND 0.57\n  AND (p.i - p.z) BETWEEN -0.35 AND 0.7\nORDER BY p.g DESC;", "qa_pairs": "To find all photometric observable GALAXY objects that meet the specified criteria regarding their magnitudes, we will need to join the relevant tables and apply the necessary filters. The query will involve the `specobj` table to filter for GALAXY objects and the `photoobj` table to apply the magnitude conditions.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT p.objid, p.g\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'GALAXY'\n  AND p.g < 22\n  AND (p.u - p.g) BETWEEN -0.27 AND 0.71\n  AND (p.g - p.r) BETWEEN -0.24 AND 0.35\n  AND (p.r - p.i) BETWEEN -0.27 AND 0.57\n  AND (p.i - p.z) BETWEEN -0.35 AND 0.7\nORDER BY p.g DESC;\n```\n\n### Explanation:\n- **SELECT p.objid, p.g**: We are selecting the object ID and magnitude g from the `photoobj` table.\n- **FROM photoobj AS p**: We are using the `photoobj` table and aliasing it as `p`.\n- **JOIN specobj AS s ON p.objid = s.bestobjid**: We join the `specobj` table to filter for GALAXY objects based on the best object ID.\n- **WHERE s.class = 'GALAXY'**: This condition filters the results to include only GALAXY objects.\n- **AND p.g < 22**: This condition ensures that the magnitude g is brighter than 22.\n- **AND (p.u - p.g) BETWEEN -0.27 AND 0.71**: This condition checks the difference between magnitudes u and g.\n- **AND (p.g - p.r) BETWEEN -0.24 AND 0.35**: This condition checks the difference between magnitudes g and r.\n- **AND (p.r - p.i) BETWEEN -0.27 AND 0.57**: This condition checks the difference between magnitudes r and i.\n- **AND (p.i - p.z) BETWEEN -0.35 AND 0.7**: This condition checks the difference between magnitudes i and z.\n- **ORDER BY p.g DESC**: Finally, we order the results in descending order by magnitude g.\n\nThis query will return the desired results based on the specified criteria.", "fixed": false, "try_times": 1, "pred": "SELECT p.objid, p.g\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'GALAXY'\n  AND p.g < 22\n  AND (p.u - p.g) BETWEEN -0.27 AND 0.71\n  AND (p.g - p.r) BETWEEN -0.24 AND 0.35\n  AND (p.r - p.i) BETWEEN -0.27 AND 0.57\n  AND (p.i - p.z) BETWEEN -0.35 AND 0.7\nORDER BY p.g DESC;"}
{"idx": 222, "db_id": "sdss", "query": "Show me the photometric observed Galaxy of which the color band magnitude g is brighter than 22, and the other constraints as following, u - g >= -0.27 but < 0.71, g - r >= -0.24 but < 0.35, r - i >= -0.27 but < 0.57, and i - z >= -0.35 but < 0.7. Rerank the result with descent order by color band magnitude g ", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "segue2primary", "survey"], "photo_type": "drop_all"}, "ground_truth": "select p.objid, p.g from photoobj as p join photo_type as pt on p.type = pt.value where pt.name = 'GALAXY' and p.g <= 22 and p.u - p.g >= -0.27 and p.u - p.g < 0.71 and p.g - p.r  >= -0.24 and p.g - p.r < 0.35 and p.r - p.i >= -0.27 and p.r - p.i < 0.57 and p.i - p.z  >= -0.35 and p.i - p.z < 0.7 order by p.g desc", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "segue2primary", "survey"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.objid, m.g\nFROM photoobj AS p\nJOIN magnitude AS m ON p.objid = m.objid\nWHERE m.g < 22\n  AND (m.u - m.g) >= -0.27 AND (m.u - m.g) < 0.71\n  AND (m.g - m.r) >= -0.24 AND (m.g - m.r) < 0.35\n  AND (m.r - m.i) >= -0.27 AND (m.r - m.i) < 0.57\n  AND (m.i - m.z) >= -0.35 AND (m.i - m.z) < 0.7\nORDER BY m.g DESC;", "qa_pairs": "To construct the SQL query based on the provided database schema and the question, we need to assume that there are additional tables or columns that store the color band magnitudes (u, g, r, i, z) for the objects. Since the schema does not explicitly mention these details, we will assume that there is a table (let's call it `magnitude`) that contains the necessary color band magnitude data.\n\nHere's how the SQL query can be structured based on the constraints provided in the question:\n\n1. We will join the `photoobj` table with the `neighbors` table to filter for galaxies.\n2. We will apply the constraints on the color band magnitudes.\n3. We will order the results by the color band magnitude `g` in descending order.\n\nAssuming the `magnitude` table has the following structure:\n- `objid` (object id)\n- `u`, `g`, `r`, `i`, `z` (color band magnitudes)\n\nThe SQL query would look like this:\n\n```sql\nSELECT p.objid, m.g\nFROM photoobj AS p\nJOIN magnitude AS m ON p.objid = m.objid\nWHERE m.g < 22\n  AND (m.u - m.g) >= -0.27 AND (m.u - m.g) < 0.71\n  AND (m.g - m.r) >= -0.24 AND (m.g - m.r) < 0.35\n  AND (m.r - m.i) >= -0.27 AND (m.r - m.i) < 0.57\n  AND (m.i - m.z) >= -0.35 AND (m.i - m.z) < 0.7\nORDER BY m.g DESC;\n```\n\n### Explanation:\n- `SELECT p.objid, m.g`: We select the object ID and the magnitude `g`.\n- `FROM photoobj AS p`: We start from the `photoobj` table.\n- `JOIN magnitude AS m ON p.objid = m.objid`: We join with the `magnitude` table to access the color band magnitudes.\n- The `WHERE` clause applies the constraints on the magnitudes as specified in the question.\n- `ORDER BY m.g DESC`: Finally, we order the results by the magnitude `g` in descending order.\n\nPlease adjust the table and column names according to your actual database schema if they differ from the assumptions made here.", "fixed": true, "try_times": 2, "pred": "-- SQL Type: SELECT\nSELECT p.objid, p.g\nFROM photoobj AS p\nWHERE p.g < 22\n  AND (p.u - p.g) >= -0.27 AND (p.u - p.g) < 0.71\n  AND (p.g - p.r) >= -0.24 AND (p.g - p.r) < 0.35\n  AND (p.r - p.i) >= -0.27 AND (p.r - p.i) < 0.57\n  AND (p.i - p.z) >= -0.35 AND (p.i - p.z) < 0.7\nORDER BY p.g DESC;"}
{"idx": 223, "db_id": "sdss", "query": "Find object id, right ascension, declination of photometrically observed star whose magnitude i is brighter than 19 and fainter than 0, the difference of magnitude g and magnitude r is higher than 2.26, the difference of magnitude i and magnitude z is lower than 0.25, and either the difference of magnitude u and magnitude g is greater than 2.0 or magnitude u is fainter than 22.3", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "ra", "dec", "i", "g", "r"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": "drop_all", "photo_type": "drop_all"}, "ground_truth": "SELECT p.objid, p.ra, p.dec from photoobj AS p JOIN photo_type AS pt ON p.type = pt.value where pt.name = 'STAR' and i < 19 and i > 0 and g - r > 2.26 and i - z < 0.25 and u - g > 2.0  or  u > 22.3", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "ra", "dec", "g", "r", "i"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "segue2primary", "survey"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT objid, ra, dec \nFROM photoobj \nWHERE \n    i < 19 AND \n    i > 0 AND \n    (g - r) > 2.26 AND \n    (i - z) < 0.25 AND \n    ((u - g) > 2.0 OR u > 22.3);", "qa_pairs": "To answer the question regarding the photometrically observed stars with the specified conditions, we need to assume that the `photoobj` table contains the necessary columns for magnitudes `u`, `g`, `r`, `i`, and `z`. However, since the `photoobj` table schema provided does not include `u` and `z`, we will proceed with the assumption that they are part of the schema for the sake of this SQL query.\n\nHere is the SQL query that meets the specified conditions:\n\n```sql\nSELECT objid, ra, dec \nFROM photoobj \nWHERE \n    i < 19 AND \n    i > 0 AND \n    (g - r) > 2.26 AND \n    (i - z) < 0.25 AND \n    ((u - g) > 2.0 OR u > 22.3);\n```\n\n### Explanation of the SQL Query:\n1. **SELECT objid, ra, dec**: This selects the object ID, right ascension, and declination from the `photoobj` table.\n2. **WHERE**: This clause filters the results based on the following conditions:\n   - `i < 19`: The magnitude `i` must be brighter than 19.\n   - `i > 0`: The magnitude `i` must be fainter than 0.\n   - `(g - r) > 2.26`: The difference between magnitudes `g` and `r` must be greater than 2.26.\n   - `(i - z) < 0.25`: The difference between magnitudes `i` and `z` must be less than 0.25.\n   - `((u - g) > 2.0 OR u > 22.3)`: Either the difference between magnitudes `u` and `g` must be greater than 2.0, or the magnitude `u` must be fainter than 22.3.\n\nThis query will return the desired results based on the conditions specified in the question.", "fixed": false, "try_times": 1, "pred": "SELECT objid, ra, dec \nFROM photoobj \nWHERE \n    i < 19 AND \n    i > 0 AND \n    (g - r) > 2.26 AND \n    (i - z) < 0.25 AND \n    ((u - g) > 2.0 OR u > 22.3);"}
{"idx": 224, "db_id": "sdss", "query": "Show me the photometrically observable star with the color band magnitude i brighter than 19 but fainter than 0, the difference of magnitude g and r is greater than 2.26, the difference of magnitude i and z is less than 0.25, and either the difference of magnitude u and g is greater than 2.0 or the color band magnitude u is fainter than 22.3", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "segue2primary", "survey"], "photo_type": "drop_all"}, "ground_truth": "SELECT p.objid, p.ra, p.dec from photoobj AS p JOIN photo_type AS pt ON p.type = pt.value where pt.name = 'STAR' and i < 19 and i > 0 and g - r > 2.26 and i - z < 0.25 and u - g > 2.0  or  u > 22.3", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "segue2primary", "survey"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.*\nFROM photoobj AS p\nJOIN magnitude AS m ON p.objid = m.objid\nJOIN photo_type AS pt ON p.type = pt.value\nWHERE pt.name = 'STAR'\n  AND m.i < 19\n  AND m.i > 0\n  AND ABS(m.g - m.r) > 2.26\n  AND ABS(m.i - m.z) < 0.25\n  AND (ABS(m.u - m.g) > 2.0 OR m.u > 22.3);", "qa_pairs": "To construct the SQL query based on the provided conditions, we need to assume that there are additional tables or columns that contain the magnitude values for the different color bands (u, g, r, i, z). Since the schema provided does not include these details, I will create a hypothetical table called `magnitude` that holds the necessary magnitude values for each object.\n\n### Hypothetical Table: magnitude\n```\n[\n  (objid, object id.),\n  (u, magnitude in u band.),\n  (g, magnitude in g band.),\n  (r, magnitude in r band.),\n  (i, magnitude in i band.),\n  (z, magnitude in z band.)\n]\n```\n\n### SQL Query\nGiven the conditions specified in the question, the SQL query would look like this:\n\n```sql\nSELECT p.*\nFROM photoobj AS p\nJOIN magnitude AS m ON p.objid = m.objid\nJOIN photo_type AS pt ON p.type = pt.value\nWHERE pt.name = 'STAR'\n  AND m.i < 19\n  AND m.i > 0\n  AND ABS(m.g - m.r) > 2.26\n  AND ABS(m.i - m.z) < 0.25\n  AND (ABS(m.u - m.g) > 2.0 OR m.u > 22.3);\n```\n\n### Explanation of the SQL Query:\n1. **Selecting from `photoobj`**: We select all columns from the `photoobj` table.\n2. **Joining with `magnitude`**: We join the `magnitude` table to access the magnitude values for each object.\n3. **Joining with `photo_type`**: We join the `photo_type` table to filter for objects classified as stars.\n4. **Applying Conditions**:\n   - The magnitude in the i band must be brighter than 19 and fainter than 0.\n   - The absolute difference between the magnitudes in the g and r bands must be greater than 2.26.\n   - The absolute difference between the magnitudes in the i and z bands must be less than 0.25.\n   - Either the absolute difference between the magnitudes in the u and g bands must be greater than 2.0, or the magnitude in the u band must be fainter than 22.3.\n\nThis query will return the photometrically observable stars that meet all the specified criteria.", "fixed": true, "try_times": 2, "pred": "-- SQL Type: SELECT\nSELECT p.objid\nFROM photoobj AS p\nJOIN neighbors AS n ON p.objid = n.objid\nJOIN photo_type AS pt ON p.type = pt.value\nWHERE pt.name = 'STAR'\n  AND p.i < 19\n  AND p.i > 0\n  AND ABS(p.g - p.r) > 2.26\n  AND ABS(p.i - p.z) < 0.25\n  AND (ABS(p.u - p.g) > 2.0 OR p.u > 22.3);"}
{"idx": 225, "db_id": "sdss", "query": "What are the photometrically observable Galaxy whose right ascension is between 140.9 and 141.1, magnitude g is brighter than 18.0 and the difference of magitude u and magnitude g is greater than 2.2. Retrieve the objecti id, right ascension and declination of these objects.", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "ra", "dec", "g", "u", "clean"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": "drop_all", "photo_type": "drop_all"}, "ground_truth": "select objid, ra, dec from photoobj as p join photo_type as pt on p.type = pt.value where pt.name = 'GALAXY' and p.ra between 140.9 and 141.1 and p.g < 18.0 and p.u - p.g > 2.2", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "clean", "ra", "dec", "u", "g"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "segue2primary", "survey"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.objid, p.ra, p.dec\nFROM photoobj AS p\nJOIN photo_type AS pt ON p.type = pt.value\nWHERE pt.name = 'GALAXY' \n  AND p.ra BETWEEN 140.9 AND 141.1\n  AND p.g < 18.0\n  AND (p.u - p.g) > 2.2;", "qa_pairs": "To retrieve the photometrically observable Galaxy objects that meet the specified criteria, we need to filter the `photoobj` table based on the conditions provided. The conditions are:\n\n1. Right ascension (`ra`) is between 140.9 and 141.1.\n2. Magnitude `g` is brighter than 18.0 (which means `g` should be less than 18.0).\n3. The difference between magnitude `u` and magnitude `g` is greater than 2.2 (i.e., `u - g > 2.2`).\n\nAdditionally, we need to ensure that the objects are of type \"Galaxy\". Assuming that the type information is stored in the `photo_type` table and that we can join it with the `photoobj` table, we will filter for the appropriate type.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT p.objid, p.ra, p.dec\nFROM photoobj AS p\nJOIN photo_type AS pt ON p.type = pt.value\nWHERE pt.name = 'GALAXY' \n  AND p.ra BETWEEN 140.9 AND 141.1\n  AND p.g < 18.0\n  AND (p.u - p.g) > 2.2;\n```\n\nIn this query:\n- We select the `objid`, `ra`, and `dec` from the `photoobj` table.\n- We join the `photoobj` table with the `photo_type` table to filter for objects classified as \"GALAXY\".\n- We apply the specified conditions to filter the results accordingly. \n\nMake sure to replace `'GALAXY'` with the actual value that represents galaxies in the `photo_type` table if it differs.", "fixed": false, "try_times": 1, "pred": "SELECT p.objid, p.ra, p.dec\nFROM photoobj AS p\nJOIN photo_type AS pt ON p.type = pt.value\nWHERE pt.name = 'GALAXY' \n  AND p.ra BETWEEN 140.9 AND 141.1\n  AND p.g < 18.0\n  AND (p.u - p.g) > 2.2;"}
{"idx": 226, "db_id": "sdss", "query": "Show me the object id, right ascension and declination of photometrically observed Galaxy, of which the the right ascension in a range of from 140.9 to 141.1, the magnitude g is less than 18.0 and the difference of magnitude u and g is higher than 2.2", "evidence": "", "extracted_schema": {"photoobj": ["objid", "ra", "dec", "g", "u", "clean"], "specobj": ["specobjid", "class", "ra", "dec", "z", "subclass"], "neighbors": "drop_all"}, "ground_truth": "select objid, ra, dec from photoobj as p join photo_type as pt on p.type = pt.value where pt.name = 'GALAXY' and p.ra between 140.9 and 141.1 and p.g < 18.0 and p.u - p.g > 2.2", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "clean", "ra", "dec", "u", "g"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.objid, p.ra, p.dec\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'GALAXY'\n  AND p.ra BETWEEN 140.9 AND 141.1\n  AND p.g < 18.0\n  AND (p.u - p.g) > 2.2", "qa_pairs": "To retrieve the object id, right ascension, and declination of photometrically observed galaxies that meet the specified criteria, you can use the following SQL query:\n\n```sql\nSELECT p.objid, p.ra, p.dec\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'GALAXY'\n  AND p.ra BETWEEN 140.9 AND 141.1\n  AND p.g < 18.0\n  AND (p.u - p.g) > 2.2\n```\n\n### Explanation:\n1. **SELECT Clause**: We are selecting the `objid`, `ra`, and `dec` from the `photoobj` table.\n2. **FROM Clause**: We are using the `photoobj` table and joining it with the `specobj` table to filter for galaxies.\n3. **JOIN Clause**: We join `photoobj` with `specobj` on the condition that `photoobj.objid` matches `specobj.bestobjid`.\n4. **WHERE Clause**: \n   - We filter for objects that are classified as 'GALAXY'.\n   - We check that the right ascension (`ra`) is between 140.9 and 141.1.\n   - We ensure that the magnitude `g` is less than 18.0.\n   - We check that the difference between magnitude `u` and `g` is greater than 2.2.\n\nThis query will return the desired results based on the specified conditions.", "fixed": false, "try_times": 1, "pred": "SELECT p.objid, p.ra, p.dec\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'GALAXY'\n  AND p.ra BETWEEN 140.9 AND 141.1\n  AND p.g < 18.0\n  AND (p.u - p.g) > 2.2"}
{"idx": 227, "db_id": "sdss", "query": "Find the object id, right ascension and declination of spectroscopic Galaxy, which have value of magnitude g between 17 and 18 and redshift less than 0.05. ", "evidence": "", "extracted_schema": {"photoobj": ["objid", "ra", "dec", "g", "type", "clean"], "specobj": ["specobjid", "class", "z", "zerr", "ra", "dec"], "neighbors": "drop_all"}, "ground_truth": "select p.objid, p.ra, p.dec from photoobj as p join specobj as s on s.bestobjid = p.objid where s.class = 'GALAXY' and p.g between 17 and 18 and s.z < 0.05", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "type", "clean", "ra", "dec", "g"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "zerr", "class"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.objid, p.ra, p.dec \nFROM specobj AS s \nJOIN photoobj AS p ON s.bestobjid = p.objid \nWHERE s.class = 'GALAXY' \n  AND p.g BETWEEN 17 AND 18 \n  AND s.z < 0.05;", "qa_pairs": "To find the object id, right ascension, and declination of spectroscopic galaxies that have a magnitude \\( g \\) between 17 and 18 and a redshift less than 0.05, we need to join the relevant tables: `specobj`, `photoobj`, and filter based on the specified conditions.\n\nHere's the SQL query that accomplishes this:\n\n```sql\nSELECT p.objid, p.ra, p.dec \nFROM specobj AS s \nJOIN photoobj AS p ON s.bestobjid = p.objid \nWHERE s.class = 'GALAXY' \n  AND p.g BETWEEN 17 AND 18 \n  AND s.z < 0.05;\n```\n\n### Explanation:\n- We select the `objid`, `ra`, and `dec` from the `photoobj` table.\n- We join the `specobj` table on the condition that the `bestobjid` in `specobj` matches the `objid` in `photoobj`.\n- We filter the results to include only those records where:\n  - The `class` in `specobj` is 'GALAXY'.\n  - The magnitude \\( g \\) in `photoobj` is between 17 and 18.\n  - The redshift \\( z \\) in `specobj` is less than 0.05.", "fixed": false, "try_times": 1, "pred": "SELECT p.objid, p.ra, p.dec \nFROM specobj AS s \nJOIN photoobj AS p ON s.bestobjid = p.objid \nWHERE s.class = 'GALAXY' \n  AND p.g BETWEEN 17 AND 18 \n  AND s.z < 0.05;"}
{"idx": 228, "db_id": "sdss", "query": "Fetch me the object id, right ascension and declination of spectroscopic Galaxy with the color band magnitude g brighter than 18.0 but fainter than 17 and redshift lower than 0.05", "evidence": "", "extracted_schema": {"photoobj": ["objid", "g", "ra", "dec", "type", "clean"], "specobj": ["specobjid", "class", "z", "ra", "dec", "bestobjid"], "neighbors": "drop_all"}, "ground_truth": "select p.objid, p.ra, p.dec from photoobj as p join specobj as s on s.bestobjid = p.objid where s.class = 'GALAXY' and p.g between 17 and 18 and s.z < 0.05", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "type", "clean", "ra", "dec", "g"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT so.objid, so.ra, so.dec\nFROM specobj AS so\nJOIN photoobj AS po ON so.bestobjid = po.objid\nWHERE so.class = 'GALAXY'\n  AND po.g < 18.0\n  AND po.g > 17\n  AND so.z < 0.05;", "qa_pairs": "To fetch the object id, right ascension, and declination of spectroscopic galaxies with the specified conditions (color band magnitude g brighter than 18.0 but fainter than 17, and redshift lower than 0.05), we need to join the relevant tables and apply the necessary filters.\n\nHere’s the SQL query that accomplishes this:\n\n```sql\nSELECT so.objid, so.ra, so.dec\nFROM specobj AS so\nJOIN photoobj AS po ON so.bestobjid = po.objid\nWHERE so.class = 'GALAXY'\n  AND po.g < 18.0\n  AND po.g > 17\n  AND so.z < 0.05;\n```\n\n### Explanation:\n1. **SELECT**: We are selecting the `objid`, `ra`, and `dec` from the `specobj` table.\n2. **FROM specobj AS so**: We are using the `specobj` table and aliasing it as `so`.\n3. **JOIN photoobj AS po ON so.bestobjid = po.objid**: We join the `photoobj` table to get the magnitude `g` values, linking them through the `bestobjid`.\n4. **WHERE**: We filter the results to include only:\n   - Spectroscopic objects classified as 'GALAXY'.\n   - Magnitude `g` values that are less than 18.0 and greater than 17.\n   - Redshift `z` values that are less than 0.05.\n\nThis query will return the desired results based on the specified conditions.", "fixed": true, "try_times": 2, "pred": "SELECT so.specobjid AS objid, so.ra, so.dec\nFROM specobj AS so\nJOIN photoobj AS po ON so.bestobjid = po.objid\nWHERE so.class = 'GALAXY'\n  AND po.g < 18.0\n  AND po.g > 17\n  AND so.z < 0.05;"}
{"idx": 229, "db_id": "sdss", "query": "Search for photometrically observed Star with the difference of magnitude u and magnitude g is less than 0.5. Retrieve each object id, right ascension and declination.", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "ra", "dec", "type", "mode", "clean"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "bestobjid", "ra", "dec", "class", "z"], "photo_type": "drop_all"}, "ground_truth": "select p.objid, p.ra, p.dec from photoobj as p join photo_type as pt on p.type = pt.value where pt.name = 'STAR' and p.u - p.g < 0.5", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "mode", "type", "clean", "ra", "dec"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.objid, p.ra, p.dec \nFROM photoobj AS p \nWHERE p.type = 'STAR' \nAND ABS(p.magnitude_u - p.magnitude_g) < 0.5;", "qa_pairs": "To retrieve the object IDs, right ascension, and declination of photometrically observed stars where the difference in magnitude between the u and g bands is less than 0.5, we need to join the relevant tables and apply the necessary conditions.\n\nAssuming that the magnitude information for the u and g bands is stored in the `photoobj` table (or a related table), we would typically need to filter based on the `type` being 'STAR' and the magnitude difference condition.\n\nHowever, since the schema provided does not explicitly mention where the magnitudes for the u and g bands are stored, I will assume that they are part of the `photoobj` table and that we have columns named `magnitude_u` and `magnitude_g` for this example.\n\nHere is the SQL query that would achieve this:\n\n```sql\nSELECT p.objid, p.ra, p.dec \nFROM photoobj AS p \nWHERE p.type = 'STAR' \nAND ABS(p.magnitude_u - p.magnitude_g) < 0.5;\n```\n\nIn this query:\n- We select the `objid`, `ra`, and `dec` from the `photoobj` table.\n- We filter for rows where the `type` is 'STAR'.\n- We apply the condition that the absolute difference between `magnitude_u` and `magnitude_g` is less than 0.5.\n\nPlease adjust the column names for magnitudes if they are stored in a different table or have different names in your actual schema.", "fixed": true, "try_times": 3, "pred": "-- SQL Type: SELECT\nSELECT DISTINCT p.objid, p.ra, p.dec \nFROM photoobj AS p \nJOIN neighbors AS n ON p.objid = n.objid \nWHERE p.type = 'STAR' \nAND p.clean = 1 \nAND ABS(n.distance) < 0.5;  -- Assuming distance represents the magnitude difference"}
{"idx": 230, "db_id": "sdss", "query": "Show me the object id, right ascension and declination of photometrically observable Star with the constraints: color band u - g < 0.5 ", "evidence": "", "extracted_schema": {"photoobj": ["objid", "ra", "dec", "u", "g", "clean"], "neighbors": "drop_all", "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "class", "subclass", "ra", "dec", "z"], "photo_type": "drop_all"}, "ground_truth": "select p.objid, p.ra, p.dec from photoobj as p join photo_type as pt on p.type = pt.value where pt.name = 'STAR' and p.u - p.g < 0.5", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "clean", "ra", "dec", "u", "g"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.objid, p.ra, p.dec \nFROM photoobj AS p \nJOIN specobj AS s ON p.objid = s.bestobjid \nWHERE s.class = 'STAR' AND (p.u - p.g) < 0.5 AND p.clean = 1;", "qa_pairs": "To retrieve the object id, right ascension, and declination of photometrically observable stars with the constraint that the color band \\( u - g < 0.5 \\), we need to join the `photoobj` table with the `specobj` table to filter for objects of type 'STAR'. \n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT p.objid, p.ra, p.dec \nFROM photoobj AS p \nJOIN specobj AS s ON p.objid = s.bestobjid \nWHERE s.class = 'STAR' AND (p.u - p.g) < 0.5 AND p.clean = 1;\n```\n\n### Explanation:\n- **SELECT p.objid, p.ra, p.dec**: This selects the object id, right ascension, and declination from the `photoobj` table.\n- **FROM photoobj AS p**: This specifies the `photoobj` table as the main table (aliased as `p`).\n- **JOIN specobj AS s ON p.objid = s.bestobjid**: This joins the `specobj` table (aliased as `s`) on the condition that the `objid` from `photoobj` matches the `bestobjid` from `specobj`.\n- **WHERE s.class = 'STAR'**: This filters the results to include only those objects classified as 'STAR'.\n- **AND (p.u - p.g) < 0.5**: This adds the constraint for the color band \\( u - g < 0.5 \\).\n- **AND p.clean = 1**: This ensures that only clean photometry flags are considered.\n\nThis query will return the desired results based on the specified conditions.", "fixed": false, "try_times": 1, "pred": "SELECT p.objid, p.ra, p.dec \nFROM photoobj AS p \nJOIN specobj AS s ON p.objid = s.bestobjid \nWHERE s.class = 'STAR' AND (p.u - p.g) < 0.5 AND p.clean = 1;"}
{"idx": 231, "db_id": "sdss", "query": "Search for photometrically observed Star that has a difference of magnitude u and magnitude g less than 0.5. Retrieve all magnitude values (u, g, r, i and z) of these objects.", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": "keep_all", "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "bestobjid", "class", "subclass", "ra", "dec"], "photo_type": "drop_all"}, "ground_truth": "select p.u, p.g, p.r, p.i, p.z from photoobj as p join photo_type as pt on p.type = pt.value where pt.name = 'STAR' and  p.u - p.g < 0.5", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type", "clean", "flags", "rowc", "colc", "cmodelmag_u", "cmodelmag_g", "cmodelmag_r", "ra", "dec", "b", "l", "extinction_r", "mjd", "loadversion", "u", "g", "r", "i", "z"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT u, g, r, i, z \nFROM photoobj \nWHERE type = (SELECT value FROM photo_type WHERE name = 'STAR') \nAND ABS(u - g) < 0.5;", "qa_pairs": "To retrieve all magnitude values (u, g, r, i, and z) of photometrically observed stars that have a difference of magnitude u and magnitude g less than 0.5, you can use the following SQL query:\n\n```sql\nSELECT u, g, r, i, z \nFROM photoobj \nWHERE type = (SELECT value FROM photo_type WHERE name = 'STAR') \nAND ABS(u - g) < 0.5;\n```\n\n### Explanation:\n1. **SELECT u, g, r, i, z**: This part specifies that we want to retrieve the magnitude values for the objects.\n2. **FROM photoobj**: We are querying the `photoobj` table, which contains the magnitude values.\n3. **WHERE type = (SELECT value FROM photo_type WHERE name = 'STAR')**: This condition filters the results to include only those objects that are classified as stars. It uses a subquery to find the corresponding value for 'STAR' from the `photo_type` table.\n4. **AND ABS(u - g) < 0.5**: This condition ensures that we only include stars where the absolute difference between the magnitudes u and g is less than 0.5.\n\nThis query will return the desired magnitude values for the specified conditions.", "fixed": false, "try_times": 1, "pred": "SELECT u, g, r, i, z \nFROM photoobj \nWHERE type = (SELECT value FROM photo_type WHERE name = 'STAR') \nAND ABS(u - g) < 0.5;"}
{"idx": 232, "db_id": "sdss", "query": "Fetch all color bands (magnitude u, g, r, i, z) of photometrically observable Star where color band u - g < 0.5", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "u", "g", "r", "i", "z"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "class", "subclass", "ra", "dec", "z"], "photo_type": "drop_all"}, "ground_truth": "select p.u, p.g, p.r, p.i, p.z from photoobj as p join photo_type as pt on p.type = pt.value where pt.name = 'STAR' and  p.u - p.g < 0.5", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "u", "g", "r", "i", "z"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.u, p.g, p.r, p.i, p.z \nFROM photoobj AS p \nJOIN specobj AS s ON p.objid = s.bestobjid \nWHERE s.class = 'STAR' AND (p.u - p.g) < 0.5;", "qa_pairs": "To fetch all color bands (magnitude u, g, r, i, z) of photometrically observable stars where the color band u - g < 0.5, we need to join the `photoobj` table with the `specobj` table to filter for objects that are classified as stars. We will then apply the condition on the color band difference.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT p.u, p.g, p.r, p.i, p.z \nFROM photoobj AS p \nJOIN specobj AS s ON p.objid = s.bestobjid \nWHERE s.class = 'STAR' AND (p.u - p.g) < 0.5;\n```\n\n### Explanation:\n- We select the magnitudes `u`, `g`, `r`, `i`, and `z` from the `photoobj` table.\n- We join the `photoobj` table (`p`) with the `specobj` table (`s`) on the condition that the `bestobjid` in `specobj` matches the `objid` in `photoobj`.\n- We filter the results to include only those entries where the `class` in `specobj` is 'STAR'.\n- Finally, we apply the condition that the difference between the magnitudes `u` and `g` is less than 0.5.", "fixed": false, "try_times": 1, "pred": "SELECT p.u, p.g, p.r, p.i, p.z \nFROM photoobj AS p \nJOIN specobj AS s ON p.objid = s.bestobjid \nWHERE s.class = 'STAR' AND (p.u - p.g) < 0.5;"}
{"idx": 233, "db_id": "sdss", "query": "Find the object id, right ascension and declination from spectroscopically observed GALAXY whose value of magnitude g fainter than 17 but brighter than 18, and redshift less than 0.05. ", "evidence": "", "extracted_schema": {"photoobj": ["objid", "ra", "dec", "g", "type", "clean"], "specobj": ["specobjid", "bestobjid", "class", "z", "zerr", "survey"], "neighbors": "drop_all"}, "ground_truth": "select p.objid, p.ra, p.dec from photoobj as p join specobj as s on s.bestobjid = p.objid where s.class = 'GALAXY' and p.g between 17 and 18 and s.z < 0.05", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "type", "clean", "ra", "dec", "g"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "survey", "z", "zerr", "class"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.objid, p.ra, p.dec\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE p.g > 17 AND p.g < 18 AND s.z < 0.05 AND s.class = 'GALAXY';", "qa_pairs": "To find the object id, right ascension, and declination from spectroscopically observed GALAXY whose magnitude \\( g \\) is fainter than 17 but brighter than 18, and redshift is less than 0.05, we need to join the relevant tables: `photoobj`, `specobj`, and filter based on the specified conditions.\n\nHere's the SQL query that accomplishes this:\n\n```sql\nSELECT p.objid, p.ra, p.dec\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE p.g > 17 AND p.g < 18 AND s.z < 0.05 AND s.class = 'GALAXY';\n```\n\n### Explanation:\n- We select the `objid`, `ra`, and `dec` from the `photoobj` table.\n- We join the `photoobj` table with the `specobj` table on the condition that `photoobj.objid` matches `specobj.bestobjid`.\n- We apply the filters:\n  - The magnitude \\( g \\) must be greater than 17 and less than 18.\n  - The redshift \\( z \\) must be less than 0.05.\n  - The class must be 'GALAXY'. \n\nThis query will return the desired results based on the specified conditions.", "fixed": false, "try_times": 1, "pred": "SELECT p.objid, p.ra, p.dec\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE p.g > 17 AND p.g < 18 AND s.z < 0.05 AND s.class = 'GALAXY';"}
{"idx": 234, "db_id": "sdss", "query": "Show me the spectroscopically observable Galaxy with magnitude g between 17 and 18, and redshift below 0.05. Retrieve the object id, right ascension and declination of them.", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "g", "ra", "dec", "run", "field"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "class", "z", "zerr", "ra", "dec"], "photo_type": "drop_all"}, "ground_truth": "select p.objid, p.ra, p.dec from photoobj as p join specobj as s on s.bestobjid = p.objid where s.class = 'GALAXY' and p.g between 17 and 18 and s.z < 0.05", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "field", "ra", "dec", "g"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "zerr", "class"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT so.specobjid, po.ra, po.dec\nFROM specobj AS so\nJOIN photoobj AS po ON so.bestobjid = po.objid\nWHERE so.class = 'GALAXY' \n  AND po.g BETWEEN 17 AND 18 \n  AND so.z < 0.05;", "qa_pairs": "To retrieve the spectroscopically observable galaxies with a magnitude \\( g \\) between 17 and 18 and a redshift below 0.05, we need to join the relevant tables: `specobj`, `photoobj`, and filter based on the specified conditions.\n\nHere’s the SQL query that accomplishes this:\n\n```sql\nSELECT so.specobjid, po.ra, po.dec\nFROM specobj AS so\nJOIN photoobj AS po ON so.bestobjid = po.objid\nWHERE so.class = 'GALAXY' \n  AND po.g BETWEEN 17 AND 18 \n  AND so.z < 0.05;\n```\n\n### Explanation:\n- We select the `specobjid`, `ra`, and `dec` from the `specobj` and `photoobj` tables.\n- We join `specobj` (aliased as `so`) with `photoobj` (aliased as `po`) on the condition that `bestobjid` from `specobj` matches `objid` from `photoobj`.\n- We filter the results to include only those records where:\n  - The `class` is 'GALAXY'.\n  - The magnitude \\( g \\) is between 17 and 18.\n  - The redshift \\( z \\) is below 0.05. \n\nThis query will return the desired object IDs, right ascension, and declination for the specified criteria.", "fixed": false, "try_times": 1, "pred": "SELECT so.specobjid, po.ra, po.dec\nFROM specobj AS so\nJOIN photoobj AS po ON so.bestobjid = po.objid\nWHERE so.class = 'GALAXY' \n  AND po.g BETWEEN 17 AND 18 \n  AND so.z < 0.05;"}
{"idx": 235, "db_id": "sdss", "query": "Find all magnitude values (u, g, r, i and z) from spectroscopically observable GALAXY whose value of magnitude g between 17 and 18,  and redshift less than 0.05. ", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "u", "g", "r", "i", "z"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "class", "z", "zerr", "ra", "dec"], "photo_type": "drop_all"}, "ground_truth": "select p.u, p.g, p.r, p.i, p.z from photoobj as p join specobj as s on s.bestobjid = p.objid where s.class = 'GALAXY' and p.g between 17 and 18 and s.z < 0.05", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "u", "g", "r", "i", "z"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "zerr", "class"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.u, p.g, p.r, p.i, p.z\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'GALAXY' \n  AND p.g BETWEEN 17 AND 18 \n  AND s.z < 0.05;", "qa_pairs": "To find all magnitude values (u, g, r, i, and z) from spectroscopically observable GALAXY with the specified conditions (magnitude g between 17 and 18, and redshift less than 0.05), we need to join the relevant tables and apply the necessary filters.\n\nHere's the SQL query that accomplishes this:\n\n```sql\nSELECT p.u, p.g, p.r, p.i, p.z\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'GALAXY' \n  AND p.g BETWEEN 17 AND 18 \n  AND s.z < 0.05;\n```\n\n### Explanation:\n1. **FROM photoobj AS p**: We start from the `photoobj` table, which contains the magnitude values.\n2. **JOIN specobj AS s ON p.objid = s.bestobjid**: We join the `specobj` table to filter for objects that are classified as GALAXY. The join condition links the `objid` in `photoobj` to the `bestobjid` in `specobj`.\n3. **WHERE s.class = 'GALAXY'**: This condition filters the results to include only those objects classified as GALAXY.\n4. **AND p.g BETWEEN 17 AND 18**: This condition ensures that we only include records where the magnitude `g` is between 17 and 18.\n5. **AND s.z < 0.05**: This condition filters for records where the redshift `z` is less than 0.05.\n\nThis query will return the desired magnitude values for the specified conditions.", "fixed": false, "try_times": 1, "pred": "SELECT p.u, p.g, p.r, p.i, p.z\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'GALAXY' \n  AND p.g BETWEEN 17 AND 18 \n  AND s.z < 0.05;"}
{"idx": 236, "db_id": "sdss", "query": "Fetch all color bands (magnitude u, g, r, i, z) of spectroscopically observable Galaxy with color band g fainter than 17 but brighter than 18 and redshift lower than 0.05", "evidence": "", "extracted_schema": {"photoobj": ["objid", "u", "g", "r", "i", "z"], "specobj": ["specobjid", "class", "z", "zerr", "ra", "dec"], "neighbors": "drop_all"}, "ground_truth": "select p.u, p.g, p.r, p.i, p.z from photoobj as p join specobj as s on s.bestobjid = p.objid where s.class = 'GALAXY' and p.g between 17 and 18 and s.z < 0.05", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "u", "g", "r", "i", "z"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "zerr", "class"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.u, p.g, p.r, p.i, p.z \nFROM specobj AS s \nJOIN photoobj AS p ON s.bestobjid = p.objid \nWHERE s.class = 'GALAXY' \nAND p.g > 17 \nAND p.g < 18 \nAND s.z < 0.05;", "qa_pairs": "To fetch all color bands (magnitude u, g, r, i, z) of spectroscopically observable galaxies with the specified conditions, we need to join the relevant tables and apply the necessary filters. The relevant tables are `specobj`, `photoobj`, and possibly others to ensure we are only selecting galaxies.\n\nHere’s the SQL query that meets the requirements:\n\n```sql\nSELECT p.u, p.g, p.r, p.i, p.z \nFROM specobj AS s \nJOIN photoobj AS p ON s.bestobjid = p.objid \nWHERE s.class = 'GALAXY' \nAND p.g > 17 \nAND p.g < 18 \nAND s.z < 0.05;\n```\n\n### Explanation:\n1. **SELECT p.u, p.g, p.r, p.i, p.z**: This selects the color bands (magnitudes) from the `photoobj` table.\n2. **FROM specobj AS s**: We start from the `specobj` table, which contains the spectroscopic objects.\n3. **JOIN photoobj AS p ON s.bestobjid = p.objid**: We join the `photoobj` table to get the corresponding magnitudes for each spectroscopic object, using the `bestobjid` from `specobj` to match with `objid` in `photoobj`.\n4. **WHERE s.class = 'GALAXY'**: This condition filters the results to include only galaxies.\n5. **AND p.g > 17 AND p.g < 18**: These conditions ensure that the g-band magnitude is fainter than 17 but brighter than 18.\n6. **AND s.z < 0.05**: This condition filters for galaxies with a redshift lower than 0.05.\n\nThis query will return the desired color bands for the specified conditions.", "fixed": false, "try_times": 1, "pred": "SELECT p.u, p.g, p.r, p.i, p.z \nFROM specobj AS s \nJOIN photoobj AS p ON s.bestobjid = p.objid \nWHERE s.class = 'GALAXY' \nAND p.g > 17 \nAND p.g < 18 \nAND s.z < 0.05;"}
{"idx": 237, "db_id": "sdss", "query": "Find the photometric objects with object ids, nearst neighbor ids, distance of center-neighbors, center types.", "evidence": "", "extracted_schema": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "galspecline": "drop_all"}, "ground_truth": "select p.objid, n.neighborobjid, n.distance, n.type from neighbors as n join  photoobj as p on n.objid = p.objid", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "segue2primary", "survey", "programname", "mjd", "plate", "fiberid", "special_target1", "segue2_target1", "segue2_target2", "ancillary_target1", "ra", "dec", "z", "zerr", "zwarning", "class", "subclass", "veldisp", "veldisperr", "loadversion"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT \n    p.objid AS Object_ID, \n    n.neighborobjid AS Nearest_Neighbor_ID, \n    n.distance AS Distance_to_Neighbor, \n    p.type AS Center_Type\nFROM \n    photoobj AS p\nJOIN \n    neighbors AS n ON p.objid = n.objid;", "qa_pairs": "To find the photometric objects along with their object IDs, nearest neighbor IDs, distances to the neighbors, and the types of the objects, you can use the following SQL query. This query joins the `photoobj` and `neighbors` tables based on the object IDs and retrieves the required fields.\n\n```sql\nSELECT \n    p.objid AS Object_ID, \n    n.neighborobjid AS Nearest_Neighbor_ID, \n    n.distance AS Distance_to_Neighbor, \n    p.type AS Center_Type\nFROM \n    photoobj AS p\nJOIN \n    neighbors AS n ON p.objid = n.objid;\n```\n\n### Explanation:\n- `SELECT` clause specifies the columns to retrieve:\n  - `p.objid` gives the object ID from the `photoobj` table.\n  - `n.neighborobjid` gives the nearest neighbor ID from the `neighbors` table.\n  - `n.distance` gives the distance to the neighbor.\n  - `p.type` gives the type of the photometric object.\n  \n- `FROM` clause specifies the main table (`photoobj`).\n\n- `JOIN` clause connects the `photoobj` table with the `neighbors` table on the common `objid` field, allowing us to access related data from both tables. \n\nThis query will return a list of photometric objects along with their nearest neighbors and the relevant distances and types.", "fixed": false, "try_times": 1, "pred": "SELECT \n    p.objid AS Object_ID, \n    n.neighborobjid AS Nearest_Neighbor_ID, \n    n.distance AS Distance_to_Neighbor, \n    p.type AS Center_Type\nFROM \n    photoobj AS p\nJOIN \n    neighbors AS n ON p.objid = n.objid;"}
{"idx": 238, "db_id": "sdss", "query": "Fetch me the object id, nearst neighbor ids, distance of center to neighbors and center type from all of the nearst neighbors", "evidence": "", "extracted_schema": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "specobj": "drop_all"}, "ground_truth": "select p.objid, n.neighborobjid, n.distance, n.type from neighbors as n join  photoobj as p on n.objid = p.objid", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "segue2primary", "survey"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT \n    n.objid AS Object_ID, \n    n.neighborobjid AS Nearest_Neighbor_ID, \n    n.distance AS Distance_To_Neighbor, \n    n.type AS Center_Type \nFROM \n    neighbors AS n", "qa_pairs": "To fetch the object id, nearest neighbor ids, distance of center to neighbors, and center type from all of the nearest neighbors, you can use the following SQL query:\n\n```sql\nSELECT \n    n.objid AS Object_ID, \n    n.neighborobjid AS Nearest_Neighbor_ID, \n    n.distance AS Distance_To_Neighbor, \n    n.type AS Center_Type \nFROM \n    neighbors AS n\n```\n\nThis query selects the required fields from the `neighbors` table, which contains the relationships between objects and their nearest neighbors, along with the distance and type information.", "fixed": false, "try_times": 1, "pred": "SELECT \n    n.objid AS Object_ID, \n    n.neighborobjid AS Nearest_Neighbor_ID, \n    n.distance AS Distance_To_Neighbor, \n    n.type AS Center_Type \nFROM \n    neighbors AS n"}
{"idx": 239, "db_id": "sdss", "query": "Find the different object type classifications of photometric objects whose right ascension is greater than 100 and declination is less than 100.", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "type", "ra", "dec", "mode", "clean"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "class", "subclass", "ra", "dec", "z"], "photo_type": "drop_all"}, "ground_truth": "select distinct p.type from photoobj as p where p.ra > 100 and p.dec < 100", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "mode", "type", "clean", "ra", "dec"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT DISTINCT type FROM photoobj WHERE ra > 100 AND dec < 100", "qa_pairs": "```sql\nSELECT DISTINCT type FROM photoobj WHERE ra > 100 AND dec < 100\n```", "fixed": false, "try_times": 1, "pred": "SELECT DISTINCT type FROM photoobj WHERE ra > 100 AND dec < 100"}
{"idx": 240, "db_id": "sdss", "query": "What is the unique object type classifications of photometrically observed objects with right ascension higher than 100 and declination lower than 100", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "type", "mode", "clean", "flags", "run"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "class", "subclass", "ra", "dec", "z"], "photo_type": "drop_all"}, "ground_truth": "select distinct p.type from photoobj as p where p.ra > 100 and p.dec < 100", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "mode", "type", "clean", "flags"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT DISTINCT po.type \nFROM photoobj AS po \nJOIN specobj AS so ON po.objid = so.bestobjid \nWHERE so.ra > 100 AND so.dec < 100;", "qa_pairs": "To retrieve the unique object type classifications of photometrically observed objects with right ascension (ra) higher than 100 and declination (dec) lower than 100, we need to join the `photoobj` table with the `specobj` table based on the `objid` and `specobjid`. Then we can filter the results based on the specified conditions and select the unique classifications.\n\nHere is the SQL query to achieve that:\n\n```sql\nSELECT DISTINCT po.type \nFROM photoobj AS po \nJOIN specobj AS so ON po.objid = so.bestobjid \nWHERE so.ra > 100 AND so.dec < 100;\n```\n\n### Explanation:\n- `SELECT DISTINCT po.type`: This selects unique object type classifications from the `photoobj` table.\n- `FROM photoobj AS po`: This specifies the `photoobj` table and gives it an alias `po`.\n- `JOIN specobj AS so ON po.objid = so.bestobjid`: This joins the `photoobj` table with the `specobj` table where the `objid` in `photoobj` matches the `bestobjid` in `specobj`.\n- `WHERE so.ra > 100 AND so.dec < 100`: This filters the results to include only those records where the right ascension is greater than 100 and the declination is less than 100. \n\nThis query will return the unique classifications of photometrically observed objects that meet the specified criteria.", "fixed": false, "try_times": 1, "pred": "SELECT DISTINCT po.type \nFROM photoobj AS po \nJOIN specobj AS so ON po.objid = so.bestobjid \nWHERE so.ra > 100 AND so.dec < 100;"}
{"idx": 241, "db_id": "sdss", "query": "Find the number of photometrically observed STAR", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "type", "mode", "clean", "flags", "run"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "class", "subclass", "bestobjid", "survey", "programname"], "photo_type": ["value", "name", "description"]}, "ground_truth": "select count(*) from photoobj as p join photo_type as pt on p.type = pt.value where pt.name = 'STAR'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "mode", "type", "clean", "flags"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "survey", "programname", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT COUNT(*) \nFROM photoobj AS p \nJOIN photo_type AS pt ON p.type = pt.value \nWHERE pt.name = 'STAR';", "qa_pairs": "To find the number of photometrically observed objects classified as \"STAR,\" we need to query the `photoobj` table and filter for objects where the `type` is associated with \"STAR.\" We can achieve this by joining the `photoobj` table with the `photo_type` table to get the corresponding names for the types.\n\nHere is the SQL query to accomplish this:\n\n```sql\nSELECT COUNT(*) \nFROM photoobj AS p \nJOIN photo_type AS pt ON p.type = pt.value \nWHERE pt.name = 'STAR';\n```\n\nThis query counts the number of entries in the `photoobj` table where the type corresponds to \"STAR\" in the `photo_type` table.", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(*) \nFROM photoobj AS p \nJOIN photo_type AS pt ON p.type = pt.value \nWHERE pt.name = 'STAR';"}
{"idx": 242, "db_id": "sdss", "query": "Count the photometrically observable STAR", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "type", "mode", "clean", "flags", "run"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "class", "subclass", "bestobjid", "survey", "programname"], "photo_type": "drop_all"}, "ground_truth": "select count(*) from photoobj as p join photo_type as pt on p.type = pt.value where pt.name = 'STAR'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "mode", "type", "clean", "flags"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "survey", "programname", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT COUNT(*) \nFROM photoobj \nJOIN photo_type ON photoobj.type = photo_type.value \nWHERE photo_type.name = 'STAR';", "qa_pairs": "To count the photometrically observable objects classified as \"STAR\" in the database, we need to join the `photoobj` table with the `photo_type` table to filter for objects of type \"STAR\". We can then count the number of such objects.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT COUNT(*) \nFROM photoobj \nJOIN photo_type ON photoobj.type = photo_type.value \nWHERE photo_type.name = 'STAR';\n```\n\nThis query counts all entries in the `photoobj` table that are classified as \"STAR\" in the `photo_type` table.", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(*) \nFROM photoobj \nJOIN photo_type ON photoobj.type = photo_type.value \nWHERE photo_type.name = 'STAR';"}
{"idx": 243, "db_id": "sdss", "query": "Find all photometrically observed object types. Return only unique records.", "evidence": "", "extracted_schema": {"neighbors": ["type", "neighbortype", "distance", "mode", "neighbormode", "neighborobjid"], "photoobj": ["type", "mode", "clean", "flags", "run", "rerun"], "photo_type": ["value", "name", "description"]}, "ground_truth": "select distinct pt.name from photo_type as pt join photoobj as p on p.type = pt.value", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode", "neighbormode"], "photoobj": ["objid", "run", "rerun", "mode", "type", "clean", "flags"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "segue2primary", "survey", "programname", "mjd", "plate", "fiberid", "special_target1", "segue2_target1", "segue2_target2", "ancillary_target1", "ra", "dec", "z", "zerr", "zwarning", "class", "subclass", "veldisp", "veldisperr", "loadversion"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT DISTINCT type FROM photoobj\nUNION\nSELECT DISTINCT neighbortype FROM neighbors;", "qa_pairs": "To find all unique photometrically observed object types from the `photoobj` and `neighbors` tables, you can use the following SQL query:\n\n```sql\nSELECT DISTINCT type FROM photoobj\nUNION\nSELECT DISTINCT neighbortype FROM neighbors;\n```\n\nThis query retrieves unique values from both the `type` column in the `photoobj` table and the `neighbortype` column in the `neighbors` table, combining the results with the `UNION` operator to ensure that only distinct records are returned.", "fixed": false, "try_times": 1, "pred": "SELECT DISTINCT type FROM photoobj\nUNION\nSELECT DISTINCT neighbortype FROM neighbors;"}
{"idx": 244, "db_id": "sdss", "query": "Show me the all different photometrical observation types among all photometric objects.", "evidence": "", "extracted_schema": {"neighbors": ["type", "neighbortype", "distance", "mode", "neighbormode", "neighborobjid"], "photoobj": ["type", "mode", "clean", "flags", "run", "rerun"], "photo_type": ["value", "name", "description"]}, "ground_truth": "select distinct pt.name from photo_type as pt join photoobj as p on p.type = pt.value", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode", "neighbormode"], "photoobj": ["objid", "run", "rerun", "mode", "type", "clean", "flags"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "segue2primary", "survey", "programname", "mjd", "plate", "fiberid", "special_target1", "segue2_target1", "segue2_target2", "ancillary_target1", "ra", "dec", "z", "zerr", "zwarning", "class", "subclass", "veldisp", "veldisperr", "loadversion"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT DISTINCT mode FROM photoobj;", "qa_pairs": "To retrieve all different photometric observation types among all photometric objects, you can query the `photoobj` table, which contains a column for the mode of photometric observation. You can use the `DISTINCT` keyword to ensure that only unique types are returned.\n\nHere is the corresponding SQL query:\n\n```sql\nSELECT DISTINCT mode FROM photoobj;\n```\n\nThis query will return a list of all unique photometric observation types present in the `photoobj` table.", "fixed": false, "try_times": 1, "pred": "SELECT DISTINCT mode FROM photoobj;"}
{"idx": 245, "db_id": "sdss", "query": "Find everything about photometrically observable Galaxy.", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": "keep_all", "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "bestobjid", "class", "subclass", "ra", "dec"], "photo_type": "drop_all"}, "ground_truth": "select * from photoobj as p join photo_type as pt on p.type = pt.value where pt.name = 'GALAXY'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type", "clean", "flags", "rowc", "colc", "cmodelmag_u", "cmodelmag_g", "cmodelmag_r", "ra", "dec", "b", "l", "extinction_r", "mjd", "loadversion", "u", "g", "r", "i", "z"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT *\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'GALAXY';", "qa_pairs": "To find everything about photometrically observable galaxies, we need to join the relevant tables based on the relationships defined in the schema. Specifically, we will join the `photoobj` table with the `specobj` table to filter for objects classified as 'GALAXY'. \n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT *\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'GALAXY';\n```\n\nThis query selects all columns from the `photoobj` table (aliased as `p`) and joins it with the `specobj` table (aliased as `s`) on the condition that the `objid` in `photoobj` matches the `bestobjid` in `specobj`. The `WHERE` clause filters the results to include only those entries where the `class` is 'GALAXY'.", "fixed": false, "try_times": 1, "pred": "SELECT *\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'GALAXY';"}
{"idx": 246, "db_id": "sdss", "query": "Fetch me all about photometrically observed Galaxy", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": "keep_all", "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "bestobjid", "class", "subclass", "ra", "dec"], "photo_type": "drop_all"}, "ground_truth": "select * from photoobj as p join photo_type as pt on p.type = pt.value where pt.name = 'GALAXY'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type", "clean", "flags", "rowc", "colc", "cmodelmag_u", "cmodelmag_g", "cmodelmag_r", "ra", "dec", "b", "l", "extinction_r", "mjd", "loadversion", "u", "g", "r", "i", "z"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT *\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'GALAXY';", "qa_pairs": "To fetch all information about photometrically observed galaxies, we need to join the relevant tables based on the relationships defined in the schema. Specifically, we will join the `photoobj` and `specobj` tables to filter for objects classified as galaxies.\n\nHere is the SQL query to achieve that:\n\n```sql\nSELECT *\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'GALAXY';\n```\n\n### Explanation:\n- We select all columns (`*`) from the `photoobj` table (aliased as `p`).\n- We join the `specobj` table (aliased as `s`) on the condition that the `objid` from `photoobj` matches the `bestobjid` from `specobj`.\n- We filter the results to include only those records where the `class` in the `specobj` table is 'GALAXY'. \n\nThis query will return all the details of photometrically observed galaxies from the database.", "fixed": false, "try_times": 1, "pred": "SELECT *\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'GALAXY';"}
{"idx": 247, "db_id": "sdss", "query": "Find the object ids, right ascensions, declinations and observed types of photometrically observed Star.", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "ra", "dec", "type", "mode", "clean"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "bestobjid", "class", "ra", "dec", "z"], "photo_type": "drop_all"}, "ground_truth": "select p.objid, p.ra, p.dec, pt.name from photoobj as p join photo_type as pt on p.type = pt.value where pt.name = 'STAR'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "mode", "type", "clean", "ra", "dec"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT \n    p.objid, \n    p.ra, \n    p.dec, \n    pt.name AS observed_type \nFROM \n    photoobj AS p \nJOIN \n    photo_type AS pt ON p.type = pt.value \nWHERE \n    pt.name = 'STAR';", "qa_pairs": "To find the object ids, right ascensions, declinations, and observed types of photometrically observed Stars, we need to join the `photoobj` table with the `photo_type` table to filter for objects classified as 'STAR'. \n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT \n    p.objid, \n    p.ra, \n    p.dec, \n    pt.name AS observed_type \nFROM \n    photoobj AS p \nJOIN \n    photo_type AS pt ON p.type = pt.value \nWHERE \n    pt.name = 'STAR';\n```\n\nThis query selects the `objid`, `ra`, and `dec` from the `photoobj` table and the `name` from the `photo_type` table where the type is classified as 'STAR'.", "fixed": false, "try_times": 1, "pred": "SELECT \n    p.objid, \n    p.ra, \n    p.dec, \n    pt.name AS observed_type \nFROM \n    photoobj AS p \nJOIN \n    photo_type AS pt ON p.type = pt.value \nWHERE \n    pt.name = 'STAR';"}
{"idx": 248, "db_id": "sdss", "query": "What is the photometrically observable Star? Retrieve their right ascension, declinations and observed type as well.", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": "keep_all", "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "bestobjid", "class", "ra", "dec", "type"], "photo_type": "drop_all"}, "ground_truth": "select p.objid, p.ra, p.dec, pt.name from photoobj as p join photo_type as pt on p.type = pt.value where pt.name = 'STAR'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type", "clean", "flags", "rowc", "colc", "cmodelmag_u", "cmodelmag_g", "cmodelmag_r", "ra", "dec", "b", "l", "extinction_r", "mjd", "loadversion", "u", "g", "r", "i", "z"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "class", "plateid"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT \n    p.ra, \n    p.dec, \n    pt.name AS observed_type \nFROM \n    photoobj AS p \nJOIN \n    specobj AS s ON p.objid = s.bestobjid \nJOIN \n    photo_type AS pt ON p.type = pt.value \nWHERE \n    s.class = 'STAR';", "qa_pairs": "To retrieve the right ascension, declinations, and observed type of photometrically observable stars, we need to join the `photoobj` table with the `specobj` table to filter for objects classified as 'STAR'. We will also join with the `photo_type` table to get the observed type. \n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT \n    p.ra, \n    p.dec, \n    pt.name AS observed_type \nFROM \n    photoobj AS p \nJOIN \n    specobj AS s ON p.objid = s.bestobjid \nJOIN \n    photo_type AS pt ON p.type = pt.value \nWHERE \n    s.class = 'STAR';\n```\n\n### Explanation:\n- We select the right ascension (`ra`), declination (`dec`), and the name of the observed type from the `photoobj` and `photo_type` tables.\n- We join `photoobj` (`p`) with `specobj` (`s`) on the condition that the `bestobjid` in `specobj` matches the `objid` in `photoobj`.\n- We also join `photoobj` with `photo_type` (`pt`) to get the name of the observed type based on the `type` value.\n- Finally, we filter the results to include only those entries where the `class` in `specobj` is 'STAR'.", "fixed": false, "try_times": 1, "pred": "SELECT \n    p.ra, \n    p.dec, \n    pt.name AS observed_type \nFROM \n    photoobj AS p \nJOIN \n    specobj AS s ON p.objid = s.bestobjid \nJOIN \n    photo_type AS pt ON p.type = pt.value \nWHERE \n    s.class = 'STAR';"}
{"idx": 249, "db_id": "sdss", "query": "Find the photometric objects with object ids, spectroscopic object id whose spectroscopic class is 'GALAXY', with the difference of magnitude u and magnitude r greater trhan 2.22 and the difference of magnitude g and magnitude i greater than 1.", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "bestobjid", "class", "ra", "dec", "z"], "photo_type": "drop_all"}, "ground_truth": "select p.objid, s.specobjid from photoobj as p join specobj as s on s.bestobjid = p.objid where s.class = 'GALAXY' and p.u - p.r > 2.22 and p.g - p.i > 1", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.objid, s.specobjid\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'GALAXY'\nAND (p.u - p.r) > 2.22\nAND (p.g - p.i) > 1;", "qa_pairs": "To find the photometric objects with the specified criteria, we need to join the relevant tables and apply the necessary conditions. The tables involved are `photoobj`, `specobj`, and potentially others if we need to access magnitude information. However, the schema provided does not include magnitude information directly, so we will assume that the necessary magnitude data is available in the `photoobj` table or can be derived from it.\n\nHere’s the SQL query that meets the requirements:\n\n```sql\nSELECT p.objid, s.specobjid\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'GALAXY'\nAND (p.u - p.r) > 2.22\nAND (p.g - p.i) > 1;\n```\n\n### Explanation:\n1. **SELECT p.objid, s.specobjid**: We are selecting the object ID from the `photoobj` table and the spectroscopic object ID from the `specobj` table.\n2. **FROM photoobj AS p**: We start from the `photoobj` table and alias it as `p`.\n3. **JOIN specobj AS s ON p.objid = s.bestobjid**: We join the `specobj` table on the condition that the `objid` from `photoobj` matches the `bestobjid` in `specobj`.\n4. **WHERE s.class = 'GALAXY'**: We filter the results to include only those records where the spectroscopic class is 'GALAXY'.\n5. **AND (p.u - p.r) > 2.22**: We apply the condition that the difference between magnitude `u` and magnitude `r` must be greater than 2.22.\n6. **AND (p.g - p.i) > 1**: We apply the condition that the difference between magnitude `g` and magnitude `i` must be greater than 1.\n\nMake sure to replace `p.u`, `p.r`, `p.g`, and `p.i` with the actual column names for the magnitudes if they are stored differently in the `photoobj` table.", "fixed": false, "try_times": 1, "pred": "SELECT p.objid, s.specobjid\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'GALAXY'\nAND (p.u - p.r) > 2.22\nAND (p.g - p.i) > 1;"}
{"idx": 250, "db_id": "sdss", "query": "What is the photometric objct id and corresponding spectroscopic object id of the spectroscopically observable Galaxy with the constraints in color bands, where u - r > 2.22 and g - i > 1", "evidence": "", "extracted_schema": {"photoobj": ["objid", "type", "mode", "run", "rerun", "field"], "specobj": ["specobjid", "bestobjid", "class", "ra", "dec", "z"], "neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"]}, "ground_truth": "select p.objid, s.specobjid from photoobj as p join specobj as s on s.bestobjid = p.objid where s.class = 'GALAXY' and p.u - p.r > 2.22 and p.g - p.i > 1", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.objid AS photometric_obj_id, s.specobjid AS spectroscopic_obj_id\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'GALAXY' \nAND (u - r > 2.22) \nAND (g - i > 1);", "qa_pairs": "To answer the question regarding the photometric object ID and corresponding spectroscopic object ID of the spectroscopically observable Galaxy with the specified constraints in color bands (u - r > 2.22 and g - i > 1), we need to assume that the necessary color band data is available in the database schema. However, since the provided schema does not include any tables or fields that directly relate to color bands (u, g, r, i), we will need to make some assumptions.\n\nAssuming that there is a way to derive or access the color band information from the existing tables (for example, through additional columns in the `specobj` table or through a related table), we can construct a SQL query. However, since the schema does not provide this information, we will focus on the existing tables.\n\nHere’s a SQL query that would typically be used if the color band information were available:\n\n```sql\nSELECT p.objid AS photometric_obj_id, s.specobjid AS spectroscopic_obj_id\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'GALAXY' \nAND (u - r > 2.22) \nAND (g - i > 1);\n```\n\nIn this query:\n- We select the `objid` from the `photoobj` table as the photometric object ID and the `specobjid` from the `specobj` table as the corresponding spectroscopic object ID.\n- We join the `photoobj` and `specobj` tables on the condition that the `bestobjid` in `specobj` matches the `objid` in `photoobj`.\n- We filter the results to include only those records where the class is 'GALAXY' and the specified color band conditions are met.\n\nSince the actual color band data is not present in the schema provided, please ensure that the necessary data is available in your database to execute this query successfully. If the color band data is stored in a different table, you would need to join that table accordingly.", "fixed": false, "try_times": 1, "pred": "SELECT p.objid AS photometric_obj_id, s.specobjid AS spectroscopic_obj_id\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'GALAXY' \nAND (u - r > 2.22) \nAND (g - i > 1);"}
{"idx": 251, "db_id": "sdss", "query": "Show me the photometric object id and modified julien date for all 'K' type Star", "evidence": "", "extracted_schema": {"photoobj": ["objid", "mjd", "run", "rerun", "field", "mode"], "specobj": ["specobjid", "class", "subclass", "bestobjid", "mjd", "plateid"], "neighbors": "drop_all"}, "ground_truth": "SELECT T2.objid, T1.mjd FROM specobj AS T1 JOIN photoobj as T2 ON T1.bestobjid = T2.objid WHERE T1.class = 'STAR' and T1.subclass like '%K%'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "mjd"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "mjd", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.objid, p.mjd \nFROM photoobj AS p \nJOIN specobj AS s ON p.objid = s.bestobjid \nWHERE s.class = 'STAR' AND s.subclass LIKE 'K%'", "qa_pairs": "To retrieve the photometric object ID and modified Julian date for all 'K' type stars, we need to join the relevant tables based on the foreign key relationships and filter for the specific class of stars. \n\nHere's the SQL query that accomplishes this:\n\n```sql\nSELECT p.objid, p.mjd \nFROM photoobj AS p \nJOIN specobj AS s ON p.objid = s.bestobjid \nWHERE s.class = 'STAR' AND s.subclass LIKE 'K%'\n```\n\n### Explanation:\n1. **SELECT p.objid, p.mjd**: We are selecting the `objid` (photometric object ID) and `mjd` (modified Julian date) from the `photoobj` table.\n2. **FROM photoobj AS p**: We are using the `photoobj` table and aliasing it as `p`.\n3. **JOIN specobj AS s ON p.objid = s.bestobjid**: We join the `specobj` table (aliased as `s`) on the condition that the `objid` in `photoobj` matches the `bestobjid` in `specobj`.\n4. **WHERE s.class = 'STAR' AND s.subclass LIKE 'K%'**: We filter the results to include only those entries where the `class` is 'STAR' and the `subclass` starts with 'K', indicating 'K' type stars.\n\nThis query will return the desired information for all 'K' type stars in the database.", "fixed": false, "try_times": 1, "pred": "SELECT p.objid, p.mjd \nFROM photoobj AS p \nJOIN specobj AS s ON p.objid = s.bestobjid \nWHERE s.class = 'STAR' AND s.subclass LIKE 'K%'"}
{"idx": 252, "db_id": "sdss", "query": "What is the photometric object id and modified julien date of spectroscopic Star with spectral type 'K'", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "mjd", "run", "rerun", "field", "type"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "class", "subclass", "ra", "dec", "z"], "photo_type": "drop_all"}, "ground_truth": "SELECT T2.objid, T1.mjd FROM specobj AS T1 JOIN photoobj as T2 ON T1.bestobjid = T2.objid WHERE T1.class = 'STAR' and T1.subclass like '%K%'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "type", "mjd"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.objid, p.mjd\nFROM specobj AS s\nJOIN photoobj AS p ON s.bestobjid = p.objid\nWHERE s.class = 'STAR' AND s.subclass = 'K';", "qa_pairs": "To retrieve the photometric object id and modified Julian date of spectroscopic objects classified as 'STAR' with a spectral type of 'K', we need to join the relevant tables based on their relationships. The `specobj` table contains the classification and subclass of the objects, while the `photoobj` table contains the photometric object id and modified Julian date.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT p.objid, p.mjd\nFROM specobj AS s\nJOIN photoobj AS p ON s.bestobjid = p.objid\nWHERE s.class = 'STAR' AND s.subclass = 'K';\n```\n\n### Explanation:\n- We select the `objid` and `mjd` from the `photoobj` table.\n- We join the `specobj` table with the `photoobj` table on the condition that `bestobjid` from `specobj` matches `objid` from `photoobj`.\n- We filter the results to include only those records where the `class` is 'STAR' and the `subclass` is 'K'. \n\nThis query will return the desired photometric object id and modified Julian date for the specified conditions.", "fixed": true, "try_times": 2, "pred": "SELECT p.objid, p.mjd\nFROM specobj AS s\nJOIN photoobj AS p ON s.bestobjid = p.objid\nWHERE s.class = 'STAR' AND s.subclass IS NOT NULL;"}
{"idx": 253, "db_id": "sdss", "query": "Find redshift, right ascension and declination of all photometrically observed Starforming Galaxy", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": "keep_all", "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "class", "subclass", "ra", "dec", "z"], "photo_type": "drop_all"}, "ground_truth": "SELECT T1.z, T1.ra, T1.dec FROM specobj AS T1 JOIN photoobj AS T2 ON T1.bestobjid = T2.objid JOIN photo_type AS T3 ON T2.type = T3.value WHERE T1.subclass = 'STARFORMING' AND T3.name = 'GALAXY'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type", "clean", "flags", "rowc", "colc", "cmodelmag_u", "cmodelmag_g", "cmodelmag_r", "ra", "dec", "b", "l", "extinction_r", "mjd", "loadversion", "u", "g", "r", "i", "z"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT specobj.z AS redshift, photoobj.ra AS right_ascension, photoobj.dec AS declination\nFROM photoobj\nJOIN specobj ON photoobj.objid = specobj.bestobjid\nWHERE specobj.subclass = 'STARFORMING';", "qa_pairs": "To find the redshift, right ascension, and declination of all photometrically observed Starforming Galaxies, we need to join the relevant tables based on their relationships. Specifically, we will join the `photoobj` table with the `specobj` table to filter for objects that are classified as \"Starforming\" in the `subclass` column.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT specobj.z AS redshift, photoobj.ra AS right_ascension, photoobj.dec AS declination\nFROM photoobj\nJOIN specobj ON photoobj.objid = specobj.bestobjid\nWHERE specobj.subclass = 'STARFORMING';\n```\n\n### Explanation:\n- We select the `z` (redshift) from the `specobj` table, and the `ra` (right ascension) and `dec` (declination) from the `photoobj` table.\n- We join the `photoobj` table with the `specobj` table using the `bestobjid` foreign key relationship.\n- We filter the results to include only those entries where the `subclass` in the `specobj` table is 'STARFORMING'. \n\nThis query will return the desired information for all photometrically observed Starforming Galaxies.", "fixed": false, "try_times": 1, "pred": "SELECT specobj.z AS redshift, photoobj.ra AS right_ascension, photoobj.dec AS declination\nFROM photoobj\nJOIN specobj ON photoobj.objid = specobj.bestobjid\nWHERE specobj.subclass = 'STARFORMING';"}
{"idx": 254, "db_id": "sdss", "query": "What is the redshift of STARFORMING GALAXY, which can be observed photometrically? Retrieve their right ascension and declination as well.", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": "keep_all", "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "ra", "dec", "z", "class", "subclass"], "photo_type": "drop_all"}, "ground_truth": "SELECT T1.z, T1.ra, T1.dec FROM specobj AS T1 JOIN photoobj AS T2 ON T1.bestobjid = T2.objid JOIN photo_type AS T3 ON T2.type = T3.value WHERE T1.subclass = 'STARFORMING' AND T3.name = 'GALAXY'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type", "clean", "flags", "rowc", "colc", "cmodelmag_u", "cmodelmag_g", "cmodelmag_r", "ra", "dec", "b", "l", "extinction_r", "mjd", "loadversion", "u", "g", "r", "i", "z"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT \n    s.z AS redshift, \n    p.ra AS right_ascension, \n    p.dec AS declination \nFROM \n    specobj AS s \nJOIN \n    photoobj AS p ON s.bestobjid = p.objid \nWHERE \n    s.class = 'GALAXY' \n    AND s.subclass = 'STARFORMING';", "qa_pairs": "To retrieve the redshift of STARFORMING GALAXY objects that can be observed photometrically, along with their right ascension and declination, we need to join the relevant tables based on the foreign key relationships. Specifically, we will join the `specobj`, `photoobj`, and `neighbors` tables to filter for the desired conditions.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT \n    s.z AS redshift, \n    p.ra AS right_ascension, \n    p.dec AS declination \nFROM \n    specobj AS s \nJOIN \n    photoobj AS p ON s.bestobjid = p.objid \nWHERE \n    s.class = 'GALAXY' \n    AND s.subclass = 'STARFORMING';\n```\n\n### Explanation:\n- We select the `redshift` from the `specobj` table and the `right ascension` and `declination` from the `photoobj` table.\n- We join the `specobj` table with the `photoobj` table using the `bestobjid` from `specobj` which corresponds to the `objid` in `photoobj`.\n- We filter the results to include only those records where the `class` is 'GALAXY' and the `subclass` is 'STARFORMING'. \n\nThis query will return the required information about STARFORMING GALAXY objects that can be observed photometrically.", "fixed": false, "try_times": 1, "pred": "SELECT \n    s.z AS redshift, \n    p.ra AS right_ascension, \n    p.dec AS declination \nFROM \n    specobj AS s \nJOIN \n    photoobj AS p ON s.bestobjid = p.objid \nWHERE \n    s.class = 'GALAXY' \n    AND s.subclass = 'STARFORMING';"}
{"idx": 255, "db_id": "sdss", "query": "What are the mininum of the extinction r grouped by run number of photometric Galaxy?", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": "keep_all", "galspecline": "drop_all", "spplines": "drop_all", "specobj": "keep_all", "photo_type": "drop_all"}, "ground_truth": "SELECT min( T1.extinction_r), T1.run FROM photoobj AS T1 JOIN photo_type AS T2 ON T1.type = T2.value WHERE T2.name = 'GALAXY' GROUP BY T1.run", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type", "clean", "flags", "rowc", "colc", "cmodelmag_u", "cmodelmag_g", "cmodelmag_r", "ra", "dec", "b", "l", "extinction_r", "mjd", "loadversion", "u", "g", "r", "i", "z"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "segue2primary", "survey", "programname", "mjd", "plate", "fiberid", "special_target1", "segue2_target1", "segue2_target2", "ancillary_target1", "ra", "dec", "z", "zerr", "zwarning", "class", "subclass", "veldisp", "veldisperr", "loadversion"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.run, MIN(p.extinction_r) AS min_extinction_r\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'GALAXY'\nGROUP BY p.run", "qa_pairs": "To find the minimum of the extinction `r` grouped by the run number of photometric galaxies, we need to join the relevant tables and apply the necessary filtering and aggregation. The `photoobj` table contains the `extinction_r` values, and we will group by the `run` number.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT p.run, MIN(p.extinction_r) AS min_extinction_r\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'GALAXY'\nGROUP BY p.run\n```\n\n### Explanation:\n- We select the `run` number from the `photoobj` table and the minimum value of `extinction_r`.\n- We join the `photoobj` table with the `specobj` table on the condition that the `objid` in `photoobj` matches the `bestobjid` in `specobj`.\n- We filter the results to include only those entries where the `class` in `specobj` is 'GALAXY'.\n- Finally, we group the results by the `run` number to get the minimum extinction `r` for each run.", "fixed": false, "try_times": 1, "pred": "SELECT p.run, MIN(p.extinction_r) AS min_extinction_r\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE s.class = 'GALAXY'\nGROUP BY p.run"}
{"idx": 256, "db_id": "sdss", "query": "Find the minimal value of the extinction r for each run number across the photometrically observed Galaxy", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "run", "mode", "type", "clean", "flags"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": "drop_all", "photo_type": "drop_all"}, "ground_truth": "SELECT min( T1.extinction_r), T1.run FROM photoobj AS T1 JOIN photo_type AS T2 ON T1.type = T2.value WHERE T2.name = 'GALAXY' GROUP BY T1.run", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "mode", "type", "clean", "flags"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "segue2primary", "survey"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.run, MIN(n.distance) AS min_extinction_r\nFROM photoobj AS p\nJOIN neighbors AS n ON p.objid = n.objid\nGROUP BY p.run;", "qa_pairs": "To find the minimal value of the extinction \\( r \\) for each run number across the photometrically observed Galaxy, we first need to clarify that the extinction \\( r \\) is typically derived from photometric observations. However, based on the provided schema, there is no direct mention of an extinction \\( r \\) value in the tables. \n\nAssuming that the extinction \\( r \\) is represented by some derived value from the `neighbors` or `photoobj` tables, we would need to aggregate the data based on the `run` number from the `photoobj` table.\n\nIf we assume that the `distance` in the `neighbors` table could represent some form of extinction value, we can write a query to find the minimum distance for each run number. Here's how you can do that:\n\n```sql\nSELECT p.run, MIN(n.distance) AS min_extinction_r\nFROM photoobj AS p\nJOIN neighbors AS n ON p.objid = n.objid\nGROUP BY p.run;\n```\n\n### Explanation:\n1. **SELECT p.run, MIN(n.distance)**: We are selecting the run number and the minimum distance (which we are assuming represents extinction \\( r \\)).\n2. **FROM photoobj AS p JOIN neighbors AS n ON p.objid = n.objid**: We are joining the `photoobj` table with the `neighbors` table on the `objid` to correlate the observations with their neighbors.\n3. **GROUP BY p.run**: We group the results by the run number to get the minimum distance for each run.\n\nThis query will give you the minimal value of the assumed extinction \\( r \\) (represented by distance) for each run number across the photometrically observed Galaxy. If there is a specific column that represents extinction \\( r \\) that is not mentioned in the schema, please provide that detail for a more accurate query.", "fixed": false, "try_times": 1, "pred": "SELECT p.run, MIN(n.distance) AS min_extinction_r\nFROM photoobj AS p\nJOIN neighbors AS n ON p.objid = n.objid\nGROUP BY p.run;"}
{"idx": 257, "db_id": "sdss", "query": "What are the galactic coordinates of all Quasi stellar object (QSO)", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "ra", "dec", "u", "g", "r"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "class", "ra", "dec", "z", "zerr"], "photo_type": "drop_all"}, "ground_truth": "SELECT T1.b, T1.l FROM photoobj AS T1 JOIN specobj AS T2 ON T1.objid = T2.bestobjid where T2.class = 'QSO'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "ra", "dec", "u", "g", "r"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "zerr", "class"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.ra, p.dec \nFROM specobj AS s \nJOIN photoobj AS p ON s.bestobjid = p.objid \nWHERE s.class = 'QSO';", "qa_pairs": "To retrieve the galactic coordinates (right ascension and declination) of all Quasi Stellar Objects (QSO) from the database, we need to join the `specobj` table with the `photoobj` table. The `specobj` table contains the classification of the objects, and we will filter for those classified as 'QSO'. The `photoobj` table contains the coordinates.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT p.ra, p.dec \nFROM specobj AS s \nJOIN photoobj AS p ON s.bestobjid = p.objid \nWHERE s.class = 'QSO';\n```\n\nThis query selects the right ascension (`ra`) and declination (`dec`) from the `photoobj` table for all objects in the `specobj` table that are classified as 'QSO'.", "fixed": false, "try_times": 1, "pred": "SELECT p.ra, p.dec \nFROM specobj AS s \nJOIN photoobj AS p ON s.bestobjid = p.objid \nWHERE s.class = 'QSO';"}
{"idx": 258, "db_id": "sdss", "query": "Find me the galactic latitude and longitude of all Quasi stellar object (QSO)", "evidence": "", "extracted_schema": {"specobj": ["specobjid", "class", "subclass", "ra", "dec", "z"], "photoobj": ["objid", "ra", "dec", "type", "mode", "clean"], "neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"]}, "ground_truth": "SELECT T1.b, T1.l FROM photoobj AS T1 JOIN specobj AS T2 ON T1.objid = T2.bestobjid where T2.class = 'QSO'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "mode", "type", "clean", "ra", "dec"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT ra, dec FROM specobj WHERE class = 'QSO';", "qa_pairs": "To find the galactic latitude and longitude of all Quasi Stellar Objects (QSO), we need to extract the relevant information from the `specobj` table, where the `class` is 'QSO'. However, the provided schema does not explicitly mention columns for galactic latitude and longitude. Instead, we can use the `ra` (right ascension) and `dec` (declination) columns from the `specobj` table, which are often used in astronomical contexts to represent positions in the sky.\n\nHere’s the SQL query to retrieve the `ra` and `dec` for all QSO objects:\n\n```sql\nSELECT ra, dec FROM specobj WHERE class = 'QSO';\n```\n\nThis query selects the right ascension and declination of all objects classified as Quasi Stellar Objects (QSO) from the `specobj` table.", "fixed": false, "try_times": 1, "pred": "SELECT ra, dec FROM specobj WHERE class = 'QSO';"}
{"idx": 259, "db_id": "sdss", "query": "How many photometrically observable Binary Star system we can find, in which it has a distance from cetner to nearest neighbor of under 0.05, a difference of magnitude u and g below 0.4, a difference of magnitude g and r below 0.7, a difference of magnitude r and i above 0.4, and a difference of magnitude i and z above 0.4.", "evidence": "", "extracted_schema": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "u", "g", "r", "i", "z"], "specobj": ["specobjid", "class", "subclass", "ra", "dec", "z"]}, "ground_truth": "SELECT count( T1.objid ) FROM neighbors AS T1 JOIN photoobj AS T2 ON T1.objid = T2.objid JOIN photo_type AS T3 ON T2.type = T3.value WHERE T3.name = 'STAR' and T1.neighbortype = T2.type and T1.distance < 0.05 and T2.u - T2.g < 0.4 and T2.g - T2.r < 0.7 and T2.r - T2.i > 0.4 and T2.i - T2.z > 0.4", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "u", "g", "r", "i", "z"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT COUNT(*) \nFROM neighbors AS n\nJOIN photoobj AS p ON n.objid = p.objid\nJOIN specobj AS s ON n.objid = s.bestobjid\nWHERE n.distance < 0.05 \n  AND ABS(p.u - p.g) < 0.4 \n  AND ABS(p.g - p.r) < 0.7 \n  AND ABS(p.r - p.i) > 0.4 \n  AND ABS(p.i - p.z) > 0.4 \n  AND s.class = 'STAR' \n  AND s.subclass = 'BINARY';", "qa_pairs": "To answer the question regarding the number of photometrically observable Binary Star systems that meet the specified criteria, we need to join the relevant tables and apply the necessary filters based on the conditions provided.\n\nHere’s the SQL query that accomplishes this:\n\n```sql\nSELECT COUNT(*) \nFROM neighbors AS n\nJOIN photoobj AS p ON n.objid = p.objid\nJOIN specobj AS s ON n.objid = s.bestobjid\nWHERE n.distance < 0.05 \n  AND ABS(p.u - p.g) < 0.4 \n  AND ABS(p.g - p.r) < 0.7 \n  AND ABS(p.r - p.i) > 0.4 \n  AND ABS(p.i - p.z) > 0.4 \n  AND s.class = 'STAR' \n  AND s.subclass = 'BINARY';\n```\n\n### Explanation of the SQL Query:\n1. **FROM Clause**: We start from the `neighbors` table (aliased as `n`), which contains the distances to neighboring objects.\n2. **JOINs**: \n   - We join the `photoobj` table (aliased as `p`) to access the magnitude values (u, g, r, i, z).\n   - We also join the `specobj` table (aliased as `s`) to filter for objects that are classified as Binary Stars.\n3. **WHERE Clause**: \n   - We apply the distance condition (`n.distance < 0.05`).\n   - We check the differences in magnitudes as specified:\n     - `ABS(p.u - p.g) < 0.4`\n     - `ABS(p.g - p.r) < 0.7`\n     - `ABS(p.r - p.i) > 0.4`\n     - `ABS(p.i - p.z) > 0.4`\n   - We filter for objects that are classified as 'STAR' and have a subclass of 'BINARY'.\n4. **COUNT(*)**: Finally, we count the number of records that meet all the criteria.\n\nThis query will return the total number of Binary Star systems that are photometrically observable under the specified conditions.", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(*) \nFROM neighbors AS n\nJOIN photoobj AS p ON n.objid = p.objid\nJOIN specobj AS s ON n.objid = s.bestobjid\nWHERE n.distance < 0.05 \n  AND ABS(p.u - p.g) < 0.4 \n  AND ABS(p.g - p.r) < 0.7 \n  AND ABS(p.r - p.i) > 0.4 \n  AND ABS(p.i - p.z) > 0.4 \n  AND s.class = 'STAR' \n  AND s.subclass = 'BINARY';"}
{"idx": 260, "db_id": "sdss", "query": "Count the number of photometrically observed Binary Star system, where the distance between center and neighbor below 0.05 and with the following constraints, u - g < 0.4, g - r < 0.7, r - i > 0.4, i - z > 0.4", "evidence": "", "extracted_schema": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "survey", "programname"]}, "ground_truth": "SELECT count( T1.objid ) FROM neighbors AS T1 JOIN photoobj AS T2 ON T1.objid = T2.objid JOIN photo_type AS T3 ON T2.type = T3.value WHERE T3.name = 'STAR' and T1.neighbortype = T2.type and T1.distance < 0.05 and T2.u - T2.g < 0.4 and T2.g - T2.r < 0.7 and T2.r - T2.i > 0.4 and T2.i - T2.z > 0.4", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "survey", "programname"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT COUNT(*) \nFROM neighbors AS n\nJOIN photoobj AS p ON n.objid = p.objid\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE n.distance < 0.05 \n  AND n.type = 3  -- Assuming type 3 corresponds to Binary Star systems\n  AND (s.u - s.g) < 0.4 \n  AND (s.g - s.r) < 0.7 \n  AND (s.r - s.i) > 0.4 \n  AND (s.i - s.z) > 0.4;", "qa_pairs": "To count the number of photometrically observed Binary Star systems with the specified conditions, we need to join the relevant tables and apply the necessary filters. The conditions include a distance constraint and color index constraints.\n\nHere's the SQL query that accomplishes this:\n\n```sql\nSELECT COUNT(*) \nFROM neighbors AS n\nJOIN photoobj AS p ON n.objid = p.objid\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE n.distance < 0.05 \n  AND n.type = 3  -- Assuming type 3 corresponds to Binary Star systems\n  AND (s.u - s.g) < 0.4 \n  AND (s.g - s.r) < 0.7 \n  AND (s.r - s.i) > 0.4 \n  AND (s.i - s.z) > 0.4;\n```\n\n### Explanation:\n1. **Table Joins**: \n   - We join the `neighbors` table with the `photoobj` table on `objid`.\n   - We also join the `photoobj` table with the `specobj` table on `bestobjid` to access the spectral data.\n\n2. **Conditions**:\n   - We filter for distances less than 0.05.\n   - We check that the type of the neighbor is 3, which we assume corresponds to Binary Star systems.\n   - We apply the color index constraints as specified in the question.\n\n3. **Count**: \n   - Finally, we count the number of records that meet all these conditions. \n\nMake sure to adjust the conditions based on the actual definitions of the types and the structure of the `specobj` table if necessary.", "fixed": true, "try_times": 2, "pred": "-- SQL Type: SELECT\nSELECT COUNT(*) \nFROM neighbors AS n\nJOIN photoobj AS p ON n.objid = p.objid\nWHERE n.distance < 0.05 \n  AND n.type = 3  -- Assuming type 3 corresponds to Binary Star systems\n  AND p.mode = 1; -- Assuming mode 1 corresponds to photometric observations"}
{"idx": 262, "db_id": "sdss", "query": "How many photometrically observable Binary Star system were found, of which the distance to nearst neighbor below 0.05, the difference of magnitude u and g less than 0.4, the difference of magnitude g and r less than 0.7, the difference of magnitude r and i greater than 0.4, and the difference of magnitude i and z greater than 0.4.", "evidence": "", "extracted_schema": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "survey", "programname"]}, "ground_truth": "SELECT COUNT(p.objid) FROM photoobj AS p JOIN photo_type AS pt ON p.type = pt.value WHERE pt.name = 'STAR' AND (p.u - p.g) < 0.4 AND (p.g - p.r) < 0.7 AND  (p.r - p.i) > 0.4 AND (p.i - p.z) > 0.4 AND p.objid in (SELECT n.objid FROM neighbors AS n JOIN photo_type AS pt ON n.neighbortype = pt.value WHERE n.distance < 0.05 AND pt.name = 'STAR')", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "survey", "programname"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT COUNT(*) \nFROM photoobj AS p\nJOIN neighbors AS n ON p.objid = n.objid\nWHERE n.distance < 0.05 \n  AND p.type = 'Binary Star'  -- Assuming 'Binary Star' is the type for Binary Star systems\n  AND (p.u - p.g) < 0.4       -- Assuming p.u and p.g are the magnitudes for u and g bands\n  AND (p.g - p.r) < 0.7       -- Assuming p.g and p.r are the magnitudes for g and r bands\n  AND (p.r - p.i) > 0.4       -- Assuming p.r and p.i are the magnitudes for r and i bands\n  AND (p.i - p.z) > 0.4;      -- Assuming p.i and p.z are the magnitudes for i and z bands", "qa_pairs": "To answer the question regarding the number of photometrically observable Binary Star systems that meet the specified criteria, we need to join the relevant tables and apply the necessary filters based on the conditions provided.\n\nAssuming that the \"Binary Star system\" is represented by a specific `type` in the `photoobj` table, we will need to filter for that type. We will also need to ensure that we have the necessary magnitude differences, which are not explicitly defined in the provided schema but are typically found in photometric data.\n\nHere's how we can construct the SQL query:\n\n```sql\nSELECT COUNT(*) \nFROM photoobj AS p\nJOIN neighbors AS n ON p.objid = n.objid\nWHERE n.distance < 0.05 \n  AND p.type = 'Binary Star'  -- Assuming 'Binary Star' is the type for Binary Star systems\n  AND (p.u - p.g) < 0.4       -- Assuming p.u and p.g are the magnitudes for u and g bands\n  AND (p.g - p.r) < 0.7       -- Assuming p.g and p.r are the magnitudes for g and r bands\n  AND (p.r - p.i) > 0.4       -- Assuming p.r and p.i are the magnitudes for r and i bands\n  AND (p.i - p.z) > 0.4;      -- Assuming p.i and p.z are the magnitudes for i and z bands\n```\n\n### Explanation:\n1. **Join the Tables**: We join the `photoobj` table with the `neighbors` table on the `objid` to access the distance to the nearest neighbor.\n2. **Filter Conditions**:\n   - We check if the distance to the nearest neighbor is less than 0.05.\n   - We filter for the type of object, assuming 'Binary Star' is the designation for Binary Star systems.\n   - We apply the conditions for the differences in magnitudes between the various bands (u, g, r, i, z).\n3. **Count the Results**: Finally, we count the number of records that meet all these criteria.\n\nMake sure to replace `'Binary Star'` with the actual value that represents Binary Star systems in your `photoobj` table if it differs. Additionally, ensure that the magnitude columns (u, g, r, i, z) exist in the `photoobj` table or adjust the query accordingly based on your actual schema.", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(*) \nFROM photoobj AS p\nJOIN neighbors AS n ON p.objid = n.objid\nWHERE n.distance < 0.05 \n  AND p.type = 'Binary Star'  -- Assuming 'Binary Star' is the type for Binary Star systems\n  AND (p.u - p.g) < 0.4       -- Assuming p.u and p.g are the magnitudes for u and g bands\n  AND (p.g - p.r) < 0.7       -- Assuming p.g and p.r are the magnitudes for g and r bands\n  AND (p.r - p.i) > 0.4       -- Assuming p.r and p.i are the magnitudes for r and i bands\n  AND (p.i - p.z) > 0.4;      -- Assuming p.i and p.z are the magnitudes for i and z bands"}
{"idx": 263, "db_id": "sdss", "query": "Find all star observed both photometrically and spectroscopically whose subclass is 'Carbon'", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": "keep_all", "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "class", "subclass", "bestobjid", "plateid", "fiberid"], "photo_type": "drop_all"}, "ground_truth": "select s.specobjid from specobj as s JOIN photoobj as p ON s.bestobjid = p.objid JOIN photo_type as pt ON p.type = pt.value WHERE s.class = 'STAR' and pt.name = 'STAR' and s.subclass = 'Carbon'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type", "clean", "flags", "rowc", "colc", "cmodelmag_u", "cmodelmag_g", "cmodelmag_r", "ra", "dec", "b", "l", "extinction_r", "mjd", "loadversion", "u", "g", "r", "i", "z"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "fiberid", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT DISTINCT p.objid \nFROM photoobj AS p \nJOIN specobj AS s ON p.objid = s.bestobjid \nWHERE s.subclass = 'Carbon' AND p.type = (SELECT value FROM photo_type WHERE name = 'STAR');", "qa_pairs": "To find all stars that have been observed both photometrically and spectroscopically and whose subclass is 'Carbon', we need to join the relevant tables based on their relationships and apply the necessary filters.\n\nHere's the SQL query that accomplishes this:\n\n```sql\nSELECT DISTINCT p.objid \nFROM photoobj AS p \nJOIN specobj AS s ON p.objid = s.bestobjid \nWHERE s.subclass = 'Carbon' AND p.type = (SELECT value FROM photo_type WHERE name = 'STAR');\n```\n\n### Explanation:\n1. **Selecting Distinct Object IDs**: We select distinct `objid` from the `photoobj` table to avoid duplicates.\n2. **Joining Tables**: We join the `photoobj` table with the `specobj` table on the condition that the `objid` from `photoobj` matches the `bestobjid` from `specobj`. This ensures we are only considering objects that have both photometric and spectroscopic observations.\n3. **Filtering by Subclass**: We filter the results to include only those records where the `subclass` in the `specobj` table is 'Carbon'.\n4. **Filtering by Type**: We ensure that the type of the photometric observation is 'STAR' by checking against the `photo_type` table.\n\nThis query will return all unique stars that meet the specified criteria.", "fixed": false, "try_times": 1, "pred": "SELECT DISTINCT p.objid \nFROM photoobj AS p \nJOIN specobj AS s ON p.objid = s.bestobjid \nWHERE s.subclass = 'Carbon' AND p.type = (SELECT value FROM photo_type WHERE name = 'STAR');"}
{"idx": 264, "db_id": "sdss", "query": "Show me the photometrically observable Star with subclass of Carbon, which was spectroscopically observed as well", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "type", "mode", "clean", "flags", "run"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "class", "subclass", "bestobjid", "survey", "mjd"], "photo_type": "drop_all"}, "ground_truth": "select s.specobjid from specobj as s JOIN photoobj as p ON s.bestobjid = p.objid JOIN photo_type as pt ON p.type = pt.value WHERE s.class = 'STAR' and pt.name = 'STAR' and s.subclass = 'Carbon'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "mode", "type", "clean", "flags"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "survey", "mjd", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.objid\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE p.type = 'STAR' \n  AND p.clean = 1 \n  AND s.subclass = 'Carbon';", "qa_pairs": "To answer the question about showing photometrically observable stars with a subclass of Carbon that were also spectroscopically observed, we need to join the relevant tables based on their relationships and filter the results accordingly.\n\nHere's how we can construct the SQL query:\n\n1. We need to identify the stars from the `photoobj` table that are classified as stars and have a clean photometry flag.\n2. We will then join this with the `specobj` table to ensure that these stars have been spectroscopically observed.\n3. Finally, we will filter for stars that have a subclass of 'Carbon'.\n\nHere’s the SQL query that accomplishes this:\n\n```sql\nSELECT p.objid\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nWHERE p.type = 'STAR' \n  AND p.clean = 1 \n  AND s.subclass = 'Carbon';\n```\n\n### Explanation:\n- `SELECT p.objid`: We are selecting the object IDs of the stars.\n- `FROM photoobj AS p`: We are starting from the `photoobj` table, aliased as `p`.\n- `JOIN specobj AS s ON p.objid = s.bestobjid`: We join the `specobj` table, aliased as `s`, on the condition that the `objid` from `photoobj` matches the `bestobjid` from `specobj`.\n- `WHERE p.type = 'STAR'`: We filter to include only those objects that are classified as stars.\n- `AND p.clean = 1`: We ensure that we only include stars with a clean photometry flag.\n- `AND s.subclass = 'Carbon'`: Finally, we filter for stars that have a subclass of 'Carbon'.\n\nThis query will return the IDs of photometrically observable stars with the specified subclass that have also been observed spectroscopically.", "fixed": true, "try_times": 3, "pred": "-- SQL Type: SELECT\nSELECT DISTINCT p.objid\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nJOIN galspecline AS g ON s.specobjid = g.specobjid\nJOIN spplines AS sp ON s.specobjid = sp.specobjid\nWHERE p.type = 'STAR' \n  AND p.clean = 1\n  AND s.subclass = 'Carbon';"}
{"idx": 265, "db_id": "sdss", "query": "Find the number of photometrically observed Galaxy", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": "keep_all", "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "class", "subclass", "ra", "dec", "z"], "photo_type": "drop_all"}, "ground_truth": "select COUNT(*) from photoobj as p join photo_type as pt on p.type = pt.value where pt.name = 'GALAXY'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type", "clean", "flags", "rowc", "colc", "cmodelmag_u", "cmodelmag_g", "cmodelmag_r", "ra", "dec", "b", "l", "extinction_r", "mjd", "loadversion", "u", "g", "r", "i", "z"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT COUNT(*) \nFROM photoobj AS p \nJOIN specobj AS s ON p.objid = s.bestobjid \nWHERE s.class = 'GALAXY';", "qa_pairs": "To find the number of photometrically observed galaxies, we need to count the entries in the `photoobj` table where the `type` corresponds to galaxies in the `specobj` table. We can achieve this by joining the `photoobj` and `specobj` tables based on the `bestobjid` and `objid`, and then filtering for the class 'GALAXY'.\n\nHere is the SQL query to accomplish this:\n\n```sql\nSELECT COUNT(*) \nFROM photoobj AS p \nJOIN specobj AS s ON p.objid = s.bestobjid \nWHERE s.class = 'GALAXY';\n```\n\nThis query counts all the photometrically observed objects in the `photoobj` table that are classified as galaxies in the `specobj` table.", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(*) \nFROM photoobj AS p \nJOIN specobj AS s ON p.objid = s.bestobjid \nWHERE s.class = 'GALAXY';"}
{"idx": 266, "db_id": "sdss", "query": "Count the number of photometrically observable Galaxy", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "type", "mode", "clean", "flags", "run"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "class", "subclass", "bestobjid", "survey", "mjd"], "photo_type": "drop_all"}, "ground_truth": "select COUNT(*) from photoobj as p join photo_type as pt on p.type = pt.value where pt.name = 'GALAXY'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "mode", "type", "clean", "flags"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "survey", "mjd", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT COUNT(*) \nFROM specobj AS s \nJOIN photoobj AS p ON s.bestobjid = p.objid \nWHERE s.class = 'GALAXY' AND p.clean = 1;", "qa_pairs": "To count the number of photometrically observable galaxies, we need to join the relevant tables and filter for the appropriate conditions. Specifically, we will look for entries in the `specobj` table where the class is 'GALAXY' and the corresponding entries in the `photoobj` table have a clean photometry flag set to 1 (indicating they are observable).\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT COUNT(*) \nFROM specobj AS s \nJOIN photoobj AS p ON s.bestobjid = p.objid \nWHERE s.class = 'GALAXY' AND p.clean = 1;\n```\n\nThis query counts the number of galaxies that are photometrically observable based on the specified conditions.", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(*) \nFROM specobj AS s \nJOIN photoobj AS p ON s.bestobjid = p.objid \nWHERE s.class = 'GALAXY' AND p.clean = 1;"}
{"idx": 267, "db_id": "sdss", "query": "Find the object ids, classes and subclasses of spectroscopically and photometrically observable Galaxy with AGN.", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "type", "clean", "flags", "ra", "dec"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "class", "subclass", "bestobjid", "plateid", "fiberid"], "photo_type": "drop_all"}, "ground_truth": "select s.specobjid, s.class, s.subclass from specobj as s join photoobj as p on s.bestobjid = p.objid join photo_type as pt on p.type = pt.value where s.subclass like '%AGN%' and s.class = 'GALAXY' and pt.name = 'GALAXY'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "type", "clean", "flags", "ra", "dec"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "fiberid", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT \n    p.objid, \n    s.class, \n    s.subclass \nFROM \n    specobj AS s \nJOIN \n    photoobj AS p ON s.bestobjid = p.objid \nWHERE \n    s.class = 'GALAXY' \n    AND s.subclass LIKE '%AGN%'", "qa_pairs": "To find the object ids, classes, and subclasses of spectroscopically and photometrically observable galaxies with AGN (Active Galactic Nuclei), we need to join the relevant tables based on the relationships defined in the schema. Specifically, we will focus on the `specobj` table for the classification of objects and the `photoobj` table for photometric observations.\n\nHere's the SQL query that accomplishes this:\n\n```sql\nSELECT \n    p.objid, \n    s.class, \n    s.subclass \nFROM \n    specobj AS s \nJOIN \n    photoobj AS p ON s.bestobjid = p.objid \nWHERE \n    s.class = 'GALAXY' \n    AND s.subclass LIKE '%AGN%'\n```\n\n### Explanation:\n1. **SELECT Clause**: We are selecting the `objid` from the `photoobj` table, and the `class` and `subclass` from the `specobj` table.\n2. **FROM Clause**: We start with the `specobj` table (aliased as `s`).\n3. **JOIN Clause**: We join the `photoobj` table (aliased as `p`) on the condition that the `bestobjid` in `specobj` matches the `objid` in `photoobj`.\n4. **WHERE Clause**: We filter the results to include only those records where the `class` is 'GALAXY' and the `subclass` contains 'AGN' (indicating that it is an Active Galactic Nucleus).\n\nThis query will return the desired object ids, classes, and subclasses for galaxies that are spectroscopically and photometrically observable with AGN characteristics.", "fixed": false, "try_times": 1, "pred": "SELECT \n    p.objid, \n    s.class, \n    s.subclass \nFROM \n    specobj AS s \nJOIN \n    photoobj AS p ON s.bestobjid = p.objid \nWHERE \n    s.class = 'GALAXY' \n    AND s.subclass LIKE '%AGN%'"}
{"idx": 268, "db_id": "sdss", "query": "Fetch me the spectroscopic object id, the spectroscopic class and subclass of Galaxy with AGN observed both spectroscopically and photometrically.", "evidence": "", "extracted_schema": {"specobj": ["specobjid", "class", "subclass", "bestobjid", "survey", "mjd"], "photoobj": ["objid", "type", "mode", "run", "field", "clean"], "neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"]}, "ground_truth": "select s.specobjid, s.class, s.subclass from specobj as s join photoobj as p on s.bestobjid = p.objid join photo_type as pt on p.type = pt.value where s.subclass like '%AGN%' and s.class = 'GALAXY' and pt.name = 'GALAXY'", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "field", "mode", "type", "clean"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "survey", "mjd", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT specobj.specobjid, specobj.class, specobj.subclass\nFROM specobj\nJOIN photoobj ON specobj.bestobjid = photoobj.objid\nWHERE specobj.class = 'GALAXY' AND specobj.subclass = 'AGN';", "qa_pairs": "To fetch the spectroscopic object id, the spectroscopic class, and subclass of galaxies with AGN observed both spectroscopically and photometrically, we need to join the relevant tables based on the relationships defined in the schema. Specifically, we will focus on the `specobj` table for the spectroscopic information and the `photoobj` table for the photometric observations.\n\nHere's the SQL query that accomplishes this:\n\n```sql\nSELECT specobj.specobjid, specobj.class, specobj.subclass\nFROM specobj\nJOIN photoobj ON specobj.bestobjid = photoobj.objid\nWHERE specobj.class = 'GALAXY' AND specobj.subclass = 'AGN';\n```\n\n### Explanation:\n1. **SELECT Clause**: We are selecting the `specobjid`, `class`, and `subclass` from the `specobj` table.\n2. **FROM Clause**: We are starting from the `specobj` table.\n3. **JOIN Clause**: We join the `photoobj` table on the condition that the `bestobjid` from `specobj` matches the `objid` from `photoobj`. This ensures we are only considering objects that have both spectroscopic and photometric data.\n4. **WHERE Clause**: We filter the results to include only those records where the `class` is 'GALAXY' and the `subclass` is 'AGN', indicating that we are interested in galaxies with Active Galactic Nuclei (AGN).\n\nThis query will return the desired information about galaxies with AGN that have been observed both spectroscopically and photometrically.", "fixed": false, "try_times": 1, "pred": "SELECT specobj.specobjid, specobj.class, specobj.subclass\nFROM specobj\nJOIN photoobj ON specobj.bestobjid = photoobj.objid\nWHERE specobj.class = 'GALAXY' AND specobj.subclass = 'AGN';"}
{"idx": 269, "db_id": "sdss", "query": "Show me the least distance of the nearst photometrically observable Star", "evidence": "", "extracted_schema": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "photo_type": ["value", "name", "description"]}, "ground_truth": "SELECT min(n.distance) FROM neighbors AS n JOIN photo_type AS pt ON n.neighbortype = pt.value JOIN photoobj AS p ON p.objid = n.objid WHERE pt.name = 'STAR' and p.objid in (SELECT p.objid FROM photoobj AS p JOIN photo_type AS pt ON p.type = pt.value WHERE pt.name = 'STAR')", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "segue2primary", "survey", "programname", "mjd", "plate", "fiberid", "special_target1", "segue2_target1", "segue2_target2", "ancillary_target1", "ra", "dec", "z", "zerr", "zwarning", "class", "subclass", "veldisp", "veldisperr", "loadversion"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT MIN(n.distance) AS least_distance\nFROM neighbors AS n\nJOIN photoobj AS p ON n.objid = p.objid\nWHERE p.type = 'STAR'", "qa_pairs": "To find the least distance of the nearest photometrically observable Star, we need to join the `neighbors` table with the `photoobj` table to filter for objects of type 'STAR' and then find the minimum distance. \n\nHere is the SQL query to achieve that:\n\n```sql\nSELECT MIN(n.distance) AS least_distance\nFROM neighbors AS n\nJOIN photoobj AS p ON n.objid = p.objid\nWHERE p.type = 'STAR'\n```\n\nThis query selects the minimum distance from the `neighbors` table where the corresponding object in the `photoobj` table is classified as a 'STAR'.", "fixed": true, "try_times": 3, "pred": "-- SQL Type: SELECT\nSELECT MIN(n.distance) AS least_distance\nFROM neighbors AS n\nJOIN photoobj AS p ON n.objid = p.objid\nWHERE p.type = 'STAR' AND n.distance IS NOT NULL"}
{"idx": 270, "db_id": "sdss", "query": "What is the minimal distance between the nearest photometrically observed Star?", "evidence": "", "extracted_schema": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "photo_type": ["value", "name", "description"]}, "ground_truth": "SELECT min(n.distance) FROM neighbors AS n JOIN photo_type AS pt ON n.neighbortype = pt.value JOIN photoobj AS p ON p.objid = n.objid WHERE pt.name = 'STAR' and p.objid in (SELECT p.objid FROM photoobj AS p JOIN photo_type AS pt ON p.type = pt.value WHERE pt.name = 'STAR')", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "segue2primary", "survey", "programname", "mjd", "plate", "fiberid", "special_target1", "segue2_target1", "segue2_target2", "ancillary_target1", "ra", "dec", "z", "zerr", "zwarning", "class", "subclass", "veldisp", "veldisperr", "loadversion"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT MIN(n.distance) AS minimal_distance\nFROM neighbors AS n\nJOIN photoobj AS p ON n.objid = p.objid\nWHERE p.type = (SELECT value FROM photo_type WHERE name = 'STAR');", "qa_pairs": "To find the minimal distance between the nearest photometrically observed Star, we need to join the `neighbors` table with the `photoobj` table to filter for objects of type 'STAR' and then find the minimum distance. \n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT MIN(n.distance) AS minimal_distance\nFROM neighbors AS n\nJOIN photoobj AS p ON n.objid = p.objid\nWHERE p.type = (SELECT value FROM photo_type WHERE name = 'STAR');\n```\n\nThis query does the following:\n1. Joins the `neighbors` table (`n`) with the `photoobj` table (`p`) on the `objid`.\n2. Filters the results to include only those entries in `photoobj` where the `type` corresponds to 'STAR' (using a subquery to get the correct value from the `photo_type` table).\n3. Selects the minimum distance from the filtered results.", "fixed": false, "try_times": 1, "pred": "SELECT MIN(n.distance) AS minimal_distance\nFROM neighbors AS n\nJOIN photoobj AS p ON n.objid = p.objid\nWHERE p.type = (SELECT value FROM photo_type WHERE name = 'STAR');"}
{"idx": 271, "db_id": "sdss", "query": "Show me the longest distance of the photometrically observable GALAXY neighbors", "evidence": "", "extracted_schema": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "survey", "programname"]}, "ground_truth": "SELECT max(n.distance) FROM neighbors AS n JOIN photo_type AS pt ON n.neighbortype = pt.value JOIN photoobj AS p ON p.objid = n.objid WHERE pt.name = 'GALAXY' and p.objid in (SELECT p.objid FROM photoobj AS p JOIN photo_type AS pt ON p.type = pt.value WHERE pt.name = 'GALAXY')", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "survey", "programname"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT MAX(distance) AS longest_distance \nFROM neighbors \nWHERE type = 3;", "qa_pairs": "To find the longest distance of the photometrically observable GALAXY neighbors, we need to filter the `neighbors` table for entries where the `type` corresponds to a GALAXY. Since the specific value for a GALAXY type is not provided in the schema, we will assume that the type value for GALAXY is `3` based on the examples given.\n\nWe will then select the maximum distance from the `neighbors` table where the `type` is `3`. Here is the SQL query to achieve that:\n\n```sql\nSELECT MAX(distance) AS longest_distance \nFROM neighbors \nWHERE type = 3;\n```\n\nThis query retrieves the maximum distance from the `neighbors` table for entries where the object type is classified as a GALAXY.", "fixed": false, "try_times": 1, "pred": "SELECT MAX(distance) AS longest_distance \nFROM neighbors \nWHERE type = 3;"}
{"idx": 272, "db_id": "sdss", "query": "What is the maximal distance between the nearest photometrically observed Star?", "evidence": "", "extracted_schema": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "survey", "programname"]}, "ground_truth": "SELECT max(n.distance) FROM neighbors AS n JOIN photo_type AS pt ON n.neighbortype = pt.value JOIN photoobj AS p ON p.objid = n.objid WHERE pt.name = 'GALAXY' and p.objid in (SELECT p.objid FROM photoobj AS p JOIN photo_type AS pt ON p.type = pt.value WHERE pt.name = 'GALAXY')", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "survey", "programname"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT MAX(n.distance) \nFROM neighbors AS n \nJOIN photoobj AS p ON n.objid = p.objid \nWHERE p.type = (SELECT value FROM photo_type WHERE name = 'STAR');", "qa_pairs": "To find the maximal distance between the nearest photometrically observed Star, we need to join the `neighbors` and `photoobj` tables. We will filter the results to only include entries where the `type` in the `photoobj` table corresponds to 'STAR'. Then, we will select the maximum distance from the `neighbors` table for those entries.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT MAX(n.distance) \nFROM neighbors AS n \nJOIN photoobj AS p ON n.objid = p.objid \nWHERE p.type = (SELECT value FROM photo_type WHERE name = 'STAR');\n```\n\nThis query does the following:\n1. Joins the `neighbors` table with the `photoobj` table on the `objid`.\n2. Filters the results to include only those rows where the `type` in `photoobj` corresponds to 'STAR'.\n3. Selects the maximum distance from the `neighbors` table for the filtered results.", "fixed": false, "try_times": 1, "pred": "SELECT MAX(n.distance) \nFROM neighbors AS n \nJOIN photoobj AS p ON n.objid = p.objid \nWHERE p.type = (SELECT value FROM photo_type WHERE name = 'STAR');"}
{"idx": 273, "db_id": "sdss", "query": "What are the galactic coordinates of the center object with the least distance to its nearest neighbor. Please retrieve the distance also.", "evidence": "", "extracted_schema": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "ra", "dec", "type", "mode", "clean"], "specobj": ["specobjid", "ra", "dec", "z", "class", "subclass"]}, "ground_truth": "SELECT p.b, p.l, n.distance from photoobj as p join neighbors n on p.objid = n.objid where n.distance = (select min(n.distance) from neighbors as n)", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "mode", "type", "clean", "ra", "dec"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.ra, p.dec, n.distance\nFROM neighbors AS n\nJOIN photoobj AS p ON n.objid = p.objid\nWHERE n.distance = (SELECT MIN(distance) FROM neighbors)", "qa_pairs": "To find the galactic coordinates of the center object with the least distance to its nearest neighbor, we need to join the `neighbors` and `photoobj` tables. We will first identify the minimum distance for each object and then retrieve the corresponding coordinates and distance.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT p.ra, p.dec, n.distance\nFROM neighbors AS n\nJOIN photoobj AS p ON n.objid = p.objid\nWHERE n.distance = (SELECT MIN(distance) FROM neighbors)\n```\n\n### Explanation:\n1. **Join the Tables**: We join the `neighbors` table with the `photoobj` table on the `objid` to get the right ascension (`ra`) and declination (`dec`) of the objects.\n2. **Subquery for Minimum Distance**: We use a subquery to find the minimum distance from the `neighbors` table.\n3. **Select Required Fields**: Finally, we select the `ra`, `dec`, and `distance` of the object that has the least distance to its nearest neighbor.\n\nThis query will return the galactic coordinates and the distance of the center object with the least distance to its nearest neighbor.", "fixed": false, "try_times": 1, "pred": "SELECT p.ra, p.dec, n.distance\nFROM neighbors AS n\nJOIN photoobj AS p ON n.objid = p.objid\nWHERE n.distance = (SELECT MIN(distance) FROM neighbors)"}
{"idx": 274, "db_id": "sdss", "query": "Fetch the least distance of the nearst neighbors. Retrieve the corresponding galactic latitude, galactic longitude as well.", "evidence": "", "extracted_schema": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "ra", "dec", "b", "l", "type"], "specobj": "drop_all"}, "ground_truth": "SELECT p.b, p.l, n.distance from photoobj as p join neighbors n on p.objid = n.objid where n.distance = (select min(n.distance) from neighbors as n)", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "type", "ra", "dec", "b", "l"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "segue2primary", "survey"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.b AS Galactic_Latitude, p.l AS Galactic_Longitude, MIN(n.distance) AS Least_Distance\nFROM neighbors AS n\nJOIN photoobj AS p ON n.objid = p.objid\nGROUP BY p.objid\nORDER BY Least_Distance ASC\nLIMIT 1;", "qa_pairs": "To fetch the least distance of the nearest neighbors along with the corresponding galactic latitude and galactic longitude, you can use the following SQL query. This query will join the `neighbors` and `photoobj` tables to get the required information.\n\n```sql\nSELECT p.b AS Galactic_Latitude, p.l AS Galactic_Longitude, MIN(n.distance) AS Least_Distance\nFROM neighbors AS n\nJOIN photoobj AS p ON n.objid = p.objid\nGROUP BY p.objid\nORDER BY Least_Distance ASC\nLIMIT 1;\n```\n\n### Explanation:\n1. **SELECT Clause**: We select the galactic latitude (`p.b`), galactic longitude (`p.l`), and the minimum distance (`MIN(n.distance)`).\n2. **FROM Clause**: We are selecting from the `neighbors` table (aliased as `n`) and joining it with the `photoobj` table (aliased as `p`) on the `objid`.\n3. **GROUP BY Clause**: We group by `p.objid` to ensure we get the minimum distance for each object.\n4. **ORDER BY Clause**: We order the results by the least distance in ascending order.\n5. **LIMIT Clause**: We limit the results to just one row to get the nearest neighbor.\n\nThis query will return the galactic latitude and longitude of the object that has the least distance to its neighbor.", "fixed": false, "try_times": 1, "pred": "SELECT p.b AS Galactic_Latitude, p.l AS Galactic_Longitude, MIN(n.distance) AS Least_Distance\nFROM neighbors AS n\nJOIN photoobj AS p ON n.objid = p.objid\nGROUP BY p.objid\nORDER BY Least_Distance ASC\nLIMIT 1;"}
{"idx": 275, "db_id": "sdss", "query": "What are the galactic coordinates of the center object with the least distance to its nearest neighbor. Please retrieve the distance also.", "evidence": "", "extracted_schema": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "ra", "dec", "type", "clean", "flags"], "specobj": ["specobjid", "ra", "dec", "z", "class", "subclass"]}, "ground_truth": "SELECT p.b, p.l, n.distance from photoobj as p join neighbors as n on p.objid = n.objid order by n.distance asc limit 1", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "type", "clean", "flags", "ra", "dec"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT P.ra, P.dec, N.distance\nFROM neighbors AS N\nJOIN photoobj AS P ON N.objid = P.objid\nWHERE N.distance = (SELECT MIN(distance) FROM neighbors)", "qa_pairs": "To find the galactic coordinates of the center object with the least distance to its nearest neighbor, we need to join the `neighbors` and `photoobj` tables. We will first find the minimum distance from the `neighbors` table and then retrieve the corresponding object details from the `photoobj` table.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT P.ra, P.dec, N.distance\nFROM neighbors AS N\nJOIN photoobj AS P ON N.objid = P.objid\nWHERE N.distance = (SELECT MIN(distance) FROM neighbors)\n```\n\n### Explanation:\n1. **Subquery**: `(SELECT MIN(distance) FROM neighbors)` retrieves the minimum distance from the `neighbors` table.\n2. **Join**: We join the `neighbors` table with the `photoobj` table on the `objid` to get the galactic coordinates (right ascension `ra` and declination `dec`) of the object.\n3. **Selection**: We select the `ra`, `dec`, and `distance` of the object that has the minimum distance to its nearest neighbor.\n\nThis query will return the galactic coordinates of the center object with the least distance to its nearest neighbor along with that distance.", "fixed": false, "try_times": 1, "pred": "SELECT P.ra, P.dec, N.distance\nFROM neighbors AS N\nJOIN photoobj AS P ON N.objid = P.objid\nWHERE N.distance = (SELECT MIN(distance) FROM neighbors)"}
{"idx": 276, "db_id": "sdss", "query": "Show me the galactic coordinates of the center object with the least distance to the nearest neighbors. Return the distance as well.", "evidence": "", "extracted_schema": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "ra", "dec", "type", "mode", "clean"], "specobj": ["specobjid", "ra", "dec", "z", "class", "subclass"]}, "ground_truth": "SELECT p.b, p.l, n.distance from photoobj as p join neighbors as n on p.objid = n.objid order by n.distance asc limit 1", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "mode", "type", "clean", "ra", "dec"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.ra, p.dec, n.distance\nFROM neighbors AS n\nJOIN photoobj AS p ON n.objid = p.objid\nWHERE n.distance = (SELECT MIN(distance) FROM neighbors)", "qa_pairs": "To find the galactic coordinates of the center object with the least distance to its nearest neighbors, we need to join the `neighbors` and `photoobj` tables. We will select the `ra` (right ascension) and `dec` (declination) of the object with the minimum distance to its neighbor. \n\nHere is the SQL query to achieve that:\n\n```sql\nSELECT p.ra, p.dec, n.distance\nFROM neighbors AS n\nJOIN photoobj AS p ON n.objid = p.objid\nWHERE n.distance = (SELECT MIN(distance) FROM neighbors)\n```\n\nThis query does the following:\n1. Joins the `neighbors` table with the `photoobj` table on the `objid`.\n2. Selects the `ra`, `dec`, and `distance` of the object where the distance is equal to the minimum distance found in the `neighbors` table. \n\nThis will return the galactic coordinates of the center object with the least distance to its nearest neighbor along with that distance.", "fixed": false, "try_times": 1, "pred": "SELECT p.ra, p.dec, n.distance\nFROM neighbors AS n\nJOIN photoobj AS p ON n.objid = p.objid\nWHERE n.distance = (SELECT MIN(distance) FROM neighbors)"}
{"idx": 278, "db_id": "sdss", "query": "What is the redshift of the center object that has the minimal distance to the nearest neighbor", "evidence": "", "extracted_schema": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "field", "type", "ra", "dec"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "zerr"]}, "ground_truth": "SELECT s.z from specobj as s join photoobj as p on s.bestobjid = p.objid join neighbors as n on p.objid = n.objid where n.distance = (select min(n.distance) from neighbors as n)", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "field", "type", "ra", "dec"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "zerr"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT s.z \nFROM specobj AS s \nJOIN photoobj AS p ON s.bestobjid = p.objid \nWHERE p.objid = (\n    SELECT n.objid \n    FROM neighbors AS n \n    ORDER BY n.distance \n    LIMIT 1\n);", "qa_pairs": "To find the redshift of the center object that has the minimal distance to the nearest neighbor, we need to follow these steps:\n\n1. Identify the object with the minimum distance to its neighbor from the `neighbors` table.\n2. Use the `objid` of that object to find the corresponding `specobjid` in the `photoobj` table.\n3. Finally, retrieve the redshift from the `specobj` table using the `specobjid`.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT s.z \nFROM specobj AS s \nJOIN photoobj AS p ON s.bestobjid = p.objid \nWHERE p.objid = (\n    SELECT n.objid \n    FROM neighbors AS n \n    ORDER BY n.distance \n    LIMIT 1\n);\n```\n\n### Explanation:\n- The inner query `(SELECT n.objid FROM neighbors AS n ORDER BY n.distance LIMIT 1)` retrieves the `objid` of the object with the minimum distance to its neighbor.\n- The outer query then joins the `specobj` table with the `photoobj` table to find the redshift (`s.z`) of the object identified by the `objid` from the inner query.", "fixed": false, "try_times": 1, "pred": "SELECT s.z \nFROM specobj AS s \nJOIN photoobj AS p ON s.bestobjid = p.objid \nWHERE p.objid = (\n    SELECT n.objid \n    FROM neighbors AS n \n    ORDER BY n.distance \n    LIMIT 1\n);"}
{"idx": 280, "db_id": "sdss", "query": "What is the redshift of the center object that has the minimal distance to the nearest neighbor", "evidence": "", "extracted_schema": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "type", "ra"], "specobj": ["specobjid", "bestobjid", "mjd", "ra", "dec", "z"]}, "ground_truth": "SELECT s.z from specobj as s join photoobj as p on s.bestobjid = p.objid join neighbors as n on p.objid = n.objid order by n.distance asc limit 1", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "type", "ra"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "mjd", "ra", "dec", "z"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT s.z \nFROM specobj AS s \nJOIN photoobj AS p ON s.bestobjid = p.objid \nWHERE p.objid = (\n    SELECT n.objid \n    FROM neighbors AS n \n    ORDER BY n.distance \n    LIMIT 1\n);", "qa_pairs": "To find the redshift of the center object that has the minimal distance to the nearest neighbor, we need to follow these steps:\n\n1. Identify the object with the minimum distance to its neighbor from the `neighbors` table.\n2. Use the `objid` of that object to find the corresponding `specobjid` in the `photoobj` table.\n3. Finally, retrieve the redshift value from the `specobj` table using the `specobjid`.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT s.z \nFROM specobj AS s \nJOIN photoobj AS p ON s.bestobjid = p.objid \nWHERE p.objid = (\n    SELECT n.objid \n    FROM neighbors AS n \n    ORDER BY n.distance \n    LIMIT 1\n);\n```\n\n### Explanation:\n- The inner query `(SELECT n.objid FROM neighbors AS n ORDER BY n.distance LIMIT 1)` retrieves the `objid` of the object with the minimum distance to its neighbor.\n- The outer query then joins the `specobj` table with the `photoobj` table to find the redshift (`s.z`) of the object identified by the `objid` from the inner query.", "fixed": false, "try_times": 1, "pred": "SELECT s.z \nFROM specobj AS s \nJOIN photoobj AS p ON s.bestobjid = p.objid \nWHERE p.objid = (\n    SELECT n.objid \n    FROM neighbors AS n \n    ORDER BY n.distance \n    LIMIT 1\n);"}
{"idx": 281, "db_id": "sdss", "query": "List all unique run numbers", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": "keep_all", "galspecline": "drop_all", "spplines": "drop_all", "specobj": "drop_all", "photo_type": "drop_all"}, "ground_truth": "select distinct p.run from photoobj as p", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type", "clean", "flags", "rowc", "colc", "cmodelmag_u", "cmodelmag_g", "cmodelmag_r", "ra", "dec", "b", "l", "extinction_r", "mjd", "loadversion", "u", "g", "r", "i", "z"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "segue2primary", "survey"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT DISTINCT run FROM photoobj;", "qa_pairs": "```sql\nSELECT DISTINCT run FROM photoobj;\n```", "fixed": false, "try_times": 1, "pred": "SELECT DISTINCT run FROM photoobj;"}
{"idx": 282, "db_id": "sdss", "query": "Find all run numbers without duplicates", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": "keep_all", "galspecline": "drop_all", "spplines": "drop_all", "specobj": "drop_all", "photo_type": "drop_all"}, "ground_truth": "select distinct p.run from photoobj as p", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type", "clean", "flags", "rowc", "colc", "cmodelmag_u", "cmodelmag_g", "cmodelmag_r", "ra", "dec", "b", "l", "extinction_r", "mjd", "loadversion", "u", "g", "r", "i", "z"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "segue2primary", "survey"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT DISTINCT run FROM photoobj;", "qa_pairs": "To find all unique run numbers from the `photoobj` table, you can use the `DISTINCT` keyword in your SQL query. Here’s the corresponding SQL statement:\n\n```sql\nSELECT DISTINCT run FROM photoobj;\n```\n\nThis query selects all unique values from the `run` column in the `photoobj` table, ensuring that there are no duplicates in the results.", "fixed": false, "try_times": 1, "pred": "SELECT DISTINCT run FROM photoobj;"}
{"idx": 283, "db_id": "sdss", "query": "How many different run number are there", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": "keep_all", "galspecline": "drop_all", "spplines": "drop_all", "specobj": "drop_all", "photo_type": "drop_all"}, "ground_truth": "select count(distinct p.run) from photoobj as p", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type", "clean", "flags", "rowc", "colc", "cmodelmag_u", "cmodelmag_g", "cmodelmag_r", "ra", "dec", "b", "l", "extinction_r", "mjd", "loadversion", "u", "g", "r", "i", "z"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "segue2primary", "survey"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT COUNT(DISTINCT run) AS different_run_numbers FROM photoobj;", "qa_pairs": "To count the number of different run numbers in the `photoobj` table, you can use the `COUNT(DISTINCT ...)` function in SQL. Here is the corresponding SQL query:\n\n```sql\nSELECT COUNT(DISTINCT run) AS different_run_numbers FROM photoobj;\n```\n\nThis query will return the count of unique run numbers present in the `photoobj` table.", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(DISTINCT run) AS different_run_numbers FROM photoobj;"}
{"idx": 284, "db_id": "sdss", "query": "Count all unique run numbers", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": "keep_all", "galspecline": "drop_all", "spplines": "drop_all", "specobj": "drop_all", "photo_type": "drop_all"}, "ground_truth": "select count(distinct p.run) from photoobj as p", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type", "clean", "flags", "rowc", "colc", "cmodelmag_u", "cmodelmag_g", "cmodelmag_r", "ra", "dec", "b", "l", "extinction_r", "mjd", "loadversion", "u", "g", "r", "i", "z"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "segue2primary", "survey"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT COUNT(DISTINCT run) AS unique_run_count FROM photoobj;", "qa_pairs": "To count all unique run numbers from the `photoobj` table, you can use the following SQL query:\n\n```sql\nSELECT COUNT(DISTINCT run) AS unique_run_count FROM photoobj;\n```\n\nThis query selects the count of distinct `run` numbers from the `photoobj` table, providing the total number of unique run numbers.", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(DISTINCT run) AS unique_run_count FROM photoobj;"}
{"idx": 285, "db_id": "sdss", "query": "Find the number of photometric objects grouped by their photometrically observed type name.", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": "keep_all", "galspecline": "drop_all", "spplines": "drop_all", "specobj": "drop_all", "photo_type": ["value", "name", "description"]}, "ground_truth": "select pt.name, count(*) from photoobj as p join photo_type as pt on pt.value = p.type group by pt.name", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type", "clean", "flags", "rowc", "colc", "cmodelmag_u", "cmodelmag_g", "cmodelmag_r", "ra", "dec", "b", "l", "extinction_r", "mjd", "loadversion", "u", "g", "r", "i", "z"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "segue2primary", "survey"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT pt.name, COUNT(po.objid) AS object_count\nFROM photoobj AS po\nJOIN photo_type AS pt ON po.type = pt.value\nGROUP BY pt.name;", "qa_pairs": "To find the number of photometric objects grouped by their photometrically observed type name, you can use the following SQL query. This query will join the `photoobj` table with the `photo_type` table to get the type names and then count the number of objects for each type.\n\n```sql\nSELECT pt.name, COUNT(po.objid) AS object_count\nFROM photoobj AS po\nJOIN photo_type AS pt ON po.type = pt.value\nGROUP BY pt.name;\n```\n\nThis SQL statement does the following:\n- Selects the `name` from the `photo_type` table and counts the `objid` from the `photoobj` table.\n- Joins the `photoobj` table with the `photo_type` table on the condition that the `type` in `photoobj` matches the `value` in `photo_type`.\n- Groups the results by the `name` of the photometric type to get the count of objects for each type.", "fixed": false, "try_times": 1, "pred": "SELECT pt.name, COUNT(po.objid) AS object_count\nFROM photoobj AS po\nJOIN photo_type AS pt ON po.type = pt.value\nGROUP BY pt.name;"}
{"idx": 286, "db_id": "sdss", "query": "How many photometric objects for each photometrically observation type are there?", "evidence": "", "extracted_schema": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "photo_type": ["value", "name", "description"]}, "ground_truth": "select pt.name, count(*) from photoobj as p join photo_type as pt on pt.value = p.type group by pt.name", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "segue2primary", "survey", "programname", "mjd", "plate", "fiberid", "special_target1", "segue2_target1", "segue2_target2", "ancillary_target1", "ra", "dec", "z", "zerr", "zwarning", "class", "subclass", "veldisp", "veldisperr", "loadversion"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT type, COUNT(*) AS object_count \nFROM photoobj \nGROUP BY type;", "qa_pairs": "To count the number of photometric objects for each photometric observation type, we can use the `photoobj` table, which contains the `type` column representing the observation type. We will group the results by the `type` and count the number of objects for each type.\n\nHere is the SQL query to achieve that:\n\n```sql\nSELECT type, COUNT(*) AS object_count \nFROM photoobj \nGROUP BY type;\n```\n\nThis query selects the `type` of photometric observation and counts the number of entries (photometric objects) for each type, grouping the results by the `type`.", "fixed": false, "try_times": 1, "pred": "SELECT type, COUNT(*) AS object_count \nFROM photoobj \nGROUP BY type;"}
{"idx": 287, "db_id": "sdss", "query": "Find right ascension, declination and photometric type class of equivalent width estimates of galactic-stars from these spectroscopic objects.", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "ra", "dec", "type", "mode", "clean"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "class", "ra", "dec", "z", "mjd"], "photo_type": ["value", "name", "description"]}, "ground_truth": "select p.ra, p.dec, p.type from spplines as sp join specobj as s on sp.specobjid = s.specobjid join photoobj as p on p.objid = s.bestobjid", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "mode", "type", "clean", "ra", "dec"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "mjd", "ra", "dec", "z", "class"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT \n    p.ra, \n    p.dec, \n    pt.name AS photometric_type\nFROM \n    specobj AS s\nJOIN \n    photoobj AS p ON s.bestobjid = p.objid\nJOIN \n    photo_type AS pt ON p.type = pt.value\nWHERE \n    s.class = 'GALAXY' OR s.class = 'STAR';", "qa_pairs": "To find the right ascension, declination, and photometric type class of equivalent width estimates of galactic stars from the spectroscopic objects, we need to join the relevant tables based on their relationships. Specifically, we will join the `specobj`, `photoobj`, and `photo_type` tables to get the required information.\n\nHere's the SQL query that accomplishes this:\n\n```sql\nSELECT \n    p.ra, \n    p.dec, \n    pt.name AS photometric_type\nFROM \n    specobj AS s\nJOIN \n    photoobj AS p ON s.bestobjid = p.objid\nJOIN \n    photo_type AS pt ON p.type = pt.value\nWHERE \n    s.class = 'GALAXY' OR s.class = 'STAR';\n```\n\n### Explanation:\n1. **SELECT Clause**: We select the right ascension (`p.ra`), declination (`p.dec`), and the name of the photometric type (`pt.name`).\n2. **FROM Clause**: We start with the `specobj` table (aliased as `s`).\n3. **JOINs**:\n   - We join `photoobj` (aliased as `p`) on the condition that `s.bestobjid` matches `p.objid`.\n   - We join `photo_type` (aliased as `pt`) on the condition that `p.type` matches `pt.value`.\n4. **WHERE Clause**: We filter the results to include only those spectroscopic objects that are classified as either 'GALAXY' or 'STAR'.\n\nThis query will return the desired information about the right ascension, declination, and photometric type class for the specified classes of spectroscopic objects.", "fixed": false, "try_times": 1, "pred": "SELECT \n    p.ra, \n    p.dec, \n    pt.name AS photometric_type\nFROM \n    specobj AS s\nJOIN \n    photoobj AS p ON s.bestobjid = p.objid\nJOIN \n    photo_type AS pt ON p.type = pt.value\nWHERE \n    s.class = 'GALAXY' OR s.class = 'STAR';"}
{"idx": 288, "db_id": "sdss", "query": "Fetch the right ascension and declination of spectroscopic objects those have equivalent width estimates of galactic-stars", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "ra", "dec", "type", "mode", "clean"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "ra", "dec", "class", "z", "zerr"], "photo_type": "drop_all"}, "ground_truth": "select p.ra, p.dec, p.type from spplines as sp join specobj as s on sp.specobjid = s.specobjid join photoobj as p on p.objid = s.bestobjid", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "mode", "type", "clean", "ra", "dec"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "zerr", "class"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT ra, dec \nFROM specobj \nWHERE class IN ('GALAXY', 'STAR');", "qa_pairs": "To fetch the right ascension and declination of spectroscopic objects that have equivalent width estimates of galactic stars, we need to join the relevant tables based on their relationships. However, the provided schema does not explicitly mention a direct relationship between equivalent width estimates and the tables. \n\nAssuming that the equivalent width estimates are represented in the `specobj` table (as it contains the classification of objects), we can filter for those classified as 'GALAXY' or 'STAR'. \n\nHere’s the SQL query to achieve that:\n\n```sql\nSELECT ra, dec \nFROM specobj \nWHERE class IN ('GALAXY', 'STAR');\n```\n\nThis query selects the right ascension (`ra`) and declination (`dec`) from the `specobj` table where the `class` is either 'GALAXY' or 'STAR', which we assume corresponds to the equivalent width estimates of galactic stars.", "fixed": false, "try_times": 1, "pred": "SELECT ra, dec \nFROM specobj \nWHERE class IN ('GALAXY', 'STAR');"}
{"idx": 289, "db_id": "sdss", "query": "Find the object id and photometric observation type of photometric objects whose right ascension is greater than 100 and declination is less than 100.", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "type", "ra", "dec", "mode", "clean"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": "drop_all", "photo_type": "drop_all"}, "ground_truth": "select p.objid, pt.name from photoobj as p join photo_type as pt on p.type = pt.value where p.ra > 100 and p.dec < 100", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "mode", "type", "clean", "ra", "dec"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "segue2primary", "survey"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT objid, type FROM photoobj WHERE ra > 100 AND dec < 100", "qa_pairs": "```sql\nSELECT objid, type FROM photoobj WHERE ra > 100 AND dec < 100\n```", "fixed": false, "try_times": 1, "pred": "SELECT objid, type FROM photoobj WHERE ra > 100 AND dec < 100"}
{"idx": 290, "db_id": "sdss", "query": "Retrieve the photometric object id and type name of corresponding photometric observation from the objects with the right ascension over 100 and declination below 100.", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "type", "ra", "dec", "mode", "clean"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": "drop_all", "photo_type": ["value", "name", "description"]}, "ground_truth": "select p.objid, pt.name from photoobj as p join photo_type as pt on p.type = pt.value where p.ra > 100 and p.dec < 100", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "mode", "type", "clean", "ra", "dec"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "segue2primary", "survey"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT photoobj.objid, photo_type.name\nFROM photoobj\nJOIN photo_type ON photoobj.type = photo_type.value\nWHERE photoobj.ra > 100 AND photoobj.dec < 100;", "qa_pairs": "To retrieve the photometric object id and type name of corresponding photometric observations from the `photoobj` table where the right ascension (`ra`) is over 100 and the declination (`dec`) is below 100, you will need to join the `photoobj` table with the `photo_type` table based on the `type` field. Here is the SQL query that accomplishes this:\n\n```sql\nSELECT photoobj.objid, photo_type.name\nFROM photoobj\nJOIN photo_type ON photoobj.type = photo_type.value\nWHERE photoobj.ra > 100 AND photoobj.dec < 100;\n```\n\nThis query selects the `objid` from the `photoobj` table and the corresponding `name` from the `photo_type` table, filtering the results based on the specified conditions for `ra` and `dec`.", "fixed": false, "try_times": 1, "pred": "SELECT photoobj.objid, photo_type.name\nFROM photoobj\nJOIN photo_type ON photoobj.type = photo_type.value\nWHERE photoobj.ra > 100 AND photoobj.dec < 100;"}
{"idx": 291, "db_id": "sdss", "query": "Find the photometric object id, right ascension and declination of corresponding spectroscopic objects, from which it has emission line estimates of galaxies.", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "ra", "dec", "type", "mode", "clean"], "galspecline": ["specobjid"], "spplines": "drop_all", "specobj": ["specobjid", "ra", "dec", "z", "class", "subclass"], "photo_type": "drop_all"}, "ground_truth": "select p.objid, p.ra, p.dec from photoobj as p join specobj as s on s.bestobjid = p.objid join galspecline as g on s.specobjid = g.specobjid", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "mode", "type", "clean", "ra", "dec"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.objid, p.ra, p.dec\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nJOIN galspecline AS g ON s.specobjid = g.specobjid\nWHERE s.class = 'GALAXY';", "qa_pairs": "To find the photometric object id, right ascension, and declination of corresponding spectroscopic objects that have emission line estimates of galaxies, we need to join the relevant tables based on their relationships. Specifically, we will join the `photoobj`, `specobj`, and `galspecline` tables.\n\nHere's the SQL query that accomplishes this:\n\n```sql\nSELECT p.objid, p.ra, p.dec\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nJOIN galspecline AS g ON s.specobjid = g.specobjid\nWHERE s.class = 'GALAXY';\n```\n\n### Explanation:\n1. **SELECT Clause**: We select the `objid`, `ra`, and `dec` from the `photoobj` table.\n2. **FROM Clause**: We start with the `photoobj` table (aliased as `p`).\n3. **JOIN Clauses**:\n   - We join the `specobj` table (aliased as `s`) on the condition that the `objid` from `photoobj` matches the `bestobjid` from `specobj`.\n   - We then join the `galspecline` table (aliased as `g`) on the condition that the `specobjid` from `specobj` matches the `specobjid` from `galspecline`.\n4. **WHERE Clause**: We filter the results to include only those spectroscopic objects that are classified as 'GALAXY'.\n\nThis query will return the desired information about photometric objects associated with galaxies that have emission line estimates.", "fixed": false, "try_times": 1, "pred": "SELECT p.objid, p.ra, p.dec\nFROM photoobj AS p\nJOIN specobj AS s ON p.objid = s.bestobjid\nJOIN galspecline AS g ON s.specobjid = g.specobjid\nWHERE s.class = 'GALAXY';"}
{"idx": 292, "db_id": "sdss", "query": "What is the best photometric object to the corresponding spectroscopic object that has emission line estimates of galaxies? Return me the object id, right ascension and declination of the best object.", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": ["objid", "ra", "dec", "run", "rerun", "field"], "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class"], "photo_type": "drop_all"}, "ground_truth": "select p.objid, p.ra, p.dec from photoobj as p join specobj as s on s.bestobjid = p.objid join galspecline as g on s.specobjid = g.specobjid", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "ra", "dec"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "ra", "dec", "z", "class"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT p.objid, p.ra, p.dec\nFROM specobj AS s\nJOIN photoobj AS p ON s.bestobjid = p.objid\nWHERE s.class = 'GALAXY';", "qa_pairs": "To find the best photometric object corresponding to spectroscopic objects that have emission line estimates of galaxies, we need to join the relevant tables and filter based on the spectroscopic class. The `specobj` table contains the spectroscopic objects, and we will filter for those classified as 'GALAXY'. We will then join this with the `photoobj` table to get the best photometric object.\n\nHere is the SQL query to achieve this:\n\n```sql\nSELECT p.objid, p.ra, p.dec\nFROM specobj AS s\nJOIN photoobj AS p ON s.bestobjid = p.objid\nWHERE s.class = 'GALAXY';\n```\n\nThis query selects the object ID, right ascension, and declination of the best photometric object for spectroscopic objects classified as galaxies.", "fixed": false, "try_times": 1, "pred": "SELECT p.objid, p.ra, p.dec\nFROM specobj AS s\nJOIN photoobj AS p ON s.bestobjid = p.objid\nWHERE s.class = 'GALAXY';"}
{"idx": 293, "db_id": "sdss", "query": "Find spectroscopic objects of equivalent width estimates of galactic-stars from these spectroscopic objects.", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": "drop_all", "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "class", "subclass", "z", "zerr", "veldisp"], "photo_type": "drop_all"}, "ground_truth": "select sp.specobjid from spplines as sp join specobj as s on sp.specobjid = s.specobjid", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "z", "zerr", "class", "subclass", "veldisp"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT DISTINCT so.specobjid\nFROM specobj AS so\nWHERE so.class IN ('GALAXY', 'STAR');", "qa_pairs": "To find spectroscopic objects of equivalent width estimates of galactic stars from the provided database schema, we need to focus on the `specobj` table, which contains the classification of the objects. We will filter for objects classified as 'GALAXY' or 'STAR' and then join with the `galspecline` and `spplines` tables to get the relevant spectroscopic objects.\n\nHere is the SQL query that accomplishes this:\n\n```sql\nSELECT DISTINCT so.specobjid\nFROM specobj AS so\nWHERE so.class IN ('GALAXY', 'STAR');\n```\n\nThis query selects distinct spectroscopic object IDs from the `specobj` table where the class is either 'GALAXY' or 'STAR', which corresponds to the equivalent width estimates of galactic stars. \n\nIf you need to include additional details or join with other tables for more specific information, please provide further context or requirements.", "fixed": false, "try_times": 1, "pred": "SELECT DISTINCT so.specobjid\nFROM specobj AS so\nWHERE so.class IN ('GALAXY', 'STAR');"}
{"idx": 294, "db_id": "sdss", "query": "What is the equivalent width estimates of galactic-stars of spectroscopic objects", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": "keep_all", "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "bestobjid", "class", "subclass", "z", "zerr"], "photo_type": "drop_all"}, "ground_truth": "select sp.specobjid from spplines as sp join specobj as s on sp.specobjid = s.specobjid", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type", "clean", "flags", "rowc", "colc", "cmodelmag_u", "cmodelmag_g", "cmodelmag_r", "ra", "dec", "b", "l", "extinction_r", "mjd", "loadversion", "u", "g", "r", "i", "z"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "z", "zerr", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT specobj.specobjid, specobj.class, specobj.subclass\nFROM specobj\nWHERE specobj.class = 'STAR';", "qa_pairs": "To retrieve the equivalent width estimates of galactic stars from the spectroscopic objects, we need to join the relevant tables based on their relationships. However, the provided schema does not explicitly mention an \"equivalent width\" field. Assuming that the equivalent width estimates are derived from the `specobj` table where the class is 'STAR', we can formulate the SQL query accordingly.\n\nHere's how you can write the SQL query:\n\n```sql\nSELECT specobj.specobjid, specobj.class, specobj.subclass\nFROM specobj\nWHERE specobj.class = 'STAR';\n```\n\nThis query selects the `specobjid`, `class`, and `subclass` of all spectroscopic objects that are classified as stars. If there is a specific field for equivalent width in another table that relates to stars, you would need to join that table as well. However, based on the provided schema, this is the best approximation we can make without additional information.", "fixed": false, "try_times": 1, "pred": "SELECT specobj.specobjid, specobj.class, specobj.subclass\nFROM specobj\nWHERE specobj.class = 'STAR';"}
{"idx": 295, "db_id": "sdss", "query": "How many spectroscopic objects of equivalent width estimates of galactic-stars from these spectroscopic objects are there?", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": "drop_all", "galspecline": "keep_all", "spplines": "keep_all", "specobj": ["specobjid", "bestobjid", "class", "subclass", "z", "zerr"], "photo_type": "drop_all"}, "ground_truth": "select count(sp.specobjid) from spplines as sp join specobj as s on sp.specobjid = s.specobjid", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "z", "zerr", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT COUNT(*) \nFROM specobj \nWHERE class IN ('GALAXY', 'STAR');", "qa_pairs": "To answer the question regarding the number of spectroscopic objects of equivalent width estimates of galactic stars, we need to analyze the provided database schema. \n\nFrom the schema, we can see that the `specobj` table contains a column named `class`, which includes classifications such as 'GALAXY', 'STAR', and 'QSO'. To find the number of spectroscopic objects classified as 'GALAXY' or 'STAR', we can use a simple `SELECT` statement with a `COUNT` function.\n\nHere’s the SQL query that will give us the desired count:\n\n```sql\nSELECT COUNT(*) \nFROM specobj \nWHERE class IN ('GALAXY', 'STAR');\n```\n\nThis query counts all entries in the `specobj` table where the `class` is either 'GALAXY' or 'STAR', which corresponds to the equivalent width estimates of galactic stars.", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(*) \nFROM specobj \nWHERE class IN ('GALAXY', 'STAR');"}
{"idx": 296, "db_id": "sdss", "query": "Count the number of spectroscopic objects that has equivalent width estimates of galactic-stars.", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": "drop_all", "galspecline": "drop_all", "spplines": "drop_all", "specobj": ["specobjid", "class", "subclass", "bestobjid", "survey", "mjd"], "photo_type": "drop_all"}, "ground_truth": "select count(sp.specobjid) from spplines as sp join specobj as s on sp.specobjid = s.specobjid", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "survey", "mjd", "class", "subclass"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT COUNT(*) \nFROM specobj \nWHERE class IN ('GALAXY', 'STAR');", "qa_pairs": "To count the number of spectroscopic objects that have equivalent width estimates of galactic stars, we need to identify the relevant tables and their relationships. Based on the provided schema, we can infer that the `specobj` table contains the classification of spectroscopic objects, and we need to filter for those classified as 'GALAXY' or 'STAR'.\n\nHowever, the schema does not explicitly mention equivalent width estimates, so we will assume that the relevant data is stored in the `galspecline` or `spplines` tables, which are linked to the `specobj` table.\n\nAssuming that we want to count the number of spectroscopic objects classified as 'GALAXY' or 'STAR', the SQL query would look like this:\n\n```sql\nSELECT COUNT(*) \nFROM specobj \nWHERE class IN ('GALAXY', 'STAR');\n```\n\nThis query counts all entries in the `specobj` table where the `class` is either 'GALAXY' or 'STAR', which would represent the spectroscopic objects with equivalent width estimates of galactic stars. \n\nIf there are specific conditions or additional tables that need to be considered for equivalent width estimates, please provide that information for a more accurate query.", "fixed": false, "try_times": 1, "pred": "SELECT COUNT(*) \nFROM specobj \nWHERE class IN ('GALAXY', 'STAR');"}
{"idx": 297, "db_id": "sdss", "query": "Find everything about spectroscopic objects and everything about emission line estimates of galaxies from these spectroscopic objects.", "evidence": "", "extracted_schema": {"specobj": "keep_all", "galspecline": "keep_all", "neighbors": "drop_all", "photoobj": "drop_all", "spplines": "drop_all", "photo_type": "drop_all"}, "ground_truth": "select * from specobj as s join galspecline as g on s.specobjid = g.specobjid", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "segue2primary", "survey", "programname", "mjd", "plate", "fiberid", "special_target1", "segue2_target1", "segue2_target2", "ancillary_target1", "ra", "dec", "z", "zerr", "zwarning", "class", "subclass", "veldisp", "veldisperr", "loadversion"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT *\nFROM specobj AS so\nJOIN galspecline AS g ON so.specobjid = g.specobjid\nWHERE so.class = 'GALAXY';", "qa_pairs": "To find everything about spectroscopic objects and everything about emission line estimates of galaxies from these spectroscopic objects, we need to join the relevant tables based on their relationships. Specifically, we will join the `specobj` table with the `galspecline` table to get the emission line estimates for galaxies.\n\nHere’s the SQL query that accomplishes this:\n\n```sql\nSELECT *\nFROM specobj AS so\nJOIN galspecline AS g ON so.specobjid = g.specobjid\nWHERE so.class = 'GALAXY';\n```\n\n### Explanation:\n- `SELECT *`: This selects all columns from the resulting joined tables.\n- `FROM specobj AS so`: This specifies the `specobj` table and gives it an alias `so`.\n- `JOIN galspecline AS g ON so.specobjid = g.specobjid`: This joins the `galspecline` table with the `specobj` table on the `specobjid` column, which is common to both tables.\n- `WHERE so.class = 'GALAXY'`: This filters the results to include only those spectroscopic objects that are classified as galaxies.\n\nThis query will return all the details about spectroscopic objects that are classified as galaxies along with their emission line estimates.", "fixed": false, "try_times": 1, "pred": "SELECT *\nFROM specobj AS so\nJOIN galspecline AS g ON so.specobjid = g.specobjid\nWHERE so.class = 'GALAXY';"}
{"idx": 298, "db_id": "sdss", "query": "Show me everything about emission line estimates of galaxies of corresponding spectroscopic objects", "evidence": "", "extracted_schema": {"neighbors": "drop_all", "photoobj": "drop_all", "galspecline": "keep_all", "spplines": "keep_all", "specobj": "keep_all", "photo_type": "drop_all"}, "ground_truth": "select * from specobj as s join galspecline as g on s.specobjid = g.specobjid", "difficulty": "sdss", "chosen_db_schem_dict": {"neighbors": ["objid", "neighborobjid", "distance", "type", "neighbortype", "mode"], "photoobj": ["objid", "run", "rerun", "field", "mode", "type"], "galspecline": ["specobjid"], "spplines": ["specobjid"], "specobj": ["specobjid", "bestobjid", "plateid", "scienceprimary", "segue2primary", "survey", "programname", "mjd", "plate", "fiberid", "special_target1", "segue2_target1", "segue2_target2", "ancillary_target1", "ra", "dec", "z", "zerr", "zwarning", "class", "subclass", "veldisp", "veldisperr", "loadversion"], "photo_type": ["value", "name", "description"]}, "pruned": true, "final_sql": "SELECT *\nFROM specobj AS so\nJOIN galspecline AS gsc ON so.specobjid = gsc.specobjid\nWHERE so.class = 'GALAXY';", "qa_pairs": "To retrieve everything about emission line estimates of galaxies from the corresponding spectroscopic objects, we need to join the relevant tables based on their relationships. The `specobj` table contains information about spectroscopic objects, and we need to filter for those that are classified as galaxies. The `galspecline` table is likely where emission line estimates are stored.\n\nHere’s the SQL query that accomplishes this:\n\n```sql\nSELECT *\nFROM specobj AS so\nJOIN galspecline AS gsc ON so.specobjid = gsc.specobjid\nWHERE so.class = 'GALAXY';\n```\n\n### Explanation:\n- `SELECT *`: This selects all columns from the resulting joined tables.\n- `FROM specobj AS so`: This specifies the `specobj` table and gives it an alias `so`.\n- `JOIN galspecline AS gsc ON so.specobjid = gsc.specobjid`: This joins the `galspecline` table on the `specobjid` field, which is common to both tables.\n- `WHERE so.class = 'GALAXY'`: This filters the results to include only those records where the `class` in the `specobj` table is 'GALAXY', ensuring we only get emission line estimates for galaxies.\n\nThis query will return all relevant information about galaxies and their emission line estimates from the database.", "fixed": false, "try_times": 1, "pred": "SELECT *\nFROM specobj AS so\nJOIN galspecline AS gsc ON so.specobjid = gsc.specobjid\nWHERE so.class = 'GALAXY';"}
