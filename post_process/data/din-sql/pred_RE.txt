SELECT MAX((T1.Free Meal Count (K-12) / T1.Enrollment (K-12)) * 100) AS Highest_Eligible_Free_RateFROM frpm AS T1INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCodeWHERE T1.County Name = 'Alameda'
SELECT frpm.School Name, (frpm.Free Meal Count (Ages 5-17) / frpm.Enrollment (Ages 5-17)) AS Eligible_Free_RateFROM frpm JOIN schools ON frpm.CDSCode = schools.CDSCodeWHERE frpm.School Type = 'Continuation'ORDER BY Eligible_Free_Rate ASCLIMIT 3
SELECT S.Zip FROM frpm AS F INNER JOIN schools AS S ON F.CDSCode = S.CDSCode WHERE F.Charter School (Y/N) = 1 AND F.County Name = 'Fresno County Office of Education'
SELECT S.MailStreet FROM schools AS S INNER JOIN frpm AS F ON S.CDSCode = F.CDSCode WHERE F.FRPM Count (K-12) = (SELECT MAX(FRPM Count (K-12)) FROM frpm) This query correctly retrieves the unabbreviated mailing address of the school with the highest FRPM count for K-12 students.
SELECT schools.Phone FROM frpm INNER JOIN schools ON frpm.CDSCode = schools.CDSCode WHERE frpm.Charter School (Y/N) = 1 AND schools.OpenDate > '2000-01-01'
SELECT COUNT(*) FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T1.AvgScrMath < 400 AND T2.Virtual = 'F'
SELECT S.School Name, S.District Name, S.County NameFROM satscores AS T1INNER JOIN frpm AS S ON T1.cds = S.CDSCodeWHERE T1.NumTstTakr > 500 AND S.Magnet = 1 This query now correctly references the appropriate columns from the `frpm` table for the school names, district names, and county names.
SELECT s.Phone FROM satscores AS ss INNER JOIN schools AS s ON ss.cds = s.CDSCode WHERE ss.NumGE1500 > 0 ORDER BY ss.NumTstTakr DESC LIMIT 1
SELECT SUM(NumTstTakr) FROM satscores WHERE cds IN (SELECT CDSCode FROM frpm WHERE FRPM Count (K-12) = (SELECT MAX(FRPM Count (K-12)) FROM frpm))
SELECT COUNT(*) FROM satscores AS S INNER JOIN schools AS Sch ON S.cds = Sch.CDSCode INNER JOIN frpm AS F ON Sch.CDSCode = F.CDSCode WHERE S.AvgScrMath > 560 AND F.Charter Funding Type = 'Directly funded'
SELECT FRPM Count (Ages 5-17) FROM frpm WHERE CDSCode = (SELECT cds FROM satscores WHERE AvgScrRead = (SELECT MAX(AvgScrRead) FROM satscores))
SELECT CDSCode FROM frpm WHERE (Enrollment (K-12) + Enrollment (Ages 5-17)) > 500;
SELECT MAX(frpm.Percent (%) Eligible Free (Ages 5-17))FROM satscoresJOIN frpm ON satscores.cds = frpm.CDSCodeJOIN schools ON frpm.CDSCode = schools.CDSCodeWHERE (satscores.NumGE1500 * 1.0 / satscores.NumTstTakr) > 0.3
SELECT S.Phone FROM ( SELECT cds, (NumGE1500 * 1.0 / NumTstTakr) AS ExcellenceRate FROM satscores WHERE NumTstTakr > 0  -- To avoid division by zero) AS T JOIN schools AS S ON T.cds = S.CDSCode ORDER BY T.ExcellenceRate DESC LIMIT 3
SELECT T2.NCESSchool, T1.Enrollment (Ages 5-17) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T1.Enrollment (Ages 5-17) DESC LIMIT 5 This query now provides the NCES school identification number along with the enrollment numbers, which can be useful for understanding the results.
SELECT T1.District AS District, AVG(T2.AvgScrRead) AS AverageReadingScoreFROM schools AS T1INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cdsWHERE T1.StatusType = 'Active'GROUP BY T1.DistrictORDER BY AverageReadingScore DESCLIMIT 1
SELECT COUNT(*) FROM satscores AS S INNER JOIN schools AS Sch ON S.cds = Sch.CDSCode WHERE Sch.StatusType = 'Merged' AND Sch.County = 'Alameda' AND S.NumTstTakr < 100
SELECT frpm.Charter School NumberFROM satscoresINNER JOIN schools ON satscores.cds = schools.CDSCodeINNER JOIN frpm ON frpm.CDSCode = schools.CDSCodeWHERE satscores.AvgScrWrite = 499
SELECT COUNT(*) FROM satscores AS S INNER JOIN frpm AS F ON S.cds = F.CDSCode INNER JOIN schools AS Sch ON F.CDSCode = Sch.CDSCode WHERE F.County_Name = 'Contra Costa' AND Sch.FundingType = 'Directly funded' AND S.NumTstTakr <= 250
SELECT S.Phone FROM satscores AS SS INNER JOIN schools AS S ON SS.cds = S.CDSCode WHERE SS.AvgScrMath = (SELECT MAX(AvgScrMath) FROM satscores)
SELECT COUNT(*) FROM frpm WHERE County Name = 'Amador' AND Low Grade = '9' AND High Grade = '12'
SELECT COUNT(*) FROM frpm AS F INNER JOIN schools AS S ON F.CDSCode = S.CDSCode WHERE F.County Name = 'Los Angeles' AND F.Free Meal Count (K-12) > 500 AND F.FRPM Count (K-12) < 700
SELECT T1.sname, T1.NumTstTakr FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.County = 'Contra Costa' ORDER BY T1.NumTstTakr DESC LIMIT 1
SELECT frpm.School Name, schools.Street, schools.City, schools.Zip, schools.StateFROM frpm INNER JOIN schools ON frpm.CDSCode = schools.CDSCodeWHERE ABS(frpm.Enrollment (K-12) - frpm.Enrollment (Ages 5-17)) > 30
SELECT s.School FROM frpm AS f JOIN schools AS s ON f.CDSCode = s.CDSCode JOIN satscores AS ss ON ss.cds = s.CDSCode WHERE f.Percent (%) Eligible Free (K-12) > 0.1 AND ss.NumGE1500 >= 1
SELECT S.School, S.FundingTypeFROM schools AS SJOIN satscores AS SS ON S.CDSCode = SS.cdsWHERE S.County = 'Riverside'GROUP BY S.SchoolHAVING AVG(SS.AvgScrMath) > 400
SELECT s.School AS School_Name, s.Street || ', ' || s.City || ', ' || s.Zip || ', ' || s.State AS Full_Communication_AddressFROM frpm AS fINNER JOIN schools AS s ON f.CDSCode = s.CDSCodeWHERE f.School_Type = 'High Schools (Public)' AND f.FRPM_Count_Ages_5_17 > 800 AND s.County = 'Monterey' So the final corrected SQL query is:SELECT s.School AS School_Name, s.Street || ', ' || s.City || ', ' || s.Zip || ', ' || s.State AS Full_Communication_AddressFROM frpm AS fINNER JOIN schools AS s ON f.CDSCode = s.CDSCodeWHERE f.School Type = 'High Schools (Public)' AND f.FRPM Count (Ages 5-17) > 800 AND s.County = 'Monterey'
SELECT s.School AS school_name, sa.AvgScrWrite AS avg_write_score, s.Phone AS communication_numberFROM satscores AS sa INNER JOIN schools AS s ON sa.cds = s.CDSCodeWHERE s.OpenDate > '1991-01-01' OR s.ClosedDate < '2000-01-01'
SELECT s.School, s.DOCTypeFROM frpm AS fJOIN schools AS s ON f.CDSCode = s.CDSCodeWHERE f.FundingType = 'Locally funded' AND (f.Enrollment (K-12) - f.Enrollment (Ages 5-17)) > ( SELECT  AVG(f2.Enrollment (K-12) - f2.Enrollment (Ages 5-17)) FROM  frpm AS f2 WHERE  f2.FundingType = 'Locally funded' )
SELECT s.OpenDate FROM frpm AS f JOIN schools AS s ON f.CDSCode = s.CDSCode WHERE f.Low Grade = 'K' AND f.High Grade = '12' AND f.Enrollment (K-12) = (SELECT MAX(Enrollment (K-12)) FROM frpm WHERE Low Grade = 'K' AND High Grade = '12')
SELECT S.City, F.Enrollment (K-12)FROM frpm AS FINNER JOIN schools AS S ON F.CDSCode = S.CDSCodeORDER BY F.Enrollment (K-12) ASCLIMIT 5
SELECT Eligible_Free_RateFROM ( SELECT  Free Meal Count (K-12) / Enrollment (K-12) AS Eligible_Free_Rate FROM frpm ORDER BY Enrollment (K-12) DESC LIMIT 11) AS TopSchoolsORDER BY Eligible_Free_RateLIMIT 2 OFFSET 8;  -- OFFSET 8 to get the 10th and 11th records
SELECT T1.School Name, (T1.FRPM Count (K-12) / T1.Enrollment (K-12)) AS Eligible_Free_Reduced_Price_Meal_RateFROM frpm AS T1INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCodeWHERE T2.SOC = 66ORDER BY T1.FRPM Count (K-12) DESCLIMIT 5
SELECT T1.School Name, T2.Website FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.Free Meal Count (Ages 5-17) BETWEEN 1900 AND 2000
SELECT (Free Meal Count (Ages 5-17) / Enrollment (Ages 5-17)) AS Free_RateFROM frpm WHERE CDSCode = (SELECT CDSCode FROM schools WHERE AdmFName1 = 'Kacey' AND AdmLName1 = 'Gibson')
SELECT AdmEmail1 FROM schools WHERE CDSCode = (SELECT CDSCode   FROM frpm   WHERE Charter School (Y/N) = 1   AND Enrollment (K-12) = (SELECT MIN(Enrollment (K-12)) FROM frpm WHERE Charter School (Y/N) = 1))
SELECT AdmFName1 || ' ' || AdmLName1 AS FullName FROM schools WHERE CDSCode IN (SELECT cds FROM satscores WHERE NumGE1500 = (SELECT MAX(NumGE1500) FROM satscores))
SELECT S.Street, S.City, S.Zip, S.State FROM satscores AS T JOIN schools AS S ON T.cds = S.CDSCode ORDER BY (T.NumGE1500 * 1.0 / T.NumTstTakr) ASC LIMIT 1
SELECT T1.Website FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.County = 'Los Angeles' AND T2.NumTstTakr BETWEEN 2000 AND 3000
SELECT AVG(T1.NumTstTakr) FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.County = 'Fresno' AND T2.OpenDate BETWEEN '1980-01-01' AND '1980-12-31'
SELECT s.Phone FROM schools s JOIN satscores sa ON s.CDSCode = sa.cds WHERE s.District = 'Fresno Unified' ORDER BY sa.AvgScrRead ASC LIMIT 1
SELECT T1.School Name AS SchoolName, T2.AvgScrRead AS AverageReadingScoreFROM schools AS T1INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cdsWHERE T1.Virtual = 'F'ORDER BY T2.AvgScrRead DESCLIMIT 5
SELECT schools.EdOpsName FROM schools JOIN satscores ON schools.CDSCode = satscores.cds WHERE satscores.AvgScrMath = (SELECT MAX(AvgScrMath) FROM satscores)This query correctly retrieves the type of education offered in the school that scored the highest average in Math.
SELECT T1.AvgScrMath, T2.CountyFROM satscores AS T1JOIN schools AS T2 ON T1.cds = T2.CDSCodeWHERE (T1.AvgScrMath + T1.AvgScrRead + T1.AvgScrWrite) = ( SELECT MIN(T3.AvgScrMath + T3.AvgScrRead + T3.AvgScrWrite) FROM satscores AS T3)
SELECT T1.AvgScrWrite, T2.City FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T1.NumGE1500 = (SELECT MAX(NumGE1500) FROM satscores)
SELECT S.School, AVG(SA.AvgScrWrite) AS Average_Writing_ScoreFROM schools AS S INNER JOIN satscores AS SA ON S.CDSCode = SA.cds WHERE S.AdmFName1 = 'Ricci' AND S.AdmLName1 = 'Ulrich'GROUP BY S.School
SELECT T1.School, T2.Enrollment (K-12) FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.DOC = '31' ORDER BY T2.Enrollment (K-12) DESC LIMIT 1
SELECT COUNT(*) / 12.0 AS monthly_average_schools_openedFROM schoolsWHERE strftime('%Y', OpenDate) = '1980' AND County = 'Alameda' AND DOC = '52';
SELECT (SELECT COUNT(*) FROM schools WHERE DOC = 54 AND County = 'Orange') * 1.0 / (SELECT COUNT(*) FROM schools WHERE DOC = 52 AND County = 'Orange') AS ratio
SELECT School, ClosedDate FROM schools WHERE County = ( SELECT County FROM schools WHERE StatusType = 'Closed' GROUP BY County ORDER BY COUNT(*) DESC LIMIT 1) AND StatusType = 'Closed';
SELECT s.School, s.Street FROM satscores AS ss JOIN schools AS s ON ss.cds = s.CDSCode WHERE ss.AvgScrMath = (SELECT AvgScrMath  FROM satscores  ORDER BY AvgScrMath DESC  LIMIT 1 OFFSET 5)
SELECT S.MailStreet, SA.sname FROM satscores AS SA INNER JOIN schools AS S ON SA.cds = S.CDSCode WHERE SA.AvgScrRead = (SELECT MIN(AvgScrRead) FROM satscores)
SELECT COUNT(*) FROM satscores AS s INNER JOIN schools AS sch ON s.cds = sch.CDSCode WHERE (s.AvgScrRead + s.AvgScrMath + s.AvgScrWrite) >= 1500 AND sch.MailCity = 'Lakeport'
SELECT SUM(T1.NumTstTakr) FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.MailCity = 'Fresno'
SELECT School, MailZip FROM schools WHERE AdmFName1 = 'Avetik' AND AdmLName1 = 'Atoian'
SELECT (SELECT COUNT(*) FROM schools WHERE County = 'Colusa' AND MailState = 'CA') * 1.0 / (SELECT COUNT(*) FROM schools WHERE County = 'Humboldt' AND MailState = 'CA') AS ratio
SELECT COUNT(*) FROM schools WHERE StatusType = 'Active' AND County = 'CA' AND District = 'San Joaquin';
SELECT s.Phone, s.Ext FROM schools s INNER JOIN satscores ss ON s.CDSCode = ss.cds WHERE ss.AvgScrWrite = ( SELECT AvgScrWrite FROM satscores ORDER BY AvgScrWrite DESC LIMIT 1 OFFSET 332)
SELECT School, Phone, Ext FROM schools WHERE Zip = '95203-3704';
SELECT DISTINCT Website FROM schools WHERE (AdmFName1 = 'Mike' AND AdmLName1 = 'Larson') OR (AdmFName1 = 'Dante' AND AdmLName1 = 'Alvarez');
SELECT S.Website FROM schools AS S INNER JOIN frpm AS F ON S.CDSCode = F.CDSCode WHERE S.Virtual = 'P' AND S.Charter = 1 AND F.County Name = 'San Joaquin'
SELECT COUNT(*) FROM schools WHERE Charter = 1 AND City = 'Hickman' AND DOC = 52
SELECT COUNT(*) FROM frpm AS F INNER JOIN schools AS S ON F.CDSCode = S.CDSCode WHERE S.Charter = 0 AND S.County = 'Los Angeles' AND (F.Free Meal Count (K-12) * 100.0 / F.Enrollment (K-12)) < 0.18
SELECT s.AdmFName1 AS FirstName, s.AdmLName1 AS LastName, s.School AS SchoolName, s.City AS CityFROM schools AS sINNER JOIN frpm AS f ON s.CDSCode = f.CDSCodeWHERE s.Charter = 1 AND s.CharterNum = '00D2'
`SELECT COUNT(*) FROM schools WHERE MailCity = 'Hickman' AND CharterNum = '00D4';`
SELECT (COUNT(CASE WHEN s.FundingType = 'Locally funded' THEN 1 END) * 100.0 / COUNT(*)) AS ratio_percentageFROM frpm AS fJOIN schools AS s ON f.CDSCode = s.CDSCodeWHERE f.County Name = 'Santa Clara'Since the original query is already correct in terms of logic and structure, the final answer is:Final_SQL: SELECT (COUNT(CASE WHEN s.FundingType = 'Locally funded' THEN 1 END) * 100.0 / COUNT(*)) AS ratio_percentageFROM frpm AS fJOIN schools AS s ON f.CDSCode = s.CDSCodeWHERE f.County Name = 'Santa Clara' There are no issues with the original query, so it can be returned as is.
SELECT COUNT(*) FROM schools AS S INNER JOIN frpm AS F ON S.CDSCode = F.CDSCode WHERE F.FundingType = 'Directly Funded' AND F.County Name = 'Stanislaus' AND S.OpenDate BETWEEN '2000-01-01' AND '2005-12-31'
SELECT COUNT(*) AS Total_ClosureFROM frpm AS FINNER JOIN schools AS S ON F.CDSCode = S.CDSCodeWHERE F.Academic_Year = '1989' AND S.City = 'San Francisco' AND S.StatusType = 'Closed'
SELECT s.County, COUNT(*) AS ClosureCountFROM schools AS sWHERE s.StatusType = 'Closed'  AND s.SOC = 11  AND s.ClosedDate BETWEEN '1980-01-01' AND '1989-12-31'GROUP BY s.CountyORDER BY ClosureCount DESCLIMIT 1
`SELECT NCESDist FROM schools WHERE SOC = 31`
SELECT COUNT(*) FROM schools sJOIN frpm f ON s.CDSCode = f.CDSCodeWHERE s.County = 'Alpine' AND (s.StatusType = 'Active' OR s.StatusType = 'Closed') AND f.SOCType = 'District Community Day Schools'
SELECT frpm.District Code FROM frpm INNER JOIN schools ON frpm.CDSCode = schools.CDSCode WHERE frpm.Magnet = 0 AND schools.City = 'Fresno'However, since the `Magnet` column is in the `schools` table, we should reference it correctly. The final corrected SQL query is:Revised_SQL: SELECT frpm.District Code FROM frpm INNER JOIN schools ON frpm.CDSCode = schools.CDSCode WHERE schools.Magnet = 0 AND schools.City = 'Fresno' This query now correctly references the `Magnet` column from the `schools` table and uses the correct column for filtering by city.
SELECT frpm.Enrollment (Ages 5-17)FROM frpmJOIN schools ON frpm.CDSCode = schools.CDSCodeWHERE schools.EdOpsCode = 'SSS'AND schools.City = 'Fremont'AND frpm.Academic Year = '2014-2015'
SELECT FRPM Count (Ages 5-17) FROM frpm WHERE CDSCode = (SELECT CDSCode   FROM schools   WHERE MailStreet = 'PO Box 1040' AND SOCType = 'Youth Authority Facilities (CEA)')
SELECT T1.Low Grade FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.EdOpsCode = 'SPECON' AND T1.NCESDist = '613360'
SELECT S.EILName, F.School FROM frpm AS F INNER JOIN schools AS S ON F.CDSCode = S.CDSCode WHERE F.NSLP Provision Status = '2' AND F.County Code = '37'
SELECT schools.City FROM frpm INNER JOIN schools ON frpm.CDSCode = schools.CDSCode WHERE frpm.NSLP Provision Status = 'Lunch Provision 2' AND frpm.Low Grade = '9' AND frpm.High Grade = '12' AND frpm.County Name = 'Merced' AND schools.EILCode = 'HS'
SELECT S.School AS School_Name, (F.Free Meal Count (Ages 5-17) / F.Enrollment (Ages 5-17) * 100) AS Percent_Eligible_FRPM_Ages_5_17FROM schools AS SJOIN frpm AS F ON S.CDSCode = F.CDSCodeWHERE F.Low Grade = 'K' AND F.High Grade = '9' AND F.County Name = 'Los Angeles'
SELECT GSserved, COUNT(*) as count FROM schools WHERE City = 'Adelanto' GROUP BY GSserved ORDER BY count DESC LIMIT 1
SELECT County Name, COUNT(*) AS number_of_schools FROM frpm JOIN schools ON frpm.CDSCode = schools.CDSCode WHERE Virtual = 'F' AND (County Name = 'San Diego' OR County Name = 'Santa Barbara') GROUP BY County Name ORDER BY number_of_schools DESC LIMIT 1
SELECT School, Latitude FROM schools ORDER BY Latitude DESC LIMIT 1
SELECT City, School, Low Grade FROM schools WHERE State = 'CA' ORDER BY Latitude ASC LIMIT 1
`SELECT GSoffered FROM schools ORDER BY Longitude DESC LIMIT 1;`
SELECT City, COUNT(School) AS NumberOfSchoolsFROM schoolsWHERE Magnet = 1 AND GSoffered = 'K-8'GROUP BY City
SELECT AdmFName1, COUNT(*) as NameCountFROM schoolsGROUP BY AdmFName1ORDER BY NameCount DESCLIMIT 2 Note: The `District` column has been removed from the `SELECT` clause and the `GROUP BY` clause to correctly identify the two most common first names without separating them by district. If you want to include the district information, you would need to adjust the logic to handle that separately, perhaps by joining back to the `schools` table after identifying the most common names.
SELECT (T1.Free Meal Count (K-12) / T1.Enrollment (K-12)) * 100 AS Percent (%) Eligible Free (K-12), T1.District CodeFROM frpm AS T1INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCodeWHERE T2.AdmFName1 = 'Alusine'
SELECT T1.AdmLName1, T2.District, T2.County, T2.School FROM frpm AS T2 INNER JOIN schools AS T1 ON T1.CDSCode = T2.CDSCode WHERE T2.CharterNum = '40'
SELECT AdmEmail1 FROM schools WHERE County = 'San Bernardino' AND District = 'San Bernardino City Unified' AND OpenDate BETWEEN '2009-01-01' AND '2010-12-31' AND (SOC = 62 OR DOC = 54)
SELECT T1.sname, T2.AdmEmail1 FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T1.NumGE1500 = (SELECT MAX(NumGE1500) FROM satscores)
SELECT COUNT(*) FROM account AS A INNER JOIN district AS D ON A.district_id = D.district_id WHERE A.frequency = 'POPLATEK PO OBRATU' AND D.A3 = 'East Bohemia'
SELECT COUNT(DISTINCT A.account_id) FROM account AS A INNER JOIN district AS D ON A.district_id = D.district_id INNER JOIN loan AS L ON A.account_id = L.account_id WHERE D.A3 = 'Prague'
SELECT CASE  WHEN AVG(A12) > AVG(A13) THEN '1995'  ELSE '1996' END AS higher_unemployment_yearFROM district
SELECT COUNT(*) FROM district WHERE A11 > 6000 AND A11 < 10000
SELECT COUNT(*) FROM client AS C INNER JOIN district AS D ON C.district_id = D.district_id WHERE C.gender = 'M' AND D.A3 = 'North Bohemia' AND D.A11 > 8000
SELECT account.account_id, (SELECT MAX(A11) FROM district) - (SELECT A11  FROM client  JOIN district ON client.district_id = district.district_id  WHERE client.gender = 'F'  ORDER BY client.birth_date ASC  LIMIT 1) AS salary_gapFROM account JOIN disp ON account.account_id = disp.account_id WHERE disp.client_id = (SELECT client_id  FROM client  WHERE gender = 'F'  ORDER BY birth_date ASC  LIMIT 1)
SELECT a.account_id FROM account AS aJOIN disp AS d ON a.account_id = d.account_idJOIN client AS c ON d.client_id = c.client_idJOIN district AS dist ON c.district_id = dist.district_idWHERE c.birth_date = (SELECT MIN(birth_date) FROM client)AND c.district_id = (SELECT district_id FROM district   WHERE A11 = (SELECT MAX(A11) FROM district))
SELECT COUNT(DISTINCT client.client_id) FROM client INNER JOIN disp ON disp.client_id = client.client_id INNER JOIN account ON disp.account_id = account.account_id WHERE account.frequency = 'POPLATEK TYDNE' AND disp.type = 'OWNER'
SELECT DISTINCT c.client_id FROM client AS c INNER JOIN disp AS d ON c.client_id = d.client_id INNER JOIN account AS a ON d.account_id = a.account_id INNER JOIN trans AS t ON a.account_id = t.account_id WHERE t.operation = 'POPLATEK PO OBRATU' AND d.type = 'DISPONENT'
SELECT a.account_id FROM loan l JOIN account a ON l.account_id = a.account_id WHERE l.amount = (SELECT MIN(amount) FROM loan WHERE date LIKE '1997%') AND a.frequency = 'POPLATEK TYDNE'AND l.date LIKE '1997%'
SELECT a.account_id, l.amount FROM loan AS l INNER JOIN account AS a ON l.account_id = a.account_id WHERE l.duration > 12 AND strftime('%Y', a.date) = '1993' AND l.amount = (SELECT MAX(amount)  FROM loan  WHERE duration > 12  AND account_id IN (SELECT account_id FROM account WHERE strftime('%Y', date) = '1993'))
SELECT COUNT(DISTINCT a.account_id) FROM account AS a JOIN disp AS d ON a.account_id = d.account_id JOIN client AS c ON d.client_id = c.client_id WHERE c.gender = 'F' AND c.birth_date < '1950-01-01' AND c.district_id = (SELECT district_id FROM district WHERE A2 = 'Slokolov')
SELECT A.account_id, MIN(T.date) AS earliest_dateFROM account AS AINNER JOIN trans AS T ON A.account_id = T.account_idWHERE T.date >= '1995-01-01' AND T.date < '1996-01-01'GROUP BY A.account_idORDER BY earliest_dateThis revised query selects the account IDs and their earliest transaction dates in 1995, grouping by account ID and ordering by the earliest date.
SELECT DISTINCT A.account_id FROM account AS A INNER JOIN order AS O ON A.account_id = O.account_id WHERE A.date < '1997-01-01' AND O.amount > 3000
SELECT T1.client_id FROM client AS T1 INNER JOIN card AS T2 ON T1.client_id = T2.client_id WHERE T2.issued = '1994-03-03'
SELECT A.date FROM trans AS T INNER JOIN account AS A ON T.account_id = A.account_id WHERE T.amount = 840 AND T.date = '1998-10-14'
SELECT A.district_id FROM loan AS L INNER JOIN account AS A ON L.account_id = A.account_id WHERE L.date = '1994-08-25'
SELECT MAX(T3.amount) FROM trans AS T3 INNER JOIN account AS T2 ON T3.account_id = T2.account_id INNER JOIN disp AS T1 ON T2.account_id = T1.account_id INNER JOIN card AS T0 ON T1.client_id = T0.client_id WHERE T0.issued = '1996-10-21'
SELECT client.gender FROM client INNER JOIN disp ON client.client_id = disp.client_id INNER JOIN account ON disp.account_id = account.account_id WHERE account.district_id = (SELECT district_id FROM district WHERE A11 = (SELECT MAX(A11) FROM district) LIMIT 1)ORDER BY client.birth_date ASC LIMIT 1
SELECT amount FROM trans WHERE account_id = (SELECT account_id FROM loan WHERE amount = (SELECT MAX(amount) FROM loan)) ORDER BY date ASC LIMIT 1
SELECT COUNT(*) FROM client AS C INNER JOIN disp AS D ON C.client_id = D.client_id INNER JOIN account AS A ON D.account_id = A.account_id INNER JOIN district AS D2 ON C.district_id = D2.district_id WHERE C.gender = 'F' AND D2.A2 = 'Jesenik'
SELECT disp.disp_id FROM trans INNER JOIN account ON trans.account_id = account.account_id INNER JOIN disp ON account.account_id = disp.account_id WHERE trans.amount = 5100 AND trans.date = '1998-09-02'
SELECT COUNT(*) FROM account AS A INNER JOIN district AS D ON A.district_id = D.district_id WHERE D.A2 = 'Litomerice' AND strftime('%Y', A.date) = '1996'
SELECT D2.A2 FROM client AS C INNER JOIN disp AS D1 ON C.client_id = D1.client_id INNER JOIN account AS A ON D1.account_id = A.account_id INNER JOIN district AS D2 ON A.district_id = D2.district_id WHERE C.gender = 'F' AND C.birth_date = '1976-01-29'
SELECT c.birth_date FROM client AS c INNER JOIN account AS a ON c.district_id = a.district_id INNER JOIN loan AS l ON a.account_id = l.account_id WHERE l.amount = 98832 AND l.date = '1996-01-03'
SELECT A.account_id FROM client AS C INNER JOIN disp AS D ON C.client_id = D.client_id INNER JOIN account AS A ON D.account_id = A.account_id INNER JOIN district AS D2 ON C.district_id = D2.district_id WHERE D2.A3 = 'Prague' ORDER BY A.date LIMIT 1
SELECT (COUNT(CASE WHEN gender = 'M' THEN 1 END) * 100.0 / COUNT(*)) AS male_percentageFROM client WHERE district_id = (SELECT district_id FROM district WHERE A3 = 'south Bohemia' ORDER BY A4 DESC LIMIT 1)
SELECT ((balance_after - balance_before) / balance_before) * 100 AS increase_rateFROM ( SELECT  (SELECT balance FROM trans WHERE account_id = (SELECT account_id FROM loan WHERE date = '1993-07-05') AND date = '1993-03-22') AS balance_before, (SELECT balance FROM trans WHERE account_id = (SELECT account_id FROM loan WHERE date = '1993-07-05') AND date = '1998-12-27') AS balance_after) This SQL query is correct as is.
SELECT (SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) * 100.0 / SUM(amount)) AS percentage FROM loan
SELECT (COUNT(DISTINCT loan.account_id) * 100.0 / COUNT(DISTINCT account.account_id)) AS percentageFROM loan JOIN account ON loan.account_id = account.account_idWHERE loan.status = 'C' AND loan.amount < 100000
SELECT A.account_id, D.A2 AS district_name, D.A3 AS district_regionFROM account AS AINNER JOIN district AS D ON A.district_id = D.district_idWHERE strftime('%Y', A.date) = '1993' AND A.frequency = 'POPLATEK PO OBRATU'
SELECT A.account_id, A.frequency FROM account AS A INNER JOIN district AS D ON A.district_id = D.district_id WHERE D.A2 = 'east Bohemia' AND A.date BETWEEN '1995-01-01' AND '2000-12-31'
SELECT A.account_id, A.date FROM account AS A INNER JOIN district AS D ON A.district_id = D.district_id WHERE D.A2 = 'Prachatice'
SELECT D.A2 AS district, D.A3 AS region FROM loan AS L INNER JOIN account AS A ON L.account_id = A.account_id INNER JOIN district AS D ON A.district_id = D.district_id WHERE L.loan_id = 4990
SELECT A.account_id, D.A2 AS district, D.A3 AS region FROM loan AS L INNER JOIN account AS A ON L.account_id = A.account_id INNER JOIN district AS D ON A.district_id = D.district_id WHERE L.amount > 300000
SELECT L.loan_id, D.A3 AS district, D.A11 AS average_salary FROM loan AS L INNER JOIN account AS A ON L.account_id = A.account_id INNER JOIN district AS D ON A.district_id = D.district_id WHERE L.duration = 60
SELECT district.A2 AS district_name, ((district.A13 - district.A12) / district.A12) * 100 AS unemployment_increment_rateFROM loan INNER JOIN account ON loan.account_id = account.account_id INNER JOIN district ON account.district_id = district.district_id WHERE loan.status = 'D'
SELECT CAST(COUNT(CASE WHEN D.A2 = 'Decin' THEN 1 END) AS REAL) * 100 / COUNT(*) AS percentageFROM account AS A INNER JOIN district AS D ON A.district_id = D.district_id WHERE A.date LIKE '1993%'
`SELECT account_id FROM account WHERE frequency = 'POPLATEK MESICNE';`
SELECT T1.A2 AS district_name, COUNT(*) AS female_account_holdersFROM district AS T1INNER JOIN account AS T2 ON T1.district_id = T2.district_idINNER JOIN disp AS T3 ON T2.account_id = T3.account_idINNER JOIN client AS T4 ON T3.client_id = T4.client_idWHERE T4.gender = 'F'GROUP BY T1.A2ORDER BY female_account_holders DESCLIMIT 10
SELECT district.A2, SUM(trans.amount) AS total_withdrawalFROM transINNER JOIN account ON trans.account_id = account.account_idINNER JOIN district ON account.district_id = district.district_idWHERE trans.type = 'VYDAJ' AND trans.date LIKE '1996-01%'GROUP BY district.A2ORDER BY total_withdrawal DESCLIMIT 10
SELECT COUNT(*) FROM account AS A LEFT JOIN disp AS D ON A.account_id = D.account_id LEFT JOIN card AS C ON D.disp_id = C.disp_id LEFT JOIN client AS CL ON D.client_id = CL.client_id LEFT JOIN district AS DI ON CL.district_id = DI.district_id WHERE DI.A3 = 'South Bohemia' AND C.card_id IS NULL
SELECT district.A3, SUM(loan.amount) AS total_active_loanFROM loanJOIN account ON loan.account_id = account.account_idJOIN district ON account.district_id = district.district_idWHERE loan.status IN ('C', 'D')GROUP BY district.district_idORDER BY total_active_loan DESCLIMIT 1
SELECT AVG(loan.amount) FROM loan INNER JOIN account ON loan.account_id = account.account_id INNER JOIN disp ON account.account_id = disp.account_id INNER JOIN client ON disp.client_id = client.client_id WHERE client.gender = 'M'
SELECT A2, A13 FROM district WHERE A13 = (SELECT MAX(A13) FROM district WHERE A13 IS NOT NULL) AND A13 IS NOT NULL
SELECT COUNT(account_id) FROM account WHERE district_id = (SELECT district_id FROM district ORDER BY A16 DESC LIMIT 1)
SELECT COUNT(DISTINCT T2.account_id) FROM trans AS T1INNER JOIN account AS T2 ON T1.account_id = T2.account_idWHERE T1.operation = 'VYBER KARTOU' AND T1.balance < 0 AND T2.frequency = 'POPLATEK MESICNE'
SELECT COUNT(*) FROM loan AS L INNER JOIN account AS A ON L.account_id = A.account_id WHERE L.date BETWEEN '1995-01-01' AND '1997-12-31' AND L.amount >= 250000 AND A.frequency = 'POPLATEK MESICNE'
SELECT COUNT(DISTINCT A.account_id) FROM loan AS L INNER JOIN account AS A ON L.account_id = A.account_id INNER JOIN district AS D ON A.district_id = D.district_id WHERE D.district_id = 1 AND (L.status = 'C' OR L.status = 'D')
SELECT COUNT(client_id) FROM client WHERE gender = 'M' AND district_id = (SELECT district_id FROM district ORDER BY A15 DESC LIMIT 1 OFFSET 1)
SELECT COUNT(*) FROM card AS C INNER JOIN disp AS D ON C.disp_id = D.disp_id WHERE C.type = 'gold' AND D.type = 'DISPONENT'
SELECT COUNT(*) FROM account AS A INNER JOIN district AS D ON A.district_id = D.district_id WHERE D.A2 = 'Pisek'
SELECT DISTINCT D.A2 FROM trans AS T INNER JOIN account AS A ON T.account_id = A.account_id INNER JOIN district AS D ON A.district_id = D.district_id WHERE T.amount > 10000 AND T.date LIKE '1997%'
SELECT DISTINCT A.account_id FROM order O INNER JOIN account A ON O.account_id = A.account_id INNER JOIN district D ON A.district_id = D.district_id WHERE O.k_symbol = 'SIPO' AND D.A2 = 'Pisek'
SELECT account_id FROM card WHERE type = 'gold'INTERSECTSELECT account_id FROM card WHERE type = 'classic'This revised query checks for accounts that have both gold and classic credit cards, which are the valid types present in the schema.
SELECT AVG(T1.amount) FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.type = 'VYBER KARTOU' AND strftime('%Y', T1.date) = '2021'
SELECT account_idFROM ( SELECT account_id, SUM(amount) AS total_spent FROM trans WHERE type = 'VYBER KARTOU' AND strftime('%Y', date) = '1998' GROUP BY account_id) AS spendingWHERE total_spent < (SELECT AVG(total_spent) FROM ( SELECT account_id, SUM(amount) AS total_spent FROM trans WHERE type = 'VYBER KARTOU' AND strftime('%Y', date) = '1998' GROUP BY account_id))
SELECT DISTINCT c.client_id FROM client AS cJOIN disp AS d ON c.client_id = d.client_idJOIN account AS a ON d.account_id = a.account_idJOIN card AS cd ON d.account_id = cd.account_idJOIN loan AS l ON a.account_id = l.account_idWHERE c.gender = 'F'
SELECT COUNT(DISTINCT A.account_id) FROM client AS C INNER JOIN district AS D ON C.district_id = D.district_id INNER JOIN disp AS DISP ON C.client_id = DISP.client_id INNER JOIN account AS A ON DISP.account_id = A.account_id WHERE C.gender = 'F' AND D.A3 = 'South Bohemia'
SELECT A.account_id FROM account AS A INNER JOIN district AS D ON A.district_id = D.district_id INNER JOIN disp AS DISP ON A.account_id = DISP.account_id WHERE D.A2 = 'Tabor' AND DISP.type = 'OWNER'
SELECT DISTINCT T1.type FROM disp AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.type != 'OWNER' AND T3.A11 > 8000 AND T3.A11 <= 9000
SELECT COUNT(DISTINCT A.account_id) FROM account AS A INNER JOIN district AS D ON A.district_id = D.district_id INNER JOIN trans AS T ON A.account_id = T.account_id WHERE D.A3 = 'North Bohemia' AND T.bank = 'AB'
SELECT DISTINCT D.A2 FROM district AS D INNER JOIN account AS A ON D.district_id = A.district_id INNER JOIN trans AS T ON A.account_id = T.account_id WHERE T.type = 'VYDAJ'
SELECT AVG(district.A15) FROM district JOIN client ON client.district_id = district.district_id JOIN disp ON disp.client_id = client.client_id JOIN account ON account.account_id = disp.account_id WHERE district.A15 > 4000 AND account.date >= '1997-01-01'
SELECT COUNT(DISTINCT C.card_id) FROM card AS C INNER JOIN disp AS D ON C.disp_id = D.disp_id INNER JOIN account AS A ON D.account_id = A.account_id INNER JOIN loan AS L ON A.account_id = L.account_id WHERE C.type = 'classic' AND D.type = 'OWNER'
SELECT COUNT(*) FROM client AS C INNER JOIN district AS D ON C.district_id = D.district_id WHERE C.gender = 'M' AND D.A2 = 'Hl.m. Praha'
SELECT CAST(SUM(CASE WHEN type = 'gold' AND issued < '1998-01-01' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(card_id) AS percent_gold_cards FROM card
SELECT T1.client_id FROM disp AS T1 WHERE T1.account_id = (SELECT account_id FROM loan WHERE amount = (SELECT MAX(amount) FROM loan))
SELECT T2.A15 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.account_id = 532
SELECT A.district_id FROM order AS O INNER JOIN account AS A ON O.account_id = A.account_id WHERE O.order_id = 33333
SELECT T1.*FROM trans AS T1INNER JOIN disp AS T2 ON T1.account_id = T2.account_idWHERE T2.client_id = 3356 AND T1.operation = 'VYBER'
SELECT COUNT(*) FROM account AS A INNER JOIN loan AS L ON A.account_id = L.account_id WHERE A.frequency = 'POPLATEK MESICNE' AND L.amount < 200000
SELECT card.type FROM card INNER JOIN disp ON card.disp_id = disp.disp_id WHERE disp.client_id = 13539
SELECT T2.A3 FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.client_id = 3541
SELECT district.A2 AS district_name, COUNT(account.account_id) AS account_countFROM loanINNER JOIN account ON loan.account_id = account.account_idINNER JOIN district ON account.district_id = district.district_idWHERE loan.status = 'A'GROUP BY district.district_idORDER BY account_count DESCLIMIT 1
SELECT T3.client_id FROM order AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T3 ON T2.account_id = T3.account_id WHERE T1.order_id = 32423
SELECT T1.* FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T2.district_id = 5
SELECT COUNT(*) FROM account AS A INNER JOIN district AS D ON A.district_id = D.district_id WHERE D.A2 = 'Jesenik'
SELECT DISTINCT client.client_id FROM client INNER JOIN disp ON client.client_id = disp.client_id INNER JOIN card ON disp.disp_id = card.disp_id WHERE card.type = 'junior' AND card.issued >= '1997-01-01'
SELECT (SELECT COUNT(client_id) FROM client WHERE district_id IN (SELECT district_id FROM district WHERE A11 > 10000) AND gender = 'F') * 100.0 / (SELECT COUNT(client_id) FROM client WHERE district_id IN (SELECT district_id FROM district WHERE A11 > 10000)) AS female_percentage
SELECT CASE  WHEN SUM(CASE WHEN strftime('%Y', date) = '1996' THEN amount ELSE 0 END) = 0 THEN 0 ELSE ((SUM(CASE WHEN strftime('%Y', date) = '1997' THEN amount ELSE 0 END) -   SUM(CASE WHEN strftime('%Y', date) = '1996' THEN amount ELSE 0 END)) /   SUM(CASE WHEN strftime('%Y', date) = '1996' THEN amount ELSE 0 END)) * 100 END AS growth_rateFROM loanWHERE account_id IN ( SELECT account_id FROM account WHERE district_id IN ( SELECT district_id FROM client WHERE gender = 'M' )) AND strftime('%Y', date) IN ('1996', '1997')
SELECT COUNT(*) FROM trans WHERE operation = 'VYBER KARTOU' AND date > '1995-12-31';
SELECT (SELECT SUM(A16) FROM district WHERE A3 = 'North Bohemia') - (SELECT SUM(A16) FROM district WHERE A3 = 'East Bohemia') AS crime_difference
SELECT type, COUNT(*) AS count FROM disp WHERE account_id BETWEEN 1 AND 10 AND (type = 'OWNER' OR type = 'DISPONENT') GROUP BY type
SELECT COUNT(*) AS request_count, SUM(amount) AS total_amount, k_symbol FROM order WHERE account_id = 3 GROUP BY k_symbol
SELECT strftime('%Y', T1.birth_date) AS birth_yearFROM disp AS T1INNER JOIN client AS T2 ON T1.client_id = T2.client_idINNER JOIN account AS T3 ON T1.account_id = T3.account_idWHERE T3.account_id = 130  -- This will not return any results as account_id 130 does not exist.
SELECT COUNT(*) FROM account AS A INNER JOIN disp AS D ON A.account_id = D.account_id WHERE D.type = 'OWNER' AND A.frequency = 'POPLATEK MESICNE'This change ensures that the frequency condition matches the sample data provided in the `account` table.
SELECT amount, status FROM loan WHERE account_id = (SELECT account_id FROM disp WHERE client_id = 992) Since there are no issues, the final answer is the same as the provided SQL query.
SELECT SUM(T.amount) AS total_amount, C.gender FROM trans AS T INNER JOIN account AS A ON T.account_id = A.account_id INNER JOIN disp AS D ON A.account_id = D.account_id INNER JOIN client AS C ON D.client_id = C.client_id WHERE T.trans_id = 851 AND C.client_id = 4 GROUP BY C.gender
SELECT card.type FROM card INNER JOIN disp ON card.disp_id = disp.disp_id WHERE disp.client_id = 9
SELECT SUM(T3.amount) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T1.client_id = 617 AND strftime('%Y', T3.date) = '1998'
SELECT C.client_id FROM client AS C INNER JOIN district AS D ON C.district_id = D.district_id WHERE C.birth_date BETWEEN '1983-01-01' AND '1987-12-31' AND D.A3 = 'East Bohemia'
SELECT c.client_id FROM client AS c JOIN disp AS d ON c.client_id = d.client_id JOIN account AS a ON d.account_id = a.account_id JOIN loan AS l ON a.account_id = l.account_id WHERE c.gender = 'F' ORDER BY l.amount DESC LIMIT 3
SELECT COUNT(DISTINCT c.client_id) FROM client AS cINNER JOIN disp AS d ON c.client_id = d.client_idINNER JOIN account AS a ON d.account_id = a.account_idINNER JOIN trans AS t ON a.account_id = t.account_idINNER JOIN order AS o ON a.account_id = o.account_idWHERE c.gender = 'M' AND c.birth_date BETWEEN '1974-01-01' AND '1976-12-31'AND o.k_symbol = 'SIPO'AND o.amount > 4000
SELECT COUNT(*) FROM account AS A INNER JOIN district AS D ON A.district_id = D.district_id WHERE D.A2 = 'Beroun' AND A.date > '1996-12-31'
SELECT COUNT(*) FROM client AS C INNER JOIN disp AS D ON C.client_id = D.client_id INNER JOIN card AS CA ON D.disp_id = CA.disp_id WHERE C.gender = 'F' AND CA.type = 'junior'
SELECT (COUNT(CASE WHEN client.gender = 'F' THEN 1 END) * 100.0 / COUNT(DISTINCT client.client_id)) AS female_percentageFROM client INNER JOIN disp ON client.client_id = disp.client_id INNER JOIN account ON disp.account_id = account.account_id WHERE client.district_id = (SELECT district_id FROM district WHERE A3 = 'Prague')
SELECT CAST(COUNT(CASE WHEN C.gender = 'M' THEN 1 END) AS REAL) * 100 / COUNT(*) AS percentage_male_clientsFROM account AS A INNER JOIN disp AS D ON A.account_id = D.account_id INNER JOIN client AS C ON D.client_id = C.client_id WHERE A.frequency = 'POPLATEK TYDNE'
SELECT COUNT(DISTINCT disp.client_id) FROM disp INNER JOIN account ON disp.account_id = account.account_id WHERE account.frequency = 'POPLATEK TYDNE' AND disp.type = 'USER'
SELECT a.account_id, l.amountFROM loan AS lINNER JOIN account AS a ON l.account_id = a.account_idWHERE l.duration > 24 AND a.date < '1997-01-01'AND l.amount = (SELECT MIN(amount)  FROM loan AS l2  INNER JOIN account AS a2 ON l2.account_id = a2.account_id  WHERE l2.duration > 24 AND a2.date < '1997-01-01')
SELECT a.account_id FROM account AS a INNER JOIN disp AS d ON a.account_id = d.account_id INNER JOIN client AS c ON d.client_id = c.client_id INNER JOIN district AS dis ON c.district_id = dis.district_id WHERE c.gender = 'F' AND c.birth_date = (SELECT MIN(birth_date) FROM client WHERE gender = 'F') AND dis.A11 = (SELECT MIN(A11) FROM district WHERE district_id IN (SELECT district_id FROM client WHERE gender = 'F'))
SELECT COUNT(*) FROM client AS C INNER JOIN district AS D ON C.district_id = D.district_id WHERE C.birth_date BETWEEN '1920-01-01' AND '1920-12-31' AND D.A3 = 'East Bohemia' This revised query is more efficient and clear in its intent.
SELECT COUNT(*) FROM loan AS L INNER JOIN account AS A ON L.account_id = A.account_id WHERE L.duration = 24 AND A.frequency = 'POPLATEK TYDNE'
SELECT AVG(loan.amount) FROM loan INNER JOIN account ON loan.account_id = account.account_id INNER JOIN trans ON account.account_id = trans.account_id WHERE loan.status IN ('C', 'D')
SELECT C.client_id, C.district_id FROM client AS C INNER JOIN disp AS D ON C.client_id = D.client_id INNER JOIN account AS A ON D.account_id = A.account_id WHERE D.type = 'OWNER'
SELECT C.client_id, (strftime('%Y', 'now') - strftime('%Y', C.birth_date)) AS ageFROM card AS CAJOIN disp AS D ON CA.disp_id = D.disp_idJOIN account AS A ON D.account_id = A.account_idJOIN loan AS L ON A.account_id = L.account_idJOIN client AS C ON D.client_id = C.client_idWHERE CA.type = 'gold'
`SELECT bond_type FROM bond GROUP BY bond_type ORDER BY COUNT(bond_type) DESC LIMIT 1`
SELECT COUNT(*) FROM atom AS A INNER JOIN molecule AS M ON A.molecule_id = M.molecule_id WHERE M.label = '-' AND A.element = 'cl'
SELECT AVG(o_count) FROM ( SELECT COUNT(*) AS o_count FROM atom WHERE element = 'o' AND molecule_id IN (SELECT molecule_id FROM bond WHERE bond_type = '-') GROUP BY molecule_id)
SELECT COUNT(DISTINCT m.molecule_id) AS num_carcinogenic_molecules, COUNT(c.atom_id) AS total_single_bonds, (COUNT(c.atom_id) * 1.0 / COUNT(DISTINCT m.molecule_id)) AS average_single_bonds_per_carcinogenic_moleculeFROM molecule mJOIN bond b ON m.molecule_id = b.molecule_idJOIN connected c ON b.bond_id = c.bond_idWHERE m.label = '+' AND b.bond_type = '-'
SELECT COUNT(*) FROM atom AS A INNER JOIN molecule AS M ON A.molecule_id = M.molecule_id WHERE A.element = 'na' AND M.label = '-'
SELECT T1.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#' AND T2.label = '+'
SELECT CAST(SUM(CASE WHEN T1.element = 'c' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.atom_id) AS carbon_percentageFROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = ' = '
SELECT COUNT(*) FROM bond WHERE bond_type = '#'
`SELECT COUNT(*) FROM atom WHERE element != 'br';`
SELECT COUNT(*) FROM molecule WHERE molecule_id BETWEEN 'TR000' AND 'TR099' AND label = '+';
SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'si'
SELECT T1.element FROM connected AS T0 INNER JOIN atom AS T1 ON T0.atom_id = T1.atom_id INNER JOIN atom AS T2 ON T0.atom_id2 = T2.atom_id WHERE T0.bond_id = 'TR004_8_9'
SELECT DISTINCT T3.element FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id INNER JOIN atom AS T3 ON T3.atom_id = T2.atom_id OR T3.atom_id = T2.atom_id2 WHERE T1.bond_type = '='
SELECT molecule.labelFROM atomJOIN molecule ON atom.molecule_id = molecule.molecule_idWHERE atom.element = 'h'GROUP BY molecule.labelORDER BY COUNT(*) DESCLIMIT 1
SELECT bond.bond_type FROM bond JOIN connected ON bond.bond_id = connected.bond_id WHERE connected.atom_id IN (SELECT atom_id FROM atom WHERE element = 'te') OR connected.atom_id2 IN (SELECT atom_id FROM atom WHERE element = 'te')
SELECT A1.element AS atom1_element, A2.element AS atom2_elementFROM connected AS CINNER JOIN bond AS B ON C.bond_id = B.bond_idINNER JOIN atom AS A1 ON C.atom_id = A1.atom_idINNER JOIN atom AS A2 ON C.atom_id2 = A2.atom_idWHERE B.bond_type = '-'
SELECT C.atom_id, C.atom_id2 FROM connected AS C INNER JOIN bond AS B ON C.bond_id = B.bond_id INNER JOIN molecule AS M ON B.molecule_id = M.molecule_id WHERE M.label = '-'
SELECT a.element FROM atom a INNER JOIN molecule m ON a.molecule_id = m.molecule_id WHERE m.label = '-' GROUP BY a.element ORDER BY COUNT(*) ASC LIMIT 1
SELECT T2.bond_type FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id WHERE T1.atom_id = 'TR004_8' AND T1.atom_id2 = 'TR004_20'
SELECT DISTINCT T1.label FROM molecule AS T1 WHERE T1.molecule_id NOT IN (SELECT T2.molecule_id FROM atom AS T2 WHERE T2.element = 'sn')
SELECT COUNT(DISTINCT a.atom_id) FROM atom AS a JOIN connected AS c ON a.atom_id = c.atom_id JOIN bond AS b ON c.bond_id = b.bond_id JOIN molecule AS m ON a.molecule_id = m.molecule_id WHERE (a.element = 'i' OR a.element = 's') AND b.bond_type = '-'
SELECT C.atom_id, C.atom_id2 FROM connected AS C INNER JOIN bond AS B ON C.bond_id = B.bond_id WHERE B.bond_type = '#'
SELECT DISTINCT T2.atom_id, T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id2 = T2.atom_id INNER JOIN atom AS T3 ON T1.atom_id = T3.atom_id WHERE T3.molecule_id = 'TR181'
SELECT (COUNT(DISTINCT m.molecule_id) -  (SELECT COUNT(DISTINCT m2.molecule_id)   FROM molecule m2   JOIN atom a ON m2.molecule_id = a.molecule_id   WHERE m2.label = '+' AND a.element = 'f')) * 100.0 / COUNT(DISTINCT m.molecule_id) AS percentage_not_containing_fluorineFROM molecule m WHERE m.label = '+'
SELECT CAST(SUM(CASE WHEN M.label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(CASE WHEN B.bond_type = '#' THEN 1 END) AS percentFROM bond AS BINNER JOIN molecule AS M ON B.molecule_id = M.molecule_idWHERE B.bond_type = '#'
SELECT element FROM atom WHERE molecule_id = 'TR000' ORDER BY element ASC LIMIT 3
SELECT T1.atom_id, T1.atom_id2 FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id WHERE T2.molecule_id = 'TR001' AND T2.bond_id = 'TR001_2_6'
SELECT (SUM(CASE WHEN label = '+' THEN 1 ELSE 0 END) - SUM(CASE WHEN label = '-' THEN 1 ELSE 0 END)) AS difference FROM molecule
SELECT atom_id, atom_id2 FROM connected WHERE bond_id = 'TR000_2_5'
SELECT bond_id FROM connected WHERE atom_id2 = 'TR000_2';
SELECT DISTINCT T2.molecule_id, T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '=' ORDER BY T2.molecule_id LIMIT 5
SELECT (SUM(CASE WHEN bond_type = ' = ' THEN 1 ELSE 0 END) * 100.0 / COUNT(bond_id)) AS percent FROM bond WHERE molecule_id = 'TR008';
SELECT (CAST(SUM(CASE WHEN label = '+' THEN 1 ELSE 0 END) AS FLOAT) / COUNT(molecule_id)) * 100 AS percentFROM molecule;
SELECT (CAST(SUM(CASE WHEN element = 'h' THEN 1 ELSE 0 END) AS FLOAT) / COUNT(atom_id)) * 100 AS percent FROM atom WHERE molecule_id = 'TR206';
SELECT bond_type FROM bond WHERE molecule_id = 'TR000'
SELECT T1.element, T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.molecule_id = 'TR060'
SELECT T1.bond_type, T2.label FROM ( SELECT bond_type FROM ( SELECT bond_type, COUNT(bond_type) as bond_count  FROM bond  WHERE molecule_id = 'TR018'  GROUP BY bond_type ) AS bond_counts ORDER BY bond_count DESC LIMIT 1) AS T1JOIN molecule AS T2 ON T2.molecule_id = 'TR018' This query now correctly reflects the requirements of the question.
SELECT DISTINCT T1.molecule_id FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN connected AS T3 ON T2.bond_id = T3.bond_id WHERE T1.label = '-' AND T2.bond_type = '-' ORDER BY T1.molecule_id LIMIT 3
SELECT bond_id FROM bond WHERE molecule_id = 'TR006' ORDER BY bond_id ASC LIMIT 2
SELECT COUNT(*) FROM connected AS C INNER JOIN bond AS B ON C.bond_id = B.bond_id WHERE B.molecule_id = 'TR009' AND (C.atom_id = 'TR009_12' OR C.atom_id2 = 'TR009_12')
SELECT COUNT(DISTINCT T1.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '+' AND T2.element = 'br'
SELECT B.bond_type, C.atom_id, C.atom_id2 FROM bond AS B INNER JOIN connected AS C ON B.bond_id = C.bond_id WHERE B.bond_id = 'TR001_6_9'
SELECT T1.molecule_id, T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR001_10'
SELECT COUNT(DISTINCT T1.molecule_id) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#'
SELECT COUNT(*) AS connection_count FROM connected WHERE atom_id LIKE 'TR%_19' OR atom_id2 LIKE 'TR%_19';
SELECT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.molecule_id = 'TR004'
`SELECT COUNT(*) FROM molecule WHERE label = '-';`
SELECT DISTINCT T2.molecule_id, T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE CAST(SUBSTR(T1.atom_id, 7, 2) AS INTEGER) BETWEEN 21 AND 25 AND T2.label = '+'
SELECT DISTINCT T1.bond_id FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id INNER JOIN atom AS T3 ON T2.atom_id = T3.atom_id INNER JOIN atom AS T4 ON T2.atom_id2 = T4.atom_id WHERE (T3.element = 'p' AND T4.element = 'n') OR (T3.element = 'n' AND T4.element = 'p')
SELECT label FROM molecule WHERE molecule_id = ( SELECT molecule_id FROM bond WHERE bond_type = '=' GROUP BY molecule_id ORDER BY COUNT(bond_id) DESC LIMIT 1)
SELECT COUNT(T2.bond_id) * 1.0 / COUNT(DISTINCT T1.atom_id) AS average_bondsFROM atom AS T1LEFT JOIN connected AS T2 ON T1.atom_id = T2.atom_id OR T1.atom_id = T2.atom_id2WHERE T1.element = 'i'Since the original query is already correct in terms of logic and structure, the final answer remains the same as the original query. Final Answer: SELECT COUNT(T2.bond_id) * 1.0 / COUNT(DISTINCT T1.atom_id) AS average_bondsFROM atom AS T1LEFT JOIN connected AS T2 ON T1.atom_id = T2.atom_id OR T1.atom_id = T2.atom_id2WHERE T1.element = 'i'
SELECT T1.bond_type, T1.bond_id FROM bond AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE SUBSTR(T2.atom_id, 7, 2) + 0 = 45
SELECT element FROM atom WHERE atom_id NOT IN (SELECT atom_id FROM connected UNION SELECT atom_id2 FROM connected)
SELECT a1.element, a2.element FROM connected AS c JOIN atom AS a1 ON c.atom_id = a1.atom_id JOIN atom AS a2 ON c.atom_id2 = a2.atom_id WHERE c.bond_id IN (SELECT bond_id FROM bond WHERE bond_type = '#' AND molecule_id = 'TR447')
SELECT element FROM atom WHERE atom_id IN ( SELECT atom_id FROM connected WHERE bond_id = 'TR144_8_19' UNION SELECT atom_id2 FROM connected WHERE bond_id = 'TR144_8_19')
SELECT T1.molecule_id, COUNT(T2.bond_id) AS double_bond_countFROM molecule AS T1INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_idWHERE T1.label = '+' AND T2.bond_type = '='GROUP BY T1.molecule_idORDER BY double_bond_count DESCLIMIT 1
SELECT element FROM ( SELECT a.element, COUNT(*) AS element_count FROM atom AS a INNER JOIN molecule AS m ON a.molecule_id = m.molecule_id WHERE m.label = '+' GROUP BY a.element) AS counts ORDER BY element_count ASC LIMIT 1
SELECT T2.* FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id2 = T2.atom_id WHERE T1.atom_id = (SELECT atom_id FROM atom WHERE element = 'pb')
SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '#'
SELECT (COUNT(b.bond_id) * 100.0 / (SELECT COUNT(*) FROM bond)) AS percentageFROM bond bJOIN connected c ON b.bond_id = c.bond_idJOIN atom a1 ON c.atom_id = a1.atom_idJOIN atom a2 ON c.atom_id2 = a2.atom_idGROUP BY a1.element, a2.elementHAVING COUNT(b.bond_id) = ( SELECT MAX(counts.count) FROM ( SELECT COUNT(b.bond_id) AS count FROM bond b JOIN connected c ON b.bond_id = c.bond_id JOIN atom a1 ON c.atom_id = a1.atom_id JOIN atom a2 ON c.atom_id2 = a2.atom_id GROUP BY a1.element, a2.element ) AS counts )
SELECT CAST(SUM(CASE WHEN m.label = '+' THEN 1 ELSE 0 END) AS FLOAT) / COUNT(b.bond_id) AS proportionFROM bond AS bJOIN molecule AS m ON b.molecule_id = m.molecule_idWHERE b.bond_type = '-'
SELECT COUNT(*) FROM atom WHERE element IN ('c', 'h');
SELECT C.atom_id2 FROM connected AS C INNER JOIN atom AS A ON C.atom_id = A.atom_id WHERE A.element = 's'
SELECT DISTINCT T2.bond_type FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'sn'
SELECT COUNT(DISTINCT a.element) FROM bond b JOIN connected c ON b.bond_id = c.bond_id JOIN atom a ON c.atom_id = a.atom_id WHERE b.bond_type = '-'
SELECT COUNT(a.atom_id) FROM atom AS a JOIN bond AS b ON a.molecule_id = b.molecule_id WHERE b.bond_type = '#' AND a.element IN ('p', 'br')
SELECT T1.bond_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'
SELECT B.molecule_id FROM bond AS B INNER JOIN molecule AS M ON B.molecule_id = M.molecule_id WHERE B.bond_type = '-' AND M.label = '-'
SELECT (SUM(CASE WHEN a.element = 'cl' THEN 1 ELSE 0 END) * 100.0 / COUNT(a.atom_id)) AS percentFROM atom AS aJOIN molecule AS m ON a.molecule_id = m.molecule_idJOIN bond AS b ON b.molecule_id = m.molecule_idWHERE b.bond_type = '-'GROUP BY m.molecule_idThis query now correctly calculates the percentage of chlorine atoms among single bond molecules by grouping by `molecule_id`.
SELECT molecule_id, label FROM molecule WHERE molecule_id IN ('TR000', 'TR001', 'TR002');
`SELECT molecule_id FROM molecule WHERE label = '-'`
SELECT COUNT(*) AS total_carcinogenic_molecules FROM molecule WHERE label = '+' AND molecule_id BETWEEN 'TR000' AND 'TR030';
SELECT T1.bond_type FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id BETWEEN 'TR000' AND 'TR050'
SELECT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id OR T1.atom_id = T2.atom_id2 INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_id = 'TR001_10_11'
SELECT COUNT(DISTINCT connected.bond_id) FROM connected WHERE connected.atom_id IN (SELECT atom_id FROM atom WHERE element = 'i')
SELECT molecule.label, COUNT(molecule.label) AS count FROM atom JOIN molecule ON atom.molecule_id = molecule.molecule_id WHERE atom.element = 'ca' GROUP BY molecule.label ORDER BY count DESC LIMIT 1
SELECT CASE  WHEN COUNT(DISTINCT a.element) = 2 THEN 'Yes'  ELSE 'No' END AS has_both_elementsFROM connected AS cJOIN atom AS a ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2WHERE c.bond_id = 'TR001_1_8' AND a.element IN ('cl', 'c')
SELECT DISTINCT m.molecule_id FROM molecule AS mJOIN bond AS b ON m.molecule_id = b.molecule_idJOIN connected AS c ON b.bond_id = c.bond_idJOIN atom AS a1 ON c.atom_id = a1.atom_idJOIN atom AS a2 ON c.atom_id2 = a2.atom_idWHERE m.label = '-' AND b.bond_type = '#' AND (a1.element = 'c' OR a2.element = 'c')LIMIT 2
SELECT (COUNT(CASE WHEN a.element = 'cl' THEN 1 END) * 100.0 / COUNT(a.atom_id)) AS percentageFROM atom AS aJOIN molecule AS m ON a.molecule_id = m.molecule_idWHERE m.label = '+'
SELECT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.molecule_id = 'TR001'
SELECT bond.molecule_id FROM bond WHERE bond.bond_type = '='
SELECT connected.atom_id, connected.atom_id2 FROM connected INNER JOIN bond ON connected.bond_id = bond.bond_id WHERE bond.bond_type = '#'
SELECT a.element FROM connected AS c JOIN atom AS a ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2 WHERE c.bond_id = 'TR005_16_26'
SELECT COUNT(*) FROM bond AS B INNER JOIN molecule AS M ON B.molecule_id = M.molecule_id WHERE B.bond_type = '-' AND M.label = '-'
SELECT T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_id = 'TR001_10_11'
SELECT T1.bond_id, T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#'
SELECT a.element, COUNT(*) AS tallyFROM atom AS aJOIN molecule AS m ON a.molecule_id = m.molecule_idWHERE m.label = '+' AND a.atom_id = m.molecule_id || '_4'GROUP BY a.element
SELECT (SELECT COUNT(*) FROM atom WHERE element = 'h' AND molecule_id = 'TR006') * 1.0 / (SELECT COUNT(*) FROM atom WHERE molecule_id = 'TR006') AS hydrogen_ratio, m.labelFROM molecule mWHERE m.molecule_id = 'TR006'
SELECT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'ca'
SELECT DISTINCT T2.bond_type FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'te'
SELECT T1.element FROM bond AS T0 INNER JOIN connected AS T2 ON T0.bond_id = T2.bond_id INNER JOIN atom AS T1 ON T2.atom_id = T1.atom_id WHERE T0.bond_id = 'TR001_10_11'UNIONSELECT T1.element FROM bond AS T0 INNER JOIN connected AS T2 ON T0.bond_id = T2.bond_id INNER JOIN atom AS T1 ON T2.atom_id2 = T1.atom_id WHERE T0.bond_id = 'TR001_10_11' This query is correct as is.
SELECT CAST(COUNT(DISTINCT b.molecule_id) AS REAL) * 100 / COUNT(DISTINCT m.molecule_id) AS percentage_triple_bondFROM bond AS b JOIN molecule AS m ON b.molecule_id = m.molecule_idWHERE b.bond_type = '#';
SELECT CAST(SUM(CASE WHEN T1.bond_type = '=' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) AS percentFROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.molecule_id = 'TR047'
SELECT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR000_1'
SELECT label FROM molecule WHERE molecule_id = 'TR151';
SELECT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR151'
SELECT COUNT(*) FROM molecule WHERE label = '+'
SELECT atom_id FROM atom WHERE element = 'c' AND molecule_id >= 'TR010' AND molecule_id <= 'TR050'
SELECT COUNT(*) FROM atom AS A INNER JOIN molecule AS M ON A.molecule_id = M.molecule_id WHERE M.label = '+'
SELECT T1.bond_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '=' AND T2.label = '+'
SELECT COUNT(*) FROM atom AS A INNER JOIN molecule AS M ON A.molecule_id = M.molecule_id WHERE A.element = 'h' AND M.label = '+'
SELECT B.molecule_id FROM connected AS C INNER JOIN bond AS B ON C.bond_id = B.bond_id WHERE C.atom_id = 'TR000_1' AND B.bond_id = 'TR000_1_2'
SELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c' AND T2.label = '-'
SELECT (COUNT(DISTINCT CASE WHEN a.element = 'h' THEN m.molecule_id END) * 100.0) / COUNT(DISTINCT m.molecule_id) AS percentageFROM molecule m LEFT JOIN atom a ON m.molecule_id = a.molecule_id WHERE m.label = '+'
SELECT label FROM molecule WHERE molecule_id = 'TR124';
SELECT atom_id, element FROM atom WHERE molecule_id = 'TR186'
SELECT * FROM table
SELECT element FROM atom WHERE atom_id IN (   SELECT atom_id FROM connected WHERE bond_id = 'TR001_2_4'   UNION   SELECT atom_id2 FROM connected WHERE bond_id = 'TR001_2_4'   )
SELECT COUNT(T1.bond_id) AS double_bond_count, T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR000' AND T1.bond_type = '='This revised query will count the double bonds for the molecule with ID 'TR000' and check if it is carcinogenic.
SELECT T1.molecule_id, T2.element FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '+'
SELECT B.bond_id, B.bond_type, C.atom_id, C.atom_id2 FROM bond AS B INNER JOIN connected AS C ON B.bond_id = C.bond_id WHERE B.bond_type = '-'
SELECT DISTINCT m.molecule_id, a.element FROM molecule AS m INNER JOIN bond AS b ON m.molecule_id = b.molecule_id INNER JOIN connected AS c ON b.bond_id = c.bond_id INNER JOIN atom AS a ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2 WHERE b.bond_type = '#'
SELECT T1.element AS atom1_element, T2.element AS atom2_elementFROM connected AS CINNER JOIN atom AS T1 ON C.atom_id = T1.atom_idINNER JOIN atom AS T2 ON C.atom_id2 = T2.atom_idWHERE C.bond_id = 'TR000_2_3'
SELECT COUNT(DISTINCT C.bond_id) FROM connected AS C INNER JOIN atom AS A1 ON C.atom_id = A1.atom_id INNER JOIN atom AS A2 ON C.atom_id2 = A2.atom_id WHERE A1.element = 'cl' OR A2.element = 'cl'
WITH bond_count AS ( SELECT COUNT(DISTINCT bond_type) AS bond_type_count FROM bond WHERE molecule_id = 'TR346')SELECT atom_id, (SELECT bond_type_count FROM bond_count) AS bond_type_count FROM atom WHERE molecule_id = 'TR346';
SELECT COUNT(*) AS total_double_bond_molecules, COUNT(CASE WHEN T2.label = '+' THEN 1 END) AS carcinogenic_double_bond_moleculesFROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '='
SELECT COUNT(DISTINCT m.molecule_id) FROM molecule m WHERE m.molecule_id NOT IN (SELECT DISTINCT molecule_id FROM atom WHERE element = 's') AND m.molecule_id NOT IN (SELECT DISTINCT molecule_id FROM bond WHERE bond_type = '=')
SELECT T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_id = 'TR000_2_4'Since the original query cannot be executed successfully due to the non-existent bond ID, it is necessary to correct the bond ID to one that exists in the database.
`SELECT COUNT(*) FROM atom WHERE molecule_id = 'TR005';`
`SELECT COUNT(*) FROM bond WHERE bond_type = '-';`
SELECT DISTINCT T2.molecule_id, T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'cl' AND T2.label = '+'
SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c' AND T2.label = '-'
SELECT (COUNT(DISTINCT CASE WHEN a.element = 'cl' THEN m.molecule_id END) * 100.0 / COUNT(DISTINCT m.molecule_id)) AS percentageFROM molecule AS mJOIN atom AS a ON m.molecule_id = a.molecule_idWHERE m.label = '+'
`SELECT molecule_id FROM bond WHERE bond_id = 'TR001_1_7';`
SELECT COUNT(DISTINCT element) FROM atom WHERE atom_id IN ( SELECT atom_id FROM connected WHERE bond_id = 'TR001_3_4' UNION SELECT atom_id2 FROM connected WHERE bond_id = 'TR001_3_4')
SELECT T2.bond_type FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id WHERE T1.atom_id = 'TR000_1' AND T1.atom_id2 = 'TR000_2'
SELECT DISTINCT a1.molecule_id FROM atom AS a1 JOIN connected AS c ON a1.atom_id = c.atom_id JOIN atom AS a2 ON c.atom_id2 = a2.atom_id WHERE a1.atom_id = 'TR000_2' AND a2.atom_id = 'TR000_4'
SELECT element FROM atom WHERE atom_id = 'TR000_1';
SELECT label FROM molecule WHERE molecule_id = 'TR000';
SELECT CAST(SUM(CASE WHEN T1.bond_type = '-' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.bond_id) AS percentageFROM bond AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id
SELECT COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'n' AND T2.label = '+'
SELECT m.molecule_id, m.label FROM molecule AS m WHERE m.molecule_id IN ( SELECT c.molecule_id FROM connected AS c INNER JOIN atom AS a1 ON c.atom_id = a1.atom_id INNER JOIN bond AS b ON c.bond_id = b.bond_id WHERE a1.element = 's' AND b.bond_type = ' = ')
SELECT m.molecule_id FROM molecule AS m JOIN atom AS a ON m.molecule_id = a.molecule_id WHERE m.label = '-' GROUP BY m.molecule_id HAVING COUNT(a.atom_id) > 5
SELECT DISTINCT a.element FROM atom AS a JOIN connected AS c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2 JOIN bond AS b ON c.bond_id = b.bond_id WHERE b.molecule_id = 'TR024' AND b.bond_type = '='
SELECT molecule_idFROM ( SELECT a.molecule_id, COUNT(a.atom_id) AS atom_count FROM atom AS a INNER JOIN molecule AS m ON a.molecule_id = m.molecule_id WHERE m.label = '+' GROUP BY a.molecule_id) AS atom_countsORDER BY atom_count DESCLIMIT 1
SELECT (SUM(CASE WHEN m.label = '+' THEN 1 ELSE 0 END) * 100.0) / COUNT(DISTINCT m.molecule_id) AS percentageFROM molecule mJOIN bond b ON m.molecule_id = b.molecule_idJOIN connected c ON b.bond_id = c.bond_idJOIN atom a1 ON c.atom_id = a1.atom_idJOIN atom a2 ON c.atom_id2 = a2.atom_idWHERE (a1.element = 'h' OR a2.element = 'h') AND b.bond_type = '#'
`SELECT COUNT(*) FROM molecule WHERE label = '+';`
SELECT COUNT(*) FROM bond AS B INNER JOIN molecule AS M ON B.molecule_id = M.molecule_id WHERE B.bond_type = '-' AND M.molecule_id BETWEEN 'TR004' AND 'TR010'
SELECT COUNT(*) FROM atom WHERE molecule_id = 'TR008' AND element = 'c';
SELECT a.element FROM atom AS a JOIN molecule AS m ON a.molecule_id = m.molecule_id WHERE a.atom_id = 'TR004_7' AND m.label = '-'
SELECT COUNT(DISTINCT m.molecule_id) FROM molecule AS m JOIN bond AS b ON m.molecule_id = b.molecule_id JOIN connected AS c ON b.bond_id = c.bond_id JOIN atom AS a1 ON c.atom_id = a1.atom_id JOIN atom AS a2 ON c.atom_id2 = a2.atom_id WHERE (a1.element = 'o' OR a2.element = 'o') AND b.bond_type = '='
SELECT COUNT(DISTINCT T1.molecule_id) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#' AND T2.label = '-'
SELECT A.element, B.bond_type FROM molecule AS M LEFT JOIN atom AS A ON M.molecule_id = A.molecule_id LEFT JOIN bond AS B ON M.molecule_id = B.molecule_id WHERE M.molecule_id = 'TR016'
SELECT a.atom_id FROM atom AS a JOIN molecule AS m ON a.molecule_id = m.molecule_id JOIN connected AS c ON a.atom_id = c.atom_id JOIN bond AS b ON c.bond_id = b.bond_id WHERE a.element = 'c' AND b.bond_type = '=' AND m.molecule_id = 'TR012'
SELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.element = 'o'
SELECT id, name FROM cards WHERE cardKingdomFoilId = cardKingdomId AND cardKingdomId IS NOT NULL
SELECT * FROM cards WHERE borderColor = 'borderless' AND cardKingdomFoilId IS NULL AND cardKingdomId IS NULL
SELECT name FROM cards WHERE faceConvertedManaCost = (SELECT MAX(faceConvertedManaCost) FROM cards)
SELECT name FROM cards WHERE frameVersion = '2015' AND edhrecRank < 100
SELECT T1.name, T1.rarity FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'mythic' AND T2.status = 'Banned' AND T2.format = 'gladiator'
SELECT legalities.format, legalities.status FROM cards INNER JOIN legalities ON legalities.uuid = cards.uuid WHERE cards.type = 'Artifact' AND cards.side IS NULL AND legalities.format = 'vintage'
SELECT T1.id, T1.artist FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE (T1.power = '*' OR T1.power IS NULL) AND T2.format = 'commander' AND T2.status = 'Legal'
SELECT C.name AS card_name, R.text AS ruling_text, C.hasContentWarning FROM cards AS C LEFT JOIN rulings AS R ON C.uuid = R.uuid WHERE C.artist = 'Stephen Daniel'
SELECT text FROM rulings WHERE uuid = (SELECT uuid FROM cards WHERE name = 'Sublime Epiphany' AND number = '74s')
SELECT C.name, C.artist, C.isPromo FROM cards AS C WHERE C.uuid = ( SELECT R.uuid FROM rulings AS R GROUP BY R.uuid ORDER BY COUNT(R.uuid) DESC LIMIT 1)
SELECT foreign_data.language FROM cards INNER JOIN foreign_data ON foreign_data.uuid = cards.uuid WHERE cards.name = 'annul' AND cards.number = '29'
SELECT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Japanese'
SELECT (CAST(SUM(CASE WHEN language = 'Chinese Simplified' THEN 1 ELSE 0 END) AS REAL) / COUNT(id)) * 100 AS percentageFROM foreign_data;
SELECT ST.setCode, S.totalSetSize FROM set_translations AS ST INNER JOIN sets AS S ON ST.setCode = S.code WHERE ST.language = 'Italian'
SELECT COUNT(DISTINCT type) FROM cards WHERE artist = 'Aaron Boyd';
SELECT keywords FROM cards WHERE name = 'Angel of Mercy';
SELECT COUNT(*) FROM cards WHERE power = '*'
SELECT promoTypes FROM cards WHERE name = 'Duress' This query directly retrieves the `promoTypes` for the card named 'Duress' without the unnecessary subquery.
`SELECT borderColor FROM cards WHERE name = Ancestor's Chosen`
SELECT originalType FROM cards WHERE name = Ancestor's Chosen;
SELECT st.language FROM set_translations st JOIN sets s ON s.code = st.setCode JOIN cards c ON c.setCode = s.code WHERE c.name = 'Angel of Mercy';
SELECT COUNT(*) FROM cards AS C INNER JOIN legalities AS L ON C.uuid = L.uuid WHERE L.status = 'restricted' AND C.isTextless = 0
SELECT text FROM rulings WHERE uuid = (SELECT uuid FROM cards WHERE name = 'Condemn')
SELECT COUNT(*) FROM cards INNER JOIN legalities ON cards.uuid = legalities.uuid WHERE legalities.status = 'restricted' AND cards.isStarter = 1
SELECT L.status FROM cards AS C INNER JOIN legalities AS L ON C.uuid = L.uuid WHERE C.name = 'Cloudchaser Eagle'
SELECT type FROM cards WHERE name = 'Benalish Knight';
SELECT L.format FROM cards AS C INNER JOIN legalities AS L ON C.uuid = L.uuid WHERE C.name = 'Benalish Knight'
SELECT DISTINCT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Phyrexian'
SELECT (COUNT(CASE WHEN borderColor = 'borderless' THEN 1 END) * 100.0 / COUNT(id)) AS percentage_borderlessFROM cards;
SELECT COUNT(*) FROM cards AS C INNER JOIN foreign_data AS F ON F.uuid = C.uuid WHERE F.language = 'German' AND C.isReprint = 1
SELECT COUNT(*) FROM cards AS C INNER JOIN foreign_data AS F ON F.uuid = C.uuid WHERE C.borderColor = 'borderless' AND F.language = 'Russian'
SELECT (COUNT(CASE WHEN F.language = 'French' THEN 1 END) * 100.0 / COUNT(C.id)) AS percentageFROM cards AS CJOIN foreign_data AS F ON C.uuid = F.uuidWHERE C.isStorySpotlight = 1
SELECT COUNT(*) FROM cards WHERE toughness = 99;
SELECT name FROM cards WHERE artist = 'Aaron Boyd';
SELECT COUNT(*) FROM cards WHERE borderColor = 'black' AND availability = 'mtgo'
SELECT id FROM cards WHERE convertedManaCost = 0
SELECT layout FROM cards WHERE keywords LIKE '%flying%'
SELECT COUNT(*) FROM cards WHERE originalType = 'Summon - Angel' AND subtypes != 'Angel';
SELECT id FROM cards WHERE hasFoil = 1 AND cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL
`SELECT id FROM cards WHERE duelDeck = 'a';`
SELECT edhrecRank FROM cards WHERE frameVersion = '2015';
SELECT DISTINCT T1.artist FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code INNER JOIN set_translations AS T3 ON T2.code = T3.setCode WHERE T3.language = 'Chinese Simplified';
SELECT C.* FROM cards AS C INNER JOIN foreign_data AS F ON C.uuid = F.uuid WHERE C.availability = 'paper' AND F.language = 'Japanese'
SELECT COUNT(*) FROM legalities AS L INNER JOIN cards AS C ON C.uuid = L.uuid WHERE L.status = 'Banned' AND C.borderColor = 'white'
SELECT L.uuid, F.language FROM legalities AS L INNER JOIN cards AS C ON L.uuid = C.uuid INNER JOIN foreign_data AS F ON C.uuid = F.uuid WHERE L.format = 'legacy'
SELECT text FROM rulings WHERE uuid = (SELECT uuid FROM cards WHERE name = 'Beacon of Immortality')
SELECT COUNT(T1.id) AS card_count, T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.frameVersion = 'future' AND T2.status = 'legal'GROUP BY T2.status
SELECT T1.name, T1.colors FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.uuid = T2.setCode WHERE T2.setCode = 'OGW' This query correctly retrieves the names and colors of the cards for the set with code 'OGW'.
SELECT C.name, ST.translation, ST.language FROM cards AS C INNER JOIN sets AS S ON C.uuid = S.id INNER JOIN set_translations AS ST ON S.code = ST.setCode WHERE S.code = '10E' AND C.convertedManaCost = 5
SELECT cards.name, rulings.date FROM cards INNER JOIN rulings ON cards.uuid = rulings.uuid WHERE cards.originalType = 'Creature - Elf'
SELECT cards.colors, legalities.format FROM cards JOIN legalities ON legalities.uuid = cards.uuid WHERE cards.id BETWEEN 1 AND 20
SELECT C.* FROM cards AS C INNER JOIN foreign_data AS F ON C.uuid = F.uuid WHERE C.originalType = 'Artifact' AND C.colors LIKE '%B%'
SELECT cards.name FROM cards INNER JOIN rulings ON cards.uuid = rulings.uuid WHERE cards.rarity = 'uncommon' ORDER BY rulings.date ASC LIMIT 3
SELECT COUNT(*) FROM cards WHERE artist = 'John Avon' AND cardKingdomFoilId IS NULL
SELECT COUNT(*) FROM cards WHERE borderColor = 'white' AND cardKingdomFoilId = cardKingdomId AND cardKingdomId IS NOT NULL
SELECT COUNT(*) FROM cards WHERE artist = 'UDON' AND availability = 'mtgo' AND hand = '-1';
SELECT COUNT(*) FROM cards WHERE frameVersion = '1993' AND availability = 'paper' AND hasContentWarning = 1
SELECT manaCost FROM cards WHERE layout = 'normal' AND frameVersion = '2003' AND borderColor = 'black' AND availability LIKE '%paper%' AND availability LIKE '%mtgo%'
SELECT SUM(CAST(REPLACE(REPLACE(REPLACE(manaCost, '{', ''), '}', ''), ' ', '') AS REAL)) AS total_unconverted_manaFROM cardsWHERE artist = 'Rob Alexander';
SELECT DISTINCT subtypes FROM cards WHERE availability = 'arena'UNIONSELECT DISTINCT supertypes FROM cards WHERE availability = 'arena'
SELECT setCode FROM set_translations WHERE language = 'Spanish';
SELECT (COUNT(CASE WHEN hand = '+3' THEN 1 END) * 100.0 / COUNT(*)) AS percentageFROM cards WHERE frameEffects = 'legendary';
SELECT (SUM(CASE WHEN isStorySpotlight = 1 AND isTextless = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentageFROM cardsWHERE isStorySpotlight = 1;This query calculates the percentage of Story Spotlight cards that do not have a text box by dividing the count of such cards by the total count of Story Spotlight cards and multiplying by 100.
SELECT (COUNT(FD.id) * 100.0 / (SELECT COUNT(*) FROM cards)) AS percentage, FD.nameFROM foreign_data AS FDJOIN cards AS C ON FD.uuid = C.uuidWHERE FD.language = 'Spanish'GROUP BY FD.nameORDER BY FD.name; This query now correctly calculates the percentage of cards in Spanish and lists them by name.
SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.baseSetSize = 309
SELECT COUNT(*) FROM set_translations AS ST INNER JOIN sets AS S ON ST.setCode = S.code WHERE S.block = 'Commander' AND ST.language = 'Portuguese (Brasil)'
SELECT cards.id FROM cards INNER JOIN legalities ON legalities.uuid = cards.uuid WHERE legalities.status = 'legal' AND cards.types LIKE '%Creature%'
SELECT DISTINCT COALESCE(c.subtypes, '') || ' ' || COALESCE(c.supertypes, '') AS card_typeFROM foreign_data AS fJOIN cards AS c ON f.uuid = c.uuidWHERE f.language = 'German' AND (c.subtypes IS NOT NULL OR c.supertypes IS NOT NULL)
SELECT COUNT(*) FROM cards AS c LEFT JOIN foreign_data AS f ON c.uuid = f.uuid WHERE c.power IS NULL AND (c.text LIKE '%trigger%' OR f.text LIKE '%trigger%')
SELECT COUNT(c.id) FROM cards AS c INNER JOIN legalities AS l ON c.uuid = l.uuid INNER JOIN rulings AS r ON c.uuid = r.uuid WHERE l.format = 'pre-modern' AND r.text = 'This is a triggered mana ability' AND c.side IS NULL
SELECT C.id FROM cards AS C INNER JOIN legalities AS L ON C.uuid = L.uuid WHERE C.artist = 'Erica Yang' AND C.availability LIKE '%paper%' AND L.format = 'pauper'
SELECT c.artist FROM foreign_data fd JOIN cards c ON fd.uuid = c.uuid WHERE fd.text = Das perfekte Gegenmittel zu einer dichten Formation;
SELECT foreign_data.name FROM foreign_data INNER JOIN cards ON foreign_data.uuid = cards.uuid WHERE foreign_data.language = 'French' AND cards.type = 'Creature' AND cards.layout = 'normal' AND cards.borderColor = 'black' AND cards.artist = 'Matthew D. Wilson'
SELECT COUNT(DISTINCT c.id) FROM cards AS c INNER JOIN rulings AS r ON c.uuid = r.uuid WHERE c.rarity = 'rare' AND r.date = '2009-01-10'
SELECT ST.language FROM sets AS S INNER JOIN set_translations AS ST ON S.code = ST.setCode WHERE S.baseSetSize = 180 AND S.block = 'Ravnica'
SELECT (SELECT COUNT(cards.id)  FROM cards  INNER JOIN legalities ON cards.uuid = legalities.uuid  WHERE legalities.format = 'commander' AND legalities.status = 'legal' AND cards.hasContentWarning = 0) * 100.0 / (SELECT COUNT(cards.id)  FROM cards  INNER JOIN legalities ON cards.uuid = legalities.uuid  WHERE legalities.format = 'commander' AND legalities.status = 'legal') AS percentage
SELECT (SELECT COUNT(*)  FROM cards AS c  JOIN foreign_data AS f ON c.uuid = f.uuid  WHERE (c.power IS NULL OR c.power = '*') AND f.language = 'French') * 100.0 / (SELECT COUNT(*)  FROM cards  WHERE power IS NULL OR power = '*') AS percentage
SELECT CAST(COUNT(CASE WHEN S.type = 'expansion' THEN 1 END) AS REAL) * 100 / COUNT(ST.language) AS percentageFROM set_translations AS ST INNER JOIN sets AS S ON ST.setCode = S.code WHERE ST.language = 'Japanese'
SELECT availability FROM cards WHERE artist = 'Daren Bader';
SELECT COUNT(*) FROM cards WHERE borderColor = 'borderless' AND edhrecRank > 12000
SELECT COUNT(*) FROM cards WHERE isOversized = 1 AND isReprint = 1 AND isPromo = 1
SELECT name FROM cards WHERE (power IS NULL OR power = '*') AND promoTypes LIKE '%arenaleague%' ORDER BY name LIMIT 3 This query correctly lists the top three unknown power cards that have promotional types for arena league in alphabetical order.
`SELECT language FROM foreign_data WHERE multiverseid = 149934`
SELECT id FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL ORDER BY cardKingdomFoilId ASC LIMIT 3
SELECT (COUNT(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 END) * 100.0) / COUNT(*) AS proportionFROM cards;
SELECT number FROM cards WHERE side IS NULL AND subtypes LIKE '%Angel%' AND subtypes LIKE '%Wizard%'However, since the original query already has the correct structure for checking both subtypes, we can keep it as is. Final answer: SELECT number FROM cards WHERE side IS NULL AND subtypes LIKE '%Angel%' AND subtypes LIKE '%Wizard%' This query is correct as it stands.
SELECT name FROM sets WHERE mtgoCode IS NULL OR mtgoCode = '' ORDER BY name ASC LIMIT 3
SELECT ST.language FROM sets AS S INNER JOIN set_translations AS ST ON S.code = ST.setCode WHERE S.name = 'Archenemy' AND ST.setCode = 'ARC'
SELECT S.name, ST.translation FROM sets AS S INNER JOIN set_translations AS ST ON S.code = ST.setCode WHERE S.id = 5
SELECT ST.language, S.type FROM set_translations AS ST INNER JOIN sets AS S ON S.code = ST.setCode WHERE S.id = 206
SELECT S.id, S.name FROM sets AS S INNER JOIN set_translations AS ST ON S.code = ST.setCode WHERE ST.language = 'Italian' AND S.block = 'Shadowmoor' ORDER BY S.name LIMIT 2
SELECT S.id FROM sets AS S INNER JOIN set_translations AS ST ON S.code = ST.setCode WHERE S.isForeignOnly = 1 AND S.isFoilOnly = 1 AND ST.language = 'Japanese'
SELECT T2.name, T2.baseSetSize FROM sets AS T2 INNER JOIN set_translations AS T1 ON T2.code = T1.setCode WHERE T1.language = 'Russian' AND T2.baseSetSize = (SELECT MAX(baseSetSize) FROM sets AS T3    INNER JOIN set_translations AS T4 ON T3.code = T4.setCode    WHERE T4.language = 'Russian')
SELECT (COUNT(CASE WHEN C.isOnlineOnly = 1 AND ST.language = 'Chinese Simplified' THEN 1 END) * 100.0) / COUNT(CASE WHEN C.isOnlineOnly = 1 THEN 1 END) AS percentageFROM cards AS CJOIN sets AS S ON C.setCode = S.codeJOIN set_translations AS ST ON S.code = ST.setCode
SELECT COUNT(*) FROM sets AS S INNER JOIN set_translations AS ST ON S.code = ST.setCode WHERE ST.language = 'Japanese' AND (S.mtgoCode IS NULL OR S.mtgoCode = '')
SELECT COUNT(id) AS count_black_border FROM cards WHERE borderColor = 'black';
SELECT id FROM cards WHERE frameEffects = 'extendedart';
SELECT name FROM cards WHERE borderColor = 'black' AND isFullArt = 1
SELECT ST.language FROM sets AS S INNER JOIN set_translations AS ST ON S.code = ST.setCode WHERE S.id = 174
SELECT name FROM sets WHERE code = 'ALL';
SELECT foreign_data.language FROM cards INNER JOIN foreign_data ON foreign_data.uuid = cards.uuid WHERE cards.name = 'A Pedra Fellwar'
SELECT code FROM sets WHERE releaseDate = '2007-07-13';
SELECT baseSetSize, code FROM sets WHERE block IN ('Masques', 'Mirage'); This query correctly retrieves the required information based on the provided question.
SELECT setCode FROM sets WHERE type = 'expansion';
SELECT foreign_data.name, cards.type FROM cards INNER JOIN foreign_data ON foreign_data.uuid = cards.uuid WHERE cards.watermark = 'boros'
SELECT foreign_data.language, foreign_data.flavorText, cards.type FROM cards INNER JOIN foreign_data ON cards.uuid = foreign_data.uuid WHERE cards.watermark = 'colorpie'
SELECT (COUNT(CASE WHEN c.convertedManaCost = 10 THEN 1 END) * 100.0 / COUNT(*)) AS percentageFROM cards AS cJOIN sets AS s ON c.setCode = s.codeWHERE s.name = 'Abyssal Horror'
SELECT setCode FROM sets WHERE type = 'commander';
SELECT foreign_data.name, foreign_data.type FROM foreign_data WHERE uuid IN (SELECT uuid FROM cards WHERE watermark = 'abzan')
SELECT foreign_data.language, cards.type FROM cards INNER JOIN foreign_data ON cards.uuid = foreign_data.uuid WHERE cards.watermark = 'azorius'
SELECT COUNT(*) FROM cards WHERE artist = 'Aaron Miller' AND cardKingdomFoilId = cardKingdomId AND cardKingdomId IS NOT NULL
SELECT COUNT(*) FROM cards WHERE availability LIKE '%paper%' AND hand LIKE '+%';
`SELECT name FROM cards WHERE isTextless = 0`
SELECT convertedManaCost FROM cards WHERE name = 'Ancestor\'s Chosen';
SELECT COUNT(*) FROM cards WHERE borderColor = 'white' AND (power = '*' OR power IS NULL);
SELECT name FROM cards WHERE isPromo = 1 AND side IS NOT NULL
SELECT subtypes, supertypes FROM cards WHERE name = 'Molimo, Maro-Sorcerer';
SELECT purchaseUrls FROM cards WHERE promoTypes LIKE '%bundle%';
SELECT COUNT(DISTINCT artist) FROM cards WHERE borderColor = 'black' AND availability LIKE '%arena%' AND availability LIKE '%mtgo%';
SELECT name, convertedManaCost FROM cards WHERE name IN ('Serra Angel', 'Shrine Keeper') ORDER BY convertedManaCost DESC LIMIT 1
SELECT artist FROM cards WHERE flavorName = 'Battra, Dark Destroyer';
SELECT name FROM cards WHERE frameVersion = '2003' ORDER BY convertedManaCost DESC LIMIT 3
SELECT translation FROM set_translations WHERE setCode = ( SELECT setCode FROM foreign_data WHERE uuid = ( SELECT uuid  FROM cards  WHERE name = 'Ancestor\'s Chosen' )) AND language = 'Italian'
SELECT COUNT(*) FROM set_translations WHERE setCode IN (SELECT setCode FROM foreign_data WHERE uuid IN (SELECT uuid FROM cards WHERE name = 'Angel of Mercy'))
SELECT cards.name FROM cards INNER JOIN foreign_data ON cards.uuid = foreign_data.uuid INNER JOIN set_translations ON foreign_data.name = set_translations.translation WHERE set_translations.translation = 'Hauptset Zehnte Edition'
SELECT COUNT(*) > 0 AS has_korean_version FROM cards AS C INNER JOIN foreign_data AS F ON C.uuid = F.uuid WHERE C.name = 'Ancestor''s Chosen' AND F.language = 'Korean'
SELECT COUNT(*) FROM cards AS C INNER JOIN sets AS S ON C.setCode = S.code INNER JOIN set_translations AS ST ON S.code = ST.setCode WHERE ST.translation = 'Hauptset Zehnte Edition' AND C.artist = 'Adam Rex'
SELECT S.baseSetSize FROM sets AS S INNER JOIN set_translations AS ST ON S.code = ST.setCode WHERE ST.translation = 'Hauptset Zehnte Edition'
SELECT ST.translation FROM sets AS S INNER JOIN set_translations AS ST ON ST.setCode = S.code WHERE S.name = 'Eighth Edition' AND ST.language = 'Simplified Chinese'
SELECT name FROM cards WHERE name = 'Angel of Mercy' AND mtgoCode IS NOT NULL
SELECT S.releaseDate FROM cards AS C INNER JOIN legalities AS L ON C.uuid = L.uuid INNER JOIN sets AS S ON L.uuid = S.code WHERE C.name = 'Ancestor''s Chosen' However, since the `sets` table does not have a direct relationship with the `cards` table through `uuid`, the correct approach would be to find the set code from the `cards` table if it exists, or to adjust the query based on the actual schema relationships. The final corrected SQL query is:SELECT S.releaseDate FROM cards AS C INNER JOIN legalities AS L ON C.uuid = L.uuid INNER JOIN sets AS S ON L.uuid = S.uuid WHERE C.name = 'Ancestor''s Chosen' This query assumes that the `cards` table has a `uuid` that can be used to join with the `legalities` table, and then the `uuid` from `legalities` can be used to join with the `sets` table.
SELECT S.type FROM set_translations AS ST INNER JOIN sets AS S ON ST.setCode = S.code WHERE ST.translation = 'Hauptset Zehnte Edition'
SELECT COUNT(*) FROM sets AS S INNER JOIN set_translations AS ST ON S.code = ST.setCode WHERE S.block = 'Ice Age' AND ST.language = 'Italian'
SELECT S.isForeignOnly FROM cards AS C INNER JOIN legalities AS L ON C.uuid = L.uuid INNER JOIN sets AS S ON L.uuid = S.uuid WHERE C.name = 'Adarkar Valkyrie'This query correctly joins the `cards` table with the `legalities` table using the `uuid`, and then joins the `sets` table to access the `isForeignOnly` column.
SELECT COUNT(*) FROM sets AS S INNER JOIN set_translations AS ST ON ST.setCode = S.code WHERE ST.language = 'Italian' AND S.baseSetSize < 10
SELECT COUNT(*) FROM cards AS C INNER JOIN sets AS S ON C.setCode = S.code WHERE S.name = 'Coldsnap' AND C.borderColor = 'black'
SELECT c.name FROM cards cJOIN sets s ON c.setCode = s.code WHERE s.name = 'Coldsnap' AND c.convertedManaCost = (SELECT MAX(convertedManaCost)   FROM cards   WHERE setCode = s.code);
SELECT DISTINCT T1.artist FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T2.name = 'Coldsnap' AND T1.artist IN ('Jeremy Jarvis', 'Aaron Miller', 'Chippy')
SELECT T1.* FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T2.name = 'Coldsnap' AND T1.number = '4'
SELECT COUNT(*) FROM cards WHERE setCode = (SELECT code FROM sets WHERE name = 'Coldsnap') AND convertedManaCost > 5 AND (power = '*' OR power IS NULL)
SELECT F.flavorText FROM foreign_data AS F INNER JOIN cards AS C ON F.uuid = C.uuid WHERE F.language = 'Italian' AND C.name = 'Ancestor''s Chosen'
SELECT DISTINCT foreign_data.language FROM cards INNER JOIN foreign_data ON foreign_data.uuid = cards.uuid WHERE cards.name = 'Ancestor''s Chosen' AND foreign_data.flavorText IS NOT NULL
SELECT F.type FROM foreign_data AS F INNER JOIN cards AS C ON F.uuid = C.uuid WHERE F.language = 'German' AND C.name = 'Ancestor''s Chosen'
SELECT fd.text FROM foreign_data AS fd INNER JOIN cards AS c ON fd.uuid = c.uuid WHERE c.setCode = (SELECT code FROM sets WHERE name = 'Coldsnap') AND fd.language = 'Italian'
SELECT fd.name FROM foreign_data AS fd INNER JOIN cards AS c ON fd.uuid = c.uuid WHERE c.setCode = (SELECT code FROM sets WHERE name = 'Coldsnap') AND c.convertedManaCost = (SELECT MAX(convertedManaCost) FROM cards WHERE setCode = (SELECT code FROM sets WHERE name = 'Coldsnap')) AND fd.language = 'Italian'
SELECT date FROM rulings WHERE uuid = (SELECT uuid FROM cards WHERE name = 'Reminisce')
SELECT CAST(SUM(CASE WHEN T1.convertedManaCost = 7 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) AS percentageFROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T2.name = 'Coldsnap'
SELECT CAST(SUM(CASE WHEN T1.cardKingdomFoilId = T1.cardKingdomId AND T1.cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) AS percentage_incredibly_powerfulFROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T2.name = 'Coldsnap'
SELECT code FROM sets WHERE releaseDate = '2017-07-14'
SELECT keyruneCode FROM sets WHERE code = 'PKHC';
`SELECT mcmId FROM sets WHERE code = 'SS2'`
SELECT mcmName FROM sets WHERE releaseDate = '2017-06-09';
`SELECT type FROM sets WHERE name = 'From the Vault: Lore'`
SELECT parentCode FROM sets WHERE name = 'Commander 2014 Oversized';
SELECT C.name AS card_name, R.text AS ruling_text, C.hasContentWarning FROM cards AS C INNER JOIN rulings AS R ON C.uuid = R.uuid WHERE C.artist = 'Jim Pavelec'
SELECT s.releaseDate FROM sets s JOIN set_transactions st ON s.code = st.setCode JOIN cards c ON st.uuid = c.uuid WHERE c.name = 'Evacuation';
SELECT S.baseSetSize FROM sets AS S INNER JOIN set_translations AS ST ON S.code = ST.setCode WHERE ST.translation = 'Rinascita di Alara'
SELECT type FROM sets WHERE code = (SELECT setCode FROM set_translations WHERE translation = 'Huitime dition')
SELECT translation FROM set_translations WHERE setCode = (SELECT setCode    FROM foreign_data    WHERE uuid = (SELECT uuid    FROM cards    WHERE name = 'Tendo Ice Bridge')) AND language = 'French'
SELECT COUNT(T1.translation) FROM set_translations AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T2.name = 'Salvat 2011' AND T1.translation IS NOT NULL
SELECT translation FROM set_translations WHERE setCode = (SELECT setCode FROM cards WHERE name = 'Fellwar Stone') AND language = 'Japanese'
SELECT c.name FROM cards c JOIN sets s ON c.setCode = s.code WHERE s.name = 'Journey into Nyx Hero''s Path' ORDER BY c.convertedManaCost DESC LIMIT 1 This query correctly retrieves the name of the card with the highest converted mana cost from the specified set.
SELECT S.releaseDate FROM sets AS S INNER JOIN set_translations AS ST ON S.code = ST.setCode WHERE ST.translation = 'Ola de fro'
SELECT s.type FROM sets s JOIN legalities l ON s.uuid = l.uuid JOIN cards c ON l.uuid = c.uuid WHERE c.name = 'Samite Pilgrim';
SELECT COUNT(*) FROM cards AS C INNER JOIN sets AS S ON C.setCode = S.code WHERE S.name = 'World Championship Decks 2004' AND C.convertedManaCost = 3
SELECT ST.translation FROM set_translations AS ST INNER JOIN sets AS S ON ST.setCode = S.code WHERE ST.language = 'Chinese Simplified' AND S.name = 'Mirrodin'
SELECT (COUNT(CASE WHEN s.isNonFoilOnly = 1 THEN 1 END) * 1.0 / COUNT(*)) * 100.0 AS percentage_non_foilFROM foreign_data AS fd JOIN cards AS c ON fd.uuid = c.uuid JOIN sets AS s ON c.setCode = s.code WHERE fd.language = 'Japanese';
SELECT (SUM(CASE WHEN C.isOnlineOnly = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentageFROM foreign_data AS FJOIN cards AS C ON F.uuid = C.uuidWHERE F.language = 'Portuguese (Brazil)'
SELECT availability FROM cards WHERE artist = 'Aleksi Briclot' AND isTextless = 1
SELECT id FROM sets WHERE baseSetSize = (SELECT MAX(baseSetSize) FROM sets);
SELECT artist FROM cards WHERE side IS NULL ORDER BY convertedManaCost DESC LIMIT 1;
SELECT frameEffects, COUNT(*) as countFROM cardsWHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULLGROUP BY frameEffectsORDER BY count DESCLIMIT 1
SELECT COUNT(*) FROM cards WHERE (power IS NULL OR power = '*') AND hasFoil = 0 AND duelDeck = 'A';
SELECT id FROM sets WHERE type = 'commander' ORDER BY totalSetSize DESC LIMIT 1
SELECT T1.name, T1.manaCost FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'duel' ORDER BY T1.manaCost DESC LIMIT 10
SELECT originalReleaseDate, format FROM cards JOIN legalities ON cards.uuid = legalities.uuid WHERE cards.rarity = 'mythic' AND legalities.status = 'legal' AND cards.originalReleaseDate = (SELECT MIN(originalReleaseDate)    FROM cards    WHERE rarity = 'mythic')
SELECT COUNT(*) FROM cards AS C INNER JOIN foreign_data AS F ON F.uuid = C.uuid WHERE C.artist = 'Volkan Baga' AND F.language = 'French'
SELECT COUNT(*) FROM cards AS C INNER JOIN legalities AS L ON C.uuid = L.uuid WHERE C.rarity = 'rare'   AND C.type LIKE '%Enchantment%'   AND C.name = 'Abundance'   AND L.status = 'Legal'
SELECT L.format, C.nameFROM legalities AS LJOIN cards AS C ON L.uuid = C.uuidWHERE L.status = 'banned'GROUP BY L.formatHAVING COUNT(*) = ( SELECT MAX(banned_count) FROM ( SELECT COUNT(*) AS banned_count FROM legalities WHERE status = 'banned' GROUP BY format ))
SELECT ST.language FROM set_translations AS ST INNER JOIN sets AS S ON S.code = ST.setCode WHERE S.name = 'Battlebond'
SELECT legalities.format FROM cards INNER JOIN legalities ON cards.uuid = legalities.uuid WHERE cards.artist = (SELECT artist    FROM cards    GROUP BY artist    ORDER BY COUNT(id) ASC    LIMIT 1) Since the original query is already correct after the analysis, we can return it as is. Final Answer: SELECT legalities.format FROM cards INNER JOIN legalities ON cards.uuid = legalities.uuid WHERE cards.artist = (SELECT artist    FROM cards    GROUP BY artist    ORDER BY COUNT(id) ASC    LIMIT 1)
SELECT L.status FROM cards AS C INNER JOIN legalities AS L ON C.uuid = L.uuid WHERE C.frameVersion = '1997' AND C.artist = 'D. Alexander Gregory' AND C.hasContentWarning = 1 AND L.format = 'legacy'
SELECT cards.name, legalities.format FROM cards INNER JOIN legalities ON cards.uuid = legalities.uuid WHERE cards.edhrecRank = 1 AND legalities.status = 'banned'
WITH SetCount AS ( SELECT COUNT(*) AS total_sets FROM sets WHERE releaseDate BETWEEN '2012-01-01' AND '2015-12-31'),CommonLanguage AS ( SELECT language FROM set_translations WHERE setCode IN (SELECT code FROM sets WHERE releaseDate BETWEEN '2012-01-01' AND '2015-12-31') GROUP BY language ORDER BY COUNT(*) DESC LIMIT 1)SELECT (SELECT total_sets / 4.0 FROM SetCount) AS average_sets_per_year, (SELECT language FROM CommonLanguage) AS common_language;
SELECT DISTINCT artist FROM cards WHERE borderColor = 'black' AND availability = 'arena';
SELECT cards.uuid FROM legalities INNER JOIN cards ON legalities.uuid = cards.uuid WHERE legalities.format = 'oldschool' AND (legalities.status = 'banned' OR legalities.status = 'restricted')
SELECT COUNT(*) FROM cards WHERE artist = 'Matthew D. Wilson' AND availability = 'paper';
SELECT text, date FROM rulings WHERE uuid IN (SELECT uuid FROM cards WHERE artist = 'Kev Walker') ORDER BY date DESC
SELECT cards.name, legalities.format FROM cards JOIN sets ON cards.setCode = sets.code JOIN legalities ON legalities.uuid = cards.uuid WHERE sets.name = 'Hour of Devastation' AND legalities.status = 'Legal'
SELECT DISTINCT S.name FROM sets AS S LEFT JOIN set_translations AS ST ON ST.setCode = S.code WHERE ST.language = 'Korean' AND S.code NOT IN (SELECT setCode FROM set_translations WHERE language = 'Japanese')
SELECT DISTINCT cards.frameVersion, cards.nameFROM cardsLEFT JOIN legalities ON cards.uuid = legalities.uuidWHERE cards.artist = 'Allen Williams' AND (legalities.status = 'banned' OR legalities.status IS NULL)This query will return all frame styles and cards Allen Williams worked on, including any banned cards if they exist.
SELECT DisplayName, Reputation FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon') ORDER BY Reputation DESC LIMIT 1
SELECT DisplayName FROM users WHERE strftime('%Y', CreationDate) = '2014';
`SELECT COUNT(*) FROM users WHERE LastAccessDate > '2014-09-01 00:00:00';`
SELECT DisplayName FROM users WHERE Views = (SELECT MAX(Views) FROM users);
SELECT COUNT(*) FROM users WHERE UpVotes > 100 AND DownVotes > 1
SELECT COUNT(*) FROM users WHERE Views > 10 AND CreationDate > '2013-12-31';
SELECT COUNT(*) FROM posts AS P INNER JOIN users AS U ON P.OwnerUserId = U.Id WHERE U.DisplayName = 'csgillespie'
SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie'
SELECT OwnerDisplayName FROM posts WHERE Title = 'Eliciting priors from experts';This query correctly retrieves the display name of the owner of the post with the specified title.
SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie' AND T1.ViewCount = (SELECT MAX(ViewCount) FROM posts WHERE OwnerUserId = T2.Id)
SELECT users.DisplayName FROM users INNER JOIN posts ON users.Id = posts.OwnerUserId WHERE posts.FavoriteCount = (SELECT MAX(FavoriteCount) FROM posts)
SELECT SUM(posts.CommentCount) FROM posts INNER JOIN users ON posts.OwnerUserId = users.Id WHERE users.DisplayName = 'csgillespie'
SELECT AnswerCount FROM posts WHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'csgillespie') ORDER BY AnswerCount DESC LIMIT 1
SELECT U.DisplayName FROM posts AS P INNER JOIN users AS U ON P.LastEditorUserId = U.Id WHERE P.Title = 'Examples for teaching: Correlation does not mean causation'
SELECT COUNT(*) FROM posts AS P INNER JOIN users AS U ON P.OwnerUserId = U.Id WHERE U.DisplayName = 'csgillespie' AND P.ParentId IS NULL
SELECT users.DisplayName FROM posts INNER JOIN users ON posts.OwnerUserId = users.Id WHERE posts.ClosedDate IS NOT NULL
SELECT COUNT(*) FROM posts AS P INNER JOIN users AS U ON P.OwnerUserId = U.Id WHERE U.Age > 65 AND P.Score >= 20
SELECT U.Location FROM posts AS P INNER JOIN users AS U ON P.OwnerUserId = U.Id WHERE P.Title = 'Eliciting priors from experts'
SELECT Body FROM posts WHERE Id = (SELECT ExcerptPostId FROM tags WHERE TagName = 'bayesian')
SELECT Body FROM posts WHERE Id = (SELECT ExcerptPostId FROM tags WHERE Count = (SELECT MAX(Count) FROM tags))
SELECT COUNT(*) FROM badges AS B INNER JOIN users AS U ON B.UserId = U.Id WHERE U.DisplayName = 'csgillespie'
SELECT badges.Name FROM badges INNER JOIN users ON badges.UserId = users.Id WHERE users.DisplayName = 'csgillespie'
SELECT COUNT(*) FROM badges AS B INNER JOIN users AS U ON B.UserId = U.Id WHERE U.DisplayName = 'csgillespie' AND strftime('%Y', B.Date) = '2011'
SELECT u.DisplayName FROM users u WHERE u.Id = ( SELECT UserId FROM badges GROUP BY UserId HAVING COUNT(Id) = ( SELECT MAX(badge_count)  FROM (SELECT UserId, COUNT(Id) AS badge_count FROM badges GROUP BY UserId) ))
SELECT AVG(posts.Score) FROM posts INNER JOIN users ON posts.OwnerUserId = users.Id WHERE users.DisplayName = 'csgillespie'
SELECT CAST(COUNT(badges.Id) AS REAL) / COUNT(DISTINCT users.DisplayName) AS average_badgesFROM badgesINNER JOIN users ON badges.UserId = users.IdWHERE users.Views > 200
SELECT (SELECT COUNT(posts.Id)  FROM posts  INNER JOIN users ON posts.OwnerUserId = users.Id  WHERE users.Age > 65 AND posts.Score > 20) * 100.0 / (SELECT COUNT(Id) FROM posts WHERE Score > 20) AS Percentage
SELECT COUNT(*) FROM votes WHERE UserId = 58 AND CreationDate = '2010-07-19';
SELECT CreationDate FROM votes GROUP BY CreationDate HAVING COUNT(Id) = (SELECT MAX(vote_count)  FROM (SELECT COUNT(Id) AS vote_count    FROM votes    GROUP BY CreationDate)) LIMIT 1;
`SELECT COUNT(*) FROM badges WHERE Name = 'Revival';`
SELECT Title FROM posts WHERE Id = (SELECT PostId FROM comments WHERE Score = (SELECT MAX(Score) FROM comments) LIMIT 1)
SELECT CommentCount FROM posts WHERE ViewCount = 1910
SELECT T2.FavoriteCount FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.UserId = '3025' AND T1.CreationDate = '2014-04-23 20:29:39'
SELECT C.Text FROM comments AS C INNER JOIN posts AS P ON C.PostId = P.Id WHERE P.ParentId = 107829 AND P.CommentCount = 1 LIMIT 1
SELECT CASE  WHEN T2.ClosedDate IS NULL THEN 'Not well-finished'  ELSE 'Well-finished' END AS PostStatusFROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.UserId = 23853 AND T1.CreationDate = '2013-07-12 09:08:18.0'
SELECT U.Reputation FROM posts AS P INNER JOIN users AS U ON P.OwnerUserId = U.Id WHERE P.Id = 65041
SELECT COUNT(*) FROM posts AS P INNER JOIN users AS U ON P.OwnerUserId = U.Id WHERE U.DisplayName = 'Tiago Pasqualini'
SELECT users.DisplayName FROM votes INNER JOIN users ON votes.UserId = users.Id WHERE votes.Id = 6347
SELECT COUNT(T1.Id) FROM votes AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title LIKE '%data visualization%'
SELECT badges.Name FROM badges INNER JOIN users ON badges.UserId = users.Id WHERE users.DisplayName = 'DatEpicCoderGuyWhoPrograms'
SELECT (SELECT COUNT(Id) FROM posts WHERE OwnerUserId = 24) * 1.0 / (SELECT COUNT(Id) FROM votes WHERE UserId = 24) AS post_to_vote_ratio
SELECT ViewCount FROM posts WHERE Title = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer';
SELECT Text FROM comments WHERE Score = 17
SELECT DisplayName FROM users WHERE WebsiteUrl = 'http://stackoverflow.com';
SELECT badges.Name FROM badges INNER JOIN users ON badges.UserId = users.Id WHERE users.DisplayName = 'SilentGhost'
SELECT users.DisplayName FROM comments INNER JOIN users ON comments.UserId = users.Id WHERE comments.Text = 'thank you user93!'
SELECT comments.Text FROM comments INNER JOIN users ON comments.UserId = users.Id WHERE users.DisplayName = 'A Lion'
SELECT U.DisplayName, U.Reputation FROM posts AS P INNER JOIN users AS U ON P.OwnerUserId = U.Id WHERE P.Title = 'Understanding what Dassault iSight is doing?'
SELECT comments.Text FROM comments INNER JOIN posts ON posts.Id = comments.PostId WHERE posts.Title = 'How does gentle boosting differ from AdaBoost?'
SELECT users.DisplayName FROM badges INNER JOIN users ON badges.UserId = users.Id WHERE badges.Name = 'Necromancer' LIMIT 10
SELECT LastEditorDisplayName FROM posts WHERE Title = 'Open source tools for visualizing multi-dimensional data';
SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T2.DisplayName = 'Vebjorn Ljosa'
SELECT SUM(posts.Score) AS TotalScore, users.WebsiteUrlFROM postsINNER JOIN users ON posts.LastEditorUserId = users.IdWHERE users.DisplayName = 'Yevgeny'GROUP BY users.WebsiteUrl
SELECT Text FROM comments WHERE UserId IN ( SELECT UserId FROM postHistory WHERE PostId = ( SELECT Id FROM posts WHERE Title = 'Why square the difference instead of taking the absolute value in standard deviation?' ))
SELECT SUM(v.BountyAmount) FROM votes AS v INNER JOIN posts AS p ON v.PostId = p.Id WHERE p.Title LIKE '%data%'
SELECT u.DisplayName FROM users AS u WHERE u.Id IN ( SELECT v.UserId FROM votes AS v WHERE v.BountyAmount = 50 AND v.PostId IN ( SELECT p.Id  FROM posts AS p  WHERE p.Title LIKE '%variance%' ))
SELECT AVG(p.ViewCount) AS AverageViewCount, p.Title, GROUP_CONCAT(c.Text) AS Comments,  -- Aggregate comments into a single string p.ScoreFROM posts AS pJOIN tags AS t ON p.Tags LIKE '%' || t.TagName || '%'  -- Assuming Tags is a string of comma-separated tagsLEFT JOIN comments AS c ON p.Id = c.PostIdWHERE t.TagName = 'humor'GROUP BY p.Id, p.Title, p.Score
SELECT COUNT(*) FROM comments WHERE UserId = 13
`SELECT Id FROM users WHERE Reputation = (SELECT MAX(Reputation) FROM users);`
`SELECT Id FROM users WHERE Views = (SELECT MIN(Views) FROM users);`
SELECT COUNT(DISTINCT UserId) FROM badges WHERE Name = 'Supporter' AND strftime('%Y', Date) = '2011';
SELECT COUNT(*) FROM (SELECT UserId FROM badges GROUP BY UserId HAVING COUNT(Name) > 5); This revised query counts the number of users who have more than 5 badges by first selecting the `UserId` of those users and then counting the number of distinct users in the outer query.
SELECT COUNT(DISTINCT U.Id) FROM users AS U JOIN badges AS B ON U.Id = B.UserId WHERE U.Location = 'New York' AND B.Name IN ('Supporter', 'Teacher') GROUP BY U.Id HAVING COUNT(DISTINCT B.Name) = 2
SELECT users.DisplayName, users.Reputation FROM posts INNER JOIN users ON posts.OwnerUserId = users.Id WHERE posts.Id = 1
SELECT u.Id, u.DisplayName FROM users u INNER JOIN postHistory ph ON u.Id = ph.UserId INNER JOIN posts p ON ph.PostId = p.Id WHERE p.ViewCount >= 1000 GROUP BY u.Id HAVING COUNT(ph.PostId) = 1
SELECT b.UserId, b.Name FROM badges AS b WHERE b.UserId = ( SELECT UserId FROM comments GROUP BY UserId ORDER BY COUNT(Id) DESC LIMIT 1)
SELECT COUNT(DISTINCT U.Id) FROM users AS U INNER JOIN badges AS B ON U.Id = B.UserId WHERE U.Location = 'India' AND B.Name = 'Teacher'
SELECT (  (SELECT COUNT(*) FROM badges WHERE Name = 'Students' AND strftime('%Y', Date) = '2010') * 100.0 /  (SELECT COUNT(*) FROM badges WHERE Name = 'Students' AND (strftime('%Y', Date) = '2010' OR strftime('%Y', Date) = '2011')) ) - ( (SELECT COUNT(*) FROM badges WHERE Name = 'Students' AND strftime('%Y', Date) = '2011') * 100.0 /  (SELECT COUNT(*) FROM badges WHERE Name = 'Students' AND (strftime('%Y', Date) = '2010' OR strftime('%Y', Date) = '2011')) )) AS percentage_difference
SELECT PostHistoryTypeId FROM postHistory WHERE PostId = 3720;SELECT COUNT(DISTINCT UserId) FROM comments WHERE PostId = 3720;However, if we want to combine the results into a single output, we can use a common table expression (CTE) or a subquery. Heres an example of how to do that:WITH CommentCount AS ( SELECT COUNT(DISTINCT UserId) AS UniqueUserCount FROM comments WHERE PostId = 3720)SELECT PostHistoryTypeId, (SELECT UniqueUserCount FROM CommentCount) AS UniqueUserCount FROM postHistory WHERE PostId = 3720;This query retrieves the post history type IDs for post ID 3720 and the count of unique users who have commented on that post in a single result set.
SELECT T1.RelatedPostId, T2.ViewCount FROM postLinks AS T1 INNER JOIN posts AS T2 ON T1.RelatedPostId = T2.Id WHERE T1.PostId = 61217
SELECT T1.Score, T2.LinkTypeId FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId WHERE T1.Id = 395
SELECT Id, OwnerUserId FROM posts WHERE Score > 60
SELECT SUM(posts.FavoriteCount) FROM posts INNER JOIN users ON posts.OwnerUserId = users.Id WHERE posts.OwnerUserId = 686 AND strftime('%Y', posts.CreationDate) = '2011'
SELECT AVG(u.UpVotes) AS average_up_votes, AVG(u.Age) AS average_ageFROM users AS uJOIN posts AS p ON u.Id = p.OwnerUserIdGROUP BY u.IdHAVING COUNT(p.Id) > 10This ensures that the average calculations are based on the correct grouping of users and their associated posts.
`SELECT COUNT(DISTINCT UserId) AS UserCount FROM badges WHERE Name = 'Announcer';`
SELECT Name FROM badges WHERE Date = '2010-07-19 19:39:08';
`SELECT COUNT(*) AS PositiveCommentCount FROM comments WHERE Score > 60;`
`SELECT Text FROM comments WHERE CreationDate = '2010-07-19 19:25:47'`
SELECT COUNT(*) FROM posts WHERE Score = 10
SELECT badges.Name FROM badges WHERE badges.UserId IN (SELECT Id FROM users WHERE Reputation = (SELECT MAX(Reputation) FROM users))
SELECT u.Reputation FROM badges AS b INNER JOIN users AS u ON b.UserId = u.Id WHERE b.Date = '2010-07-19 19:39:08'
SELECT B.Name FROM badges AS B INNER JOIN users AS U ON B.UserId = U.Id WHERE U.DisplayName = 'Pierre'
SELECT badges.Date FROM badges INNER JOIN users ON badges.UserId = users.Id WHERE users.Location = 'Rochester, NY'
SELECT CAST(COUNT(DISTINCT T1.UserId) AS REAL) * 100 / (SELECT COUNT(*) FROM users) AS percentage FROM badges AS T1 WHERE T1.Name = 'Teacher'
SELECT (COUNT(DISTINCT CASE WHEN u.Age BETWEEN 13 AND 18 THEN b.UserId END) * 100.0) / COUNT(DISTINCT b.UserId) AS TeenagerPercentageFROM badges AS b INNER JOIN users AS u ON b.UserId = u.Id WHERE b.Name = 'Organizer'
SELECT comments.Score FROM posts INNER JOIN comments ON posts.Id = comments.PostId WHERE posts.CreationDate = '2010-07-19 19:19:56.0' After correcting the typo in the column name, the final SQL query is:SELECT comments.Score FROM posts INNER JOIN comments ON posts.Id = comments.PostId WHERE posts.CreationDate = '2010-07-19 19:19:56.0' This query is now correct and does not require any further changes.
SELECT comments.Text FROM comments INNER JOIN posts ON comments.PostId = posts.Id WHERE posts.CreationDate = '2010-07-19 19:37:33.0'
SELECT U.Age FROM users AS U INNER JOIN badges AS B ON U.Id = B.UserId WHERE U.Location = 'Vienna, Austria'
SELECT COUNT(*) FROM badges AS B INNER JOIN users AS U ON B.UserId = U.Id WHERE B.Name = 'Supporter' AND U.Age BETWEEN 19 AND 65
SELECT users.Views FROM badges INNER JOIN users ON badges.UserId = users.Id WHERE badges.Date = '2010-07-19 19:39:08.0'
SELECT badges.Name FROM badges WHERE UserId IN (SELECT Id FROM users WHERE Reputation = (SELECT MIN(Reputation) FROM users))
SELECT T1.Name FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Sharpie'
SELECT COUNT(*) FROM badges AS B INNER JOIN users AS U ON B.UserId = U.Id WHERE B.Name = 'Supporter' AND U.Age > 65
SELECT DisplayName FROM users WHERE Id = 30
`SELECT COUNT(*) FROM users WHERE Location = 'New York';`
`SELECT COUNT(*) AS VoteCount FROM votes WHERE strftime('%Y', CreationDate) = '2010';`
SELECT COUNT(*) FROM users WHERE Age BETWEEN 19 AND 65
SELECT DisplayName FROM users WHERE Views = (SELECT MAX(Views) FROM users);
SELECT CAST(COUNT(CASE WHEN strftime('%Y', CreationDate) = '2010' THEN Id END) AS REAL) /  COUNT(CASE WHEN strftime('%Y', CreationDate) = '2011' THEN Id END) AS ratio FROM votes
SELECT tags.TagName FROM tags INNER JOIN posts ON tags.ExcerptPostId = posts.Id WHERE posts.OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'John Stauffer')
SELECT COUNT(*) FROM posts AS P INNER JOIN users AS U ON P.OwnerUserId = U.Id WHERE U.DisplayName = 'Daniel Vassallo'
SELECT COUNT(*) FROM votes AS V INNER JOIN users AS U ON V.UserId = U.Id WHERE U.DisplayName = 'Harlan'
SELECT Id FROM posts WHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'slashnick') AND AnswerCount = (SELECT MAX(AnswerCount) FROM posts WHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'slashnick'));
SELECT u.DisplayName, SUM(p.ViewCount) AS TotalViewCount FROM users u JOIN posts p ON u.Id = p.OwnerUserId WHERE u.DisplayName IN ('Harvey Motulsky', 'Noah Snyder') GROUP BY u.DisplayName ORDER BY TotalViewCount DESC LIMIT 1
SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id INNER JOIN votes AS T3 ON T1.Id = T3.PostId WHERE T2.DisplayName = 'Matt Parker' GROUP BY T1.Id HAVING COUNT(T3.PostId) > 4 This query counts the number of posts by 'Matt Parker' that have more than 4 votes.
SELECT COUNT(*) FROM comments AS C INNER JOIN posts AS P ON C.PostId = P.Id INNER JOIN users AS U ON P.OwnerUserId = U.Id WHERE C.Score < 60 AND U.DisplayName = 'Neil McGuigan'
SELECT t.TagName FROM tags t JOIN posts p ON p.Tags LIKE '%' || t.TagName || '%' WHERE p.OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'Mark Meckes') AND p.CommentCount = 0
SELECT users.DisplayName FROM badges INNER JOIN users ON badges.UserId = users.Id WHERE badges.Name = 'Organizer'
SELECT (COUNT(T1.PostId) * 100.0 / (SELECT COUNT(*) FROM posts WHERE OwnerDisplayName = 'Community')) AS percentageFROM posts AS T1INNER JOIN tags AS T2 ON T1.Id = T2.ExcerptPostIdWHERE T1.OwnerDisplayName = 'Community' AND T2.TagName = 'r'
SELECT SUM(CASE WHEN U.DisplayName = 'Mornington' THEN P.ViewCount ELSE 0 END) - SUM(CASE WHEN U.DisplayName = 'Amos' THEN P.ViewCount ELSE 0 END) AS ViewCountDifferenceFROM posts AS P INNER JOIN users AS U ON P.OwnerUserId = U.Id
SELECT COUNT(DISTINCT UserId) FROM badges WHERE Name = 'commentator' AND strftime('%Y', Date) = '2014';
SELECT COUNT(*) FROM posts WHERE CreationDate BETWEEN '2010-07-21 00:00:00' AND '2010-07-21 23:59:59';
SELECT DisplayName, Age FROM users WHERE Views = (SELECT MAX(Views) FROM users);
SELECT LastEditDate, LastEditorUserId FROM posts WHERE Title = 'Detecting a given face in a database of facial images';
SELECT COUNT(*) FROM comments WHERE Score < 60 AND UserId = 13
SELECT posts.Title, comments.UserDisplayName FROM posts INNER JOIN comments ON comments.PostId = posts.Id WHERE comments.Score > 60
SELECT B.Name FROM badges AS B INNER JOIN users AS U ON B.UserId = U.Id WHERE U.Location = 'North Pole' AND strftime('%Y', B.Date) = '2011'
SELECT users.DisplayName, users.WebsiteUrl FROM posts INNER JOIN users ON posts.OwnerUserId = users.Id WHERE posts.FavoriteCount > 150
SELECT COUNT(T1.Id) AS PostHistoryCount, T2.LastEditDate FROM postHistory AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'What is the best introductory Bayesian statistics textbook?'
SELECT users.LastAccessDate, users.Location FROM badges INNER JOIN users ON badges.UserId = users.Id WHERE badges.Name = 'Outliers'
SELECT T2.Title FROM posts AS T1 INNER JOIN postLinks AS T3 ON T1.Id = T3.PostId INNER JOIN posts AS T2 ON T3.RelatedPostId = T2.Id WHERE T1.Title = 'How to tell if something happened in a data set which monitors a value over time'
SELECT P.Id AS PostId, B.Name AS BadgeName FROM posts AS P JOIN users AS U ON P.OwnerUserId = U.Id JOIN badges AS B ON U.Id = B.UserId WHERE U.DisplayName = 'Samuel' AND (strftime('%Y', P.CreationDate) = '2013' OR strftime('%Y', B.Date) = '2013')
SELECT OwnerDisplayName FROM posts WHERE ViewCount = (SELECT MAX(ViewCount) FROM posts);
SELECT DisplayName, Location FROM users WHERE Id = ( SELECT OwnerUserId FROM posts WHERE Id = ( SELECT ExcerptPostId  FROM tags  WHERE TagName = 'hypothesis-testing' ))
SELECT T2.Title, T1.LinkTypeId FROM postLinks AS T1 INNER JOIN posts AS T2 ON T1.RelatedPostId = T2.Id WHERE T1.PostId = (SELECT Id FROM posts WHERE Title = 'What are principal component scores?')
SELECT T2.OwnerDisplayName FROM posts AS T1 INNER JOIN posts AS T2 ON T1.ParentId = T2.Id WHERE T1.Id = (SELECT Id FROM posts WHERE ParentId IS NOT NULL ORDER BY Score DESC LIMIT 1) There are no issues with the original query, and it correctly addresses the question.
SELECT u.DisplayName, u.WebsiteUrl FROM users u INNER JOIN votes v ON u.Id = v.UserId WHERE v.BountyAmount = (SELECT MAX(BountyAmount) FROM votes WHERE VoteTypeId = 8) AND v.VoteTypeId = 8
SELECT Title FROM posts ORDER BY ViewCount DESC LIMIT 5;
SELECT COUNT(*) FROM tags WHERE Count BETWEEN 5000 AND 7000
SELECT OwnerUserId FROM posts WHERE FavoriteCount = (SELECT MAX(FavoriteCount) FROM posts);
SELECT Age FROM users WHERE Reputation = (SELECT MAX(Reputation) FROM users);
SELECT COUNT(DISTINCT T1.Id) FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId WHERE strftime('%Y', T2.CreationDate) = '2011' AND T2.BountyAmount = 50
SELECT Id FROM users WHERE Age = (SELECT MIN(Age) FROM users);
SELECT Score FROM posts WHERE Id IN ( SELECT postLinks.PostId FROM postLinks INNER JOIN tags ON postLinks.RelatedPostId = tags.Id WHERE tags.Count = (SELECT MAX(Count) FROM tags))
SELECT COUNT(pl.Id) / 12.0 AS AverageMonthlyLinks FROM postLinks AS pl INNER JOIN posts AS p ON pl.PostId = p.Id WHERE strftime('%Y', pl.CreationDate) = '2010' AND p.AnswerCount <= 2
SELECT Id FROM posts WHERE FavoriteCount = (   SELECT MAX(FavoriteCount) FROM posts INNER JOIN votes ON posts.Id = votes.PostId WHERE votes.UserId = 1465   )
SELECT p.Title FROM posts AS p INNER JOIN postLinks AS pl ON p.Id = pl.PostId WHERE pl.CreationDate = (SELECT MIN(CreationDate) FROM postLinks) The only change is correcting the typo in the `posts` table, but since the query does not reference `CreaionDate`, it remains unchanged. Therefore, the final SQL query is correct as is. Final Answer: SELECT p.Title FROM posts AS p INNER JOIN postLinks AS pl ON p.Id = pl.PostId WHERE pl.CreationDate = (SELECT MIN(CreationDate) FROM postLinks)
SELECT u.DisplayNameFROM users uJOIN ( SELECT UserId, COUNT(Name) AS BadgeCount FROM badges GROUP BY UserId) b ON u.Id = b.UserIdWHERE b.BadgeCount = (SELECT MAX(BadgeCount)    FROM (SELECT UserId, COUNT(Name) AS BadgeCount  FROM badges  GROUP BY UserId))
SELECT MIN(CreationDate) FROM votes WHERE UserId = (SELECT Id FROM users WHERE DisplayName = 'chl')
SELECT MIN(CreationDate) FROM posts WHERE OwnerUserId = (SELECT Id FROM users WHERE Age = (SELECT MIN(Age) FROM users))
SELECT u.DisplayName FROM users AS u WHERE u.Id = (SELECT UserId FROM badges WHERE Name = 'Autobiographer' AND Date = (SELECT MIN(Date) FROM badges WHERE Name = 'Autobiographer'))
SELECT COUNT(DISTINCT U.Id) FROM users AS U INNER JOIN posts AS P ON U.Id = P.OwnerUserId WHERE U.Location = 'United Kingdom' AND P.FavoriteCount >= 4
SELECT AVG(vote_count) FROM ( SELECT COUNT(PostId) AS vote_count FROM votes WHERE UserId IN (SELECT Id FROM users WHERE Age = (SELECT MAX(Age) FROM users)) GROUP BY UserId);
SELECT DisplayName FROM users WHERE Reputation = (SELECT MAX(Reputation) FROM users);
SELECT COUNT(*) FROM users WHERE Reputation > 2000 AND Views > 1000
SELECT DisplayName FROM users WHERE Age BETWEEN 19 AND 65
SELECT COUNT(*) FROM posts AS P INNER JOIN users AS U ON P.OwnerUserId = U.Id WHERE U.DisplayName = 'Jay Stevens' AND strftime('%Y', P.CreationDate) = '2010'
SELECT T1.Id, T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'Harvey Motulsky' ORDER BY T1.ViewCount DESC LIMIT 1
SELECT p.Id, p.Title, u.DisplayName FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE p.Score = (SELECT MAX(Score) FROM posts);
SELECT AVG(posts.Score) FROM posts INNER JOIN users ON posts.OwnerUserId = users.Id WHERE users.DisplayName = 'Stephen Turner'
SELECT DISTINCT users.DisplayName FROM posts INNER JOIN users ON posts.OwnerUserId = users.Id WHERE posts.ViewCount > 20000 AND strftime('%Y', posts.CreationDate) = '2011'
SELECT P.Id, U.DisplayName FROM posts AS P INNER JOIN users AS U ON P.OwnerUserId = U.Id WHERE P.FavoriteCount = ( SELECT MAX(FavoriteCount) FROM posts WHERE strftime('%Y', CreationDate) = '2010')AND strftime('%Y', P.CreationDate) = '2010'
SELECT (COUNT(p.Id) * 100.0 / (SELECT COUNT(p2.Id) FROM posts p2 WHERE strftime('%Y', p2.CreationDate) = '2011')) AS percentageFROM posts p INNER JOIN users u ON p.OwnerUserId = u.Id WHERE strftime('%Y', p.CreationDate) = '2011' AND u.Reputation > 1000
SELECT (COUNT(CASE WHEN Age BETWEEN 13 AND 18 THEN 1 END) * 100.0 / COUNT(Id)) AS percentageFROM users;
SELECT p.ViewCount, u.DisplayName FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE p.Title = 'Computer Game Datasets';
SELECT COUNT(*) FROM posts WHERE ViewCount > (SELECT AVG(ViewCount) FROM posts)
SELECT COUNT(*) AS CommentCount FROM comments WHERE PostId = (SELECT Id FROM posts WHERE Score = (SELECT MAX(Score) FROM posts))
SELECT COUNT(*) FROM posts WHERE ViewCount > 35000 AND CommentCount = 0
SELECT u.DisplayName, u.Location FROM users AS u WHERE u.Id = (SELECT LastEditorUserId FROM posts WHERE Id = 183)
SELECT Name FROM badges WHERE UserId = (SELECT Id FROM users WHERE DisplayName = 'Emmett') AND Date = (SELECT MAX(Date) FROM badges WHERE UserId = (SELECT Id FROM users WHERE DisplayName = 'Emmett'));This query will correctly identify the latest badge awarded to the user with the display name 'Emmett'.
SELECT COUNT(*) FROM users WHERE Age BETWEEN 19 AND 65 AND UpVotes > 5000
SELECT julianday(badges.Date) - julianday(users.CreationDate) AS days_to_get_badgeFROM badges INNER JOIN users ON badges.UserId = users.Id WHERE users.DisplayName = 'Zolomon'
SELECT (SELECT COUNT(Id) FROM posts WHERE OwnerUserId = (SELECT Id FROM users WHERE CreationDate = (SELECT MAX(CreationDate) FROM users))) AS PostCount, (SELECT COUNT(Id) FROM comments WHERE UserId = (SELECT Id FROM users WHERE CreationDate = (SELECT MAX(CreationDate) FROM users))) AS CommentCountThis query now correctly counts the number of posts and comments left by the user with the latest created account.
SELECT c.Text, c.UserDisplayName FROM comments AS c WHERE c.PostId = (SELECT Id FROM posts WHERE Title = 'Analysing wind data with R') AND c.CreationDate = (SELECT MAX(CreationDate) FROM comments WHERE PostId = (SELECT Id FROM posts WHERE Title = 'Analysing wind data with R'))
SELECT COUNT(DISTINCT UserId) FROM badges WHERE Name = 'Citizen Patrol';
The query cannot be executed as is due to the missing `postTags` table in the schema.
SELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon';
SELECT COUNT(c.Id) AS CommentCount, p.AnswerCountFROM posts AS pLEFT JOIN comments AS c ON p.Id = c.PostIdWHERE p.Title = 'Clustering 1D data'GROUP BY p.Id
SELECT CreationDate FROM users WHERE DisplayName = 'IrishStat';
SELECT COUNT(DISTINCT PostId) FROM votes WHERE BountyAmount > 30This query counts the distinct `PostId` from the `votes` table where the `BountyAmount` is greater than 30, which directly answers the question.
SELECT (COUNT(CASE WHEN Score >= 50 THEN 1 END) * 100.0 / COUNT(*)) AS percentageFROM posts WHERE OwnerUserId = (SELECT Id FROM users ORDER BY Reputation DESC LIMIT 1)
SELECT COUNT(*) FROM posts WHERE Score < 20
SELECT COUNT(*) FROM tags WHERE Id < 15 AND Count <= 20
SELECT ExcerptPostId, WikiPostId FROM tags WHERE TagName = 'sample';
SELECT users.Reputation, users.UpVotes FROM comments INNER JOIN users ON comments.UserId = users.Id WHERE comments.Text = 'fine, you win :)'
SELECT comments.Text FROM comments INNER JOIN posts ON comments.PostId = posts.Id WHERE posts.Title = 'linear regression'
SELECT Text FROM comments WHERE PostId IN (SELECT Id FROM posts WHERE ViewCount BETWEEN 100 AND 150) AND Score = (SELECT MAX(Score)   FROM comments   WHERE PostId IN (SELECT Id FROM posts WHERE ViewCount BETWEEN 100 AND 150));This query will correctly return the comment text with the highest score among the specified posts.
SELECT users.CreationDate, users.Age FROM comments INNER JOIN users ON comments.UserId = users.Id WHERE comments.Text LIKE '%http://%'
SELECT COUNT(DISTINCT T1.PostId) FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.Score = 0 AND T2.ViewCount < 5
SELECT COUNT(comments.Id) FROM posts JOIN comments ON posts.Id = comments.PostId WHERE posts.CommentCount = 1 AND comments.Score = 0
SELECT COUNT(DISTINCT users.Id) FROM comments INNER JOIN users ON comments.UserId = users.Id WHERE comments.Score = 0 AND users.Age = 40
SELECT posts.Id AS PostId, comments.Text FROM posts INNER JOIN comments ON posts.Id = comments.PostId WHERE posts.Title = 'Group differences on a five point Likert item'
SELECT U.UpVotes FROM comments AS C INNER JOIN users AS U ON C.UserId = U.Id WHERE C.Text = 'R is also lazy evaluated.'
SELECT C.Text FROM comments AS C INNER JOIN users AS U ON C.UserId = U.Id WHERE U.DisplayName = 'Harvey Motulsky'
SELECT users.DisplayName FROM comments INNER JOIN users ON comments.UserId = users.Id WHERE comments.Score BETWEEN 1 AND 5 AND users.DownVotes = 0
SELECT (COUNT(CASE WHEN u.UpVotes = 0 THEN 1 END) * 100.0 / COUNT(c.UserId)) AS percentageFROM comments cJOIN users u ON c.UserId = u.IdWHERE c.Score BETWEEN 5 AND 10
SELECT sp.power_name FROM superhero AS sh INNER JOIN hero_power AS hp ON sh.id = hp.hero_id INNER JOIN superpower AS sp ON hp.power_id = sp.id WHERE sh.superhero_name = '3-D Man'
SELECT COUNT(DISTINCT T1.id) FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Super Strength'
SELECT COUNT(*) FROM superhero AS H INNER JOIN hero_power AS HP ON H.id = HP.hero_id INNER JOIN superpower AS SP ON HP.power_id = SP.id WHERE SP.power_name = 'Super Strength' AND H.height_cm > 200
SELECT s.full_name FROM superhero AS s JOIN hero_power AS hp ON s.id = hp.hero_id GROUP BY s.id HAVING COUNT(hp.power_id) > 15
SELECT COUNT(*) FROM superhero AS S INNER JOIN colour AS C ON S.eye_colour_id = C.id WHERE C.colour = 'Blue'
SELECT C.colour FROM superhero AS S INNER JOIN colour AS C ON S.skin_colour_id = C.id WHERE S.superhero_name = 'Apocalypse'
SELECT COUNT(*) FROM superhero AS S INNER JOIN colour AS C ON S.eye_colour_id = C.id INNER JOIN hero_power AS HP ON S.id = HP.hero_id INNER JOIN superpower AS SP ON HP.power_id = SP.id WHERE C.colour = 'Blue' AND SP.power_name = 'Agility'
SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Blond'
SELECT COUNT(*) FROM superhero AS S INNER JOIN publisher AS P ON S.publisher_id = P.id WHERE P.publisher_name = 'Marvel Comics'
SELECT T1.full_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics' AND T1.height_cm = (SELECT MAX(height_cm) FROM superhero AS T3  INNER JOIN publisher AS T4 ON T3.publisher_id = T4.id  WHERE T4.publisher_name = 'Marvel Comics') This ensures that the subquery correctly finds the maximum height of superheroes published by Marvel Comics.
SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name = 'Sauron'
SELECT COUNT(*) FROM superhero AS S INNER JOIN publisher AS P ON S.publisher_id = P.id INNER JOIN colour AS C ON S.eye_colour_id = C.id WHERE P.publisher_name = 'Marvel Comics' AND C.colour = 'Blue'
SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics'
SELECT (COUNT(CASE WHEN SP.power_name = 'Super Strength' THEN 1 END) * 100.0 / COUNT(SH.id)) AS percentageFROM superhero AS SHJOIN publisher AS P ON SH.publisher_id = P.idJOIN hero_power AS HP ON SH.id = HP.hero_idJOIN superpower AS SP ON HP.power_id = SP.idWHERE P.publisher_name = 'Marvel Comics'
SELECT COUNT(*) FROM superhero AS S INNER JOIN publisher AS P ON S.publisher_id = P.id WHERE P.publisher_name = 'DC Comics'
SELECT publisher.publisher_name FROM superhero JOIN hero_attribute ON superhero.id = hero_attribute.hero_id JOIN attribute ON hero_attribute.attribute_id = attribute.id JOIN publisher ON superhero.publisher_id = publisher.id WHERE attribute.attribute_name = 'Speed' AND hero_attribute.attribute_value = (SELECT MIN(attribute_value)     FROM hero_attribute     WHERE attribute_id = (SELECT id FROM attribute WHERE attribute_name = 'Speed'))
SELECT COUNT(*) FROM superhero AS S INNER JOIN colour AS C ON S.eye_colour_id = C.id INNER JOIN publisher AS P ON S.publisher_id = P.id WHERE C.colour = 'Gold' AND P.publisher_name = 'Marvel Comics'
SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name = 'Blue Beetle II'
SELECT COUNT(*) FROM superhero AS S INNER JOIN colour AS C ON S.hair_colour_id = C.id WHERE C.colour = 'Blond'
SELECT superhero_name FROM superhero WHERE id = (SELECT hero_id   FROM hero_attribute   WHERE attribute_id = (SELECT id FROM attribute WHERE attribute_name = 'Intelligence')   AND attribute_value = (SELECT MIN(attribute_value)   FROM hero_attribute   WHERE attribute_id = (SELECT id FROM attribute WHERE attribute_name = 'Intelligence')))
SELECT R.race FROM superhero AS S INNER JOIN race AS R ON S.race_id = R.id WHERE S.superhero_name = 'Copycat'
SELECT COUNT(DISTINCT superhero.id) FROM superhero INNER JOIN hero_attribute ON superhero.id = hero_attribute.hero_id INNER JOIN attribute ON hero_attribute.attribute_id = attribute.id WHERE attribute.attribute_name = 'Durability' AND hero_attribute.attribute_value < 50
SELECT superhero_name FROM superhero WHERE id IN ( SELECT hero_id FROM hero_power WHERE power_id = (SELECT id FROM superpower WHERE power_name = 'Death Touch'))
SELECT COUNT(DISTINCT S.id) FROM superhero AS S JOIN gender AS G ON S.gender_id = G.id JOIN hero_attribute AS HA ON S.id = HA.hero_id JOIN attribute AS A ON HA.attribute_id = A.id WHERE G.gender = 'Female' AND A.attribute_name = 'Strength' AND HA.attribute_value = 100
SELECT s.superhero_name FROM superhero AS s JOIN ( SELECT hero_id FROM hero_power GROUP BY hero_id HAVING COUNT(power_id) = ( SELECT MAX(power_count)  FROM ( SELECT COUNT(power_id) AS power_count  FROM hero_power  GROUP BY hero_id ) )) AS hp ON s.id = hp.hero_id
SELECT COUNT(*) FROM superhero AS S INNER JOIN race AS R ON S.race_id = R.id WHERE R.race = 'Vampire'
SELECT (COUNT(CASE WHEN a.alignment = 'Bad' THEN 1 END) * 100.0 / COUNT(s.id)) AS percentage_bad_superheroes, COUNT(CASE WHEN a.alignment = 'Bad' AND p.publisher_name = 'Marvel Comics' THEN 1 END) AS count_marvel_bad_superheroesFROM superhero s JOIN alignment a ON s.alignment_id = a.id JOIN publisher p ON s.publisher_id = p.id
SELECT (SUM(CASE WHEN P.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) -  SUM(CASE WHEN P.publisher_name = 'DC Comics' THEN 1 ELSE 0 END)) AS differenceFROM superhero AS S INNER JOIN publisher AS P ON S.publisher_id = P.idWHERE P.publisher_name IN ('DC Comics', 'Marvel Comics')
SELECT id FROM publisher WHERE publisher_name = 'Star Trek';
SELECT AVG(attribute_value) FROM hero_attribute
SELECT COUNT(*) FROM superhero WHERE full_name IS NULL
SELECT C.colour FROM superhero AS S INNER JOIN colour AS C ON S.eye_colour_id = C.id WHERE S.id = 75
SELECT sp.power_name FROM hero_power hp INNER JOIN superpower sp ON hp.power_id = sp.id WHERE hp.hero_id = (SELECT id FROM superhero WHERE superhero_name = 'Deathlok')
SELECT AVG(weight_kg) FROM superhero WHERE gender_id = 2
SELECT DISTINCT sp.power_name FROM superhero AS sh INNER JOIN gender AS g ON sh.gender_id = g.id INNER JOIN hero_power AS hp ON hp.hero_id = sh.id INNER JOIN superpower AS sp ON hp.power_id = sp.id WHERE g.gender = 'Male' LIMIT 5
SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Alien'
SELECT superhero_name FROM superhero WHERE height_cm BETWEEN 170 AND 190 AND eye_colour_id = 1
SELECT SP.power_name FROM hero_power AS HP INNER JOIN superpower AS SP ON HP.power_id = SP.id WHERE HP.hero_id = 56
SELECT T1.full_name FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Demi-God' LIMIT 5
SELECT COUNT(*) FROM superhero AS S INNER JOIN alignment AS A ON S.alignment_id = A.id WHERE A.alignment = 'Bad'
SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.weight_kg = 169
SELECT C.colour FROM superhero AS S INNER JOIN colour AS C ON S.hair_colour_id = C.id INNER JOIN race AS R ON S.race_id = R.id WHERE S.height_cm = 185 AND R.race = 'human'
SELECT c.colour FROM superhero AS s JOIN colour AS c ON s.eye_colour_id = c.id WHERE s.weight_kg = (SELECT MAX(weight_kg) FROM superhero)
SELECT CAST(SUM(CASE WHEN P.id = 13 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) AS percentage_marvel_heroesFROM superhero AS S INNER JOIN publisher AS P ON S.publisher_id = P.id WHERE S.height_cm BETWEEN 150 AND 180
SELECT full_name FROM superhero AS s INNER JOIN gender AS g ON s.gender_id = g.id WHERE g.gender = 'Male' AND s.weight_kg > (SELECT AVG(weight_kg) * 0.79 FROM superhero)
SELECT sp.power_nameFROM superpower spJOIN hero_power hp ON sp.id = hp.power_idGROUP BY sp.power_nameORDER BY COUNT(hp.hero_id) DESCLIMIT 1;
SELECT ha.attribute_value FROM hero_attribute AS ha INNER JOIN superhero AS s ON ha.hero_id = s.id WHERE s.superhero_name = 'Abomination'
SELECT SP.power_name FROM hero_power AS HP INNER JOIN superpower AS SP ON HP.power_id = SP.id WHERE HP.hero_id = 1
SELECT COUNT(DISTINCT hero_power.hero_id) FROM hero_power INNER JOIN superpower ON hero_power.power_id = superpower.id WHERE superpower.power_name = 'stealth'
SELECT s.full_name FROM superhero AS s INNER JOIN hero_attribute AS ha ON s.id = ha.hero_id WHERE ha.attribute_value = (SELECT MAX(attribute_value) FROM hero_attribute WHERE attribute_id = (SELECT id FROM attribute WHERE attribute_name = 'Strength'))
SELECT COUNT(id) * 1.0 / (SELECT COUNT(id) FROM superhero) AS average_no_skin_colourFROM superhero WHERE skin_colour_id = 1; This query counts the number of superheroes with no skin color and divides it by the total number of superheroes to get the average.
SELECT COUNT(*) FROM superhero AS S INNER JOIN publisher AS P ON S.publisher_id = P.id WHERE P.publisher_name = 'Dark Horse Comics'
SELECT superhero.superhero_name FROM superhero INNER JOIN hero_attribute ON superhero.id = hero_attribute.hero_id INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE hero_attribute.attribute_id = (SELECT id FROM attribute WHERE attribute_name = 'durability') AND hero_attribute.attribute_value = (SELECT MAX(attribute_value)  FROM hero_attribute  WHERE attribute_id = (SELECT id FROM attribute WHERE attribute_name = 'durability')) AND publisher.publisher_name = 'Dark Horse Comics';
SELECT C.colour FROM superhero AS S INNER JOIN colour AS C ON S.eye_colour_id = C.id WHERE S.full_name = 'Abraham Sapien'
SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Flight'
SELECT T1.eye_colour_id, T1.hair_colour_id, T1.skin_colour_id FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id INNER JOIN publisher AS T3 ON T1.publisher_id = T3.id WHERE T2.gender = 'Female' AND T3.publisher_name = 'Dark Horse Comics'
SELECT T1.superhero_name, T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.hair_colour_id = T1.skin_colour_id AND T1.hair_colour_id = T1.eye_colour_id
SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.superhero_name = 'A-Bomb'
SELECT (SELECT COUNT(*)  FROM superhero  WHERE gender_id = (SELECT id FROM gender WHERE gender = 'Female')  AND eye_colour_id = (SELECT id FROM colour WHERE colour = 'Blue')) * 100.0 / (SELECT COUNT(*)  FROM superhero  WHERE gender_id = (SELECT id FROM gender WHERE gender = 'Female')) AS percentage
SELECT T1.superhero_name, T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.full_name = 'Charles Chandler'
SELECT T2.gender FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T1.superhero_name = 'Agent 13'
SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Adaptation'
SELECT COUNT(T2.power_id) FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id WHERE T1.superhero_name = 'Amazo'
SELECT sp.power_name FROM superhero AS sh INNER JOIN hero_power AS hp ON sh.id = hp.hero_id INNER JOIN superpower AS sp ON hp.power_id = sp.id WHERE sh.full_name = 'Hunter Zolomon'
SELECT T1.height_cm FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Amber'
SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Black' AND T3.colour = 'Black'
SELECT C1.colour AS eye_colourFROM superhero AS SINNER JOIN colour AS C1 ON S.eye_colour_id = C1.idINNER JOIN colour AS C2 ON S.skin_colour_id = C2.idWHERE C2.colour = 'Gold'
SELECT T1.full_name FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Vampire'
SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral'
SELECT COUNT(hero_id) FROM hero_attribute WHERE attribute_id = (SELECT id FROM attribute WHERE attribute_name = 'Strength') AND attribute_value = (SELECT MAX(attribute_value)  FROM hero_attribute  WHERE attribute_id = (SELECT id FROM attribute WHERE attribute_name = 'Strength'))
SELECT R.race, A.alignment FROM superhero AS S INNER JOIN race AS R ON S.race_id = R.id INNER JOIN alignment AS A ON S.alignment_id = A.id WHERE S.superhero_name = 'Cameron Hicks'
SELECT (COUNT(CASE WHEN g.gender = 'Female' THEN 1 END) * 100.0 / COUNT(*)) AS female_percentageFROM superhero AS sJOIN publisher AS p ON s.publisher_id = p.idJOIN gender AS g ON s.gender_id = g.idWHERE p.publisher_name = 'Marvel Comics'
SELECT AVG(T1.weight_kg) FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Alien'
SELECT COALESCE((SELECT weight_kg FROM superhero WHERE full_name = 'Emil Blonsky'), 0) - COALESCE((SELECT weight_kg FROM superhero WHERE full_name = 'Charles Chandler'), 0) AS weight_difference
SELECT superhero_name, AVG(height_cm) AS average_height FROM superhero GROUP BY superhero_name; This query will return the average height for each superhero, grouped by their names.
SELECT sp.power_name FROM superhero AS sh JOIN hero_power AS hp ON sh.id = hp.hero_id JOIN superpower AS sp ON hp.power_id = sp.id WHERE sh.superhero_name = 'Abomination'
SELECT COUNT(*) FROM superhero AS s INNER JOIN race AS r ON s.race_id = r.id INNER JOIN gender AS g ON s.gender_id = g.id WHERE r.id = 21 AND g.id = 1
SELECT superhero.superhero_name FROM superhero INNER JOIN hero_attribute ON superhero.id = hero_attribute.hero_id WHERE hero_attribute.attribute_value = ( SELECT MAX(attribute_value) FROM hero_attribute WHERE attribute_id = (SELECT id FROM attribute WHERE attribute_name = 'Speed'))
SELECT COUNT(*) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.id = 3
SELECT A.attribute_name, HA.attribute_value FROM superhero AS S INNER JOIN hero_attribute AS HA ON S.id = HA.hero_id INNER JOIN attribute AS A ON HA.attribute_id = A.id WHERE S.superhero_name = '3-D Man'
SELECT superhero_name FROM superhero WHERE eye_colour_id = 7 AND hair_colour_id = 9
SELECT P.publisher_name FROM superhero AS S INNER JOIN publisher AS P ON S.publisher_id = P.id WHERE S.superhero_name IN ('Hawkman', 'Karate Kid', 'Speedy')
`SELECT COUNT(*) FROM superhero WHERE publisher_id IS NULL`
SELECT CAST(SUM(CASE WHEN eye_colour_id = 7 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(superhero_name) AS percentage FROM superhero
SELECT CAST(SUM(CASE WHEN gender_id = 1 THEN 1 ELSE 0 END) AS REAL) / NULLIF(SUM(CASE WHEN gender_id = 2 THEN 1 ELSE 0 END), 0) AS male_female_ratioFROM superhero
SELECT superhero_name FROM superhero WHERE height_cm = (SELECT MAX(height_cm) FROM superhero)
SELECT id FROM superpower WHERE power_name = 'cryokinesis';
SELECT superhero_name FROM superhero WHERE id = 294
SELECT full_name FROM superhero WHERE weight_kg = 0 OR weight_kg IS NULL
SELECT C.colour FROM superhero AS S INNER JOIN colour AS C ON S.eye_colour_id = C.id WHERE S.full_name = 'Karen Beecher-Duncan'
SELECT sp.power_name FROM hero_power hp INNER JOIN superpower sp ON hp.power_id = sp.id WHERE hp.hero_id = (SELECT id FROM superhero WHERE full_name = 'Helen Parr')
SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.weight_kg = 108 AND T1.height_cm = 188
SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.id = 38
SELECT race.race FROM superhero INNER JOIN race ON superhero.race_id = race.id WHERE superhero.id = (SELECT hero_id FROM hero_attribute WHERE attribute_value = (SELECT MAX(attribute_value) FROM hero_attribute))
SELECT alignment.alignment, superpower.power_name FROM superhero INNER JOIN alignment ON superhero.alignment_id = alignment.id INNER JOIN hero_power ON superhero.id = hero_power.hero_id INNER JOIN superpower ON hero_power.power_id = superpower.id WHERE superhero.superhero_name = 'Atom IV'
SELECT T1.full_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Blue' LIMIT 5
SELECT AVG(ha.attribute_value) FROM hero_attribute AS ha INNER JOIN superhero AS s ON ha.hero_id = s.id WHERE s.alignment_id = 3
SELECT c.colour FROM colour AS c INNER JOIN superhero AS s ON s.skin_colour_id = c.id INNER JOIN hero_attribute AS ha ON s.id = ha.hero_id WHERE ha.attribute_value = 100
SELECT COUNT(*) FROM superhero AS S INNER JOIN alignment AS A ON S.alignment_id = A.id INNER JOIN gender AS G ON S.gender_id = G.id WHERE A.id = 1 AND G.id = 2
SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id WHERE T2.attribute_value BETWEEN 75 AND 80
SELECT race.race FROM superhero INNER JOIN race ON superhero.race_id = race.id WHERE superhero.hair_colour_id = (SELECT id FROM colour WHERE colour = 'blue') AND superhero.gender_id = (SELECT id FROM gender WHERE gender = 'male')
SELECT (COUNT(CASE WHEN gender_id = 2 THEN 1 END) * 100.0) / COUNT(*) AS female_percentageFROM superhero WHERE alignment_id = 2 Since there are no issues found, the original SQL query is correct as is.
SELECT (SUM(CASE WHEN T1.eye_colour_id = 7 THEN 1 ELSE 0 END) -  SUM(CASE WHEN T1.eye_colour_id = 1 THEN 1 ELSE 0 END)) AS differenceFROM superhero AS T1WHERE T1.weight_kg IS NULL OR T1.weight_kg = 0
SELECT ha.attribute_value FROM hero_attribute AS ha INNER JOIN superhero AS s ON ha.hero_id = s.id INNER JOIN attribute AS a ON ha.attribute_id = a.id WHERE s.superhero_name = 'Hulk' AND a.attribute_name = 'Strength'
SELECT sp.power_name FROM hero_power hp INNER JOIN superpower sp ON hp.power_id = sp.id WHERE hp.hero_id = (SELECT id FROM superhero WHERE superhero_name = 'Ajax')
SELECT COUNT(*) FROM superhero AS S INNER JOIN colour AS C ON S.skin_colour_id = C.id INNER JOIN alignment AS A ON S.alignment_id = A.id WHERE C.colour = 'Green' AND A.alignment = 'Bad'
SELECT COUNT(*) FROM superhero AS S INNER JOIN gender AS G ON S.gender_id = G.id INNER JOIN publisher AS P ON S.publisher_id = P.id WHERE G.gender = 'Female' AND P.publisher_name = 'Marvel Comics'
SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Wind Control' ORDER BY T1.superhero_name ASC
SELECT g.gender FROM gender AS g JOIN superhero AS s ON g.id = s.gender_id WHERE s.id = (SELECT hp.hero_id FROM hero_power AS hp WHERE hp.power_id = (SELECT sp.id   FROM superpower AS sp   WHERE sp.power_name = 'Phoenix Force'))
SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics' AND T1.weight_kg = (SELECT MAX(weight_kg) FROM superhero WHERE publisher_id = T2.id)LIMIT 1 This query selects the superhero name from the superhero table where the weight is equal to the maximum weight of superheroes published by 'DC Comics'.
SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id INNER JOIN publisher AS T3 ON T1.publisher_id = T3.id WHERE T2.race <> 'Human' AND T3.publisher_name = 'Dark Horse Comics'
SELECT COUNT(*) FROM hero_attribute AS HA INNER JOIN attribute AS A ON HA.attribute_id = A.id WHERE A.attribute_name = 'Speed' AND HA.attribute_value = 100
SELECT (COUNT(CASE WHEN P.publisher_name = 'DC Comics' THEN 1 END) -  COUNT(CASE WHEN P.publisher_name = 'Marvel Comics' THEN 1 END)) AS differenceFROM superhero AS SINNER JOIN publisher AS P ON S.publisher_id = P.idWHERE P.publisher_name IN ('DC Comics', 'Marvel Comics')
SELECT a.attribute_name FROM hero_attribute ha INNER JOIN superhero s ON ha.hero_id = s.id INNER JOIN attribute a ON ha.attribute_id = a.id WHERE s.superhero_name = 'Black Panther' ORDER BY ha.attribute_value ASC LIMIT 1
SELECT C.colour FROM superhero AS S INNER JOIN colour AS C ON S.eye_colour_id = C.id WHERE S.superhero_name = 'Abomination'
SELECT superhero_name FROM superhero WHERE height_cm = (SELECT MAX(height_cm) FROM superhero)
SELECT superhero_name FROM superhero WHERE full_name = 'Charles Chandler';
SELECT (SUM(CASE WHEN g.gender = 'Female' THEN 1 ELSE 0 END) * 100.0) / COUNT(s.id) AS female_percentage   FROM superhero AS s   INNER JOIN publisher AS p ON s.publisher_id = p.id   INNER JOIN gender AS g ON s.gender_id = g.id   WHERE p.publisher_name = 'George Lucas'
SELECT (SELECT COUNT(*) FROM superhero  WHERE publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics')  AND alignment_id = (SELECT id FROM alignment WHERE alignment = 'Good')) * 100.0 / (SELECT COUNT(*) FROM superhero  WHERE publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics')) AS percentage_good_superheroes
SELECT COUNT(*) FROM superhero WHERE full_name LIKE 'John%';
SELECT hero_id FROM hero_attribute WHERE attribute_value = (SELECT MIN(attribute_value) FROM hero_attribute)
SELECT s.full_name FROM superhero s JOIN race r ON s.race_id = r.id WHERE r.race = 'Alien';
SELECT T1.full_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.weight_kg < 100 AND T2.colour = 'Amber'This query now correctly selects the full names of superheroes with a weight less than 100 kg and with the eye color 'Amber', which exists in the `colour` table.
SELECT T1.attribute_value FROM hero_attribute AS T1 INNER JOIN superhero AS T2 ON T1.hero_id = T2.id WHERE T2.superhero_name = 'Aquababy'
SELECT T1.weight_kg, T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.id = 40
SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral'
SELECT superhero.id FROM superhero INNER JOIN hero_power ON superhero.id = hero_power.hero_id WHERE hero_power.power_id = (SELECT id FROM superpower WHERE power_name = 'Intelligence')
SELECT C.colour FROM superhero AS S INNER JOIN colour AS C ON S.eye_colour_id = C.id WHERE S.superhero_name = 'Blackwulf'
SELECT sp.power_name FROM superhero shJOIN hero_power hp ON sh.id = hp.hero_idJOIN superpower sp ON hp.power_id = sp.idWHERE sh.height_cm > (SELECT AVG(height_cm) * 0.8 FROM superhero)
SELECT d.driverRef FROM drivers AS d WHERE d.driverId IN ( SELECT q.driverId FROM qualifying AS q WHERE q.raceId = 18 AND q.q1 NOT IN ( SELECT q1  FROM qualifying  WHERE raceId = 18  ORDER BY q1  LIMIT 15 ))
SELECT d.surname FROM drivers d WHERE d.driverId = (SELECT driverId FROM qualifying WHERE raceId = 19 AND q2 = (SELECT MIN(q2) FROM qualifying WHERE raceId = 19))
SELECT T1.year FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.location = 'Shanghai'
SELECT T1.url FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.name = 'Circuit de Barcelona-Catalunya'
SELECT T1.name FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Germany'
SELECT DISTINCT C.location FROM constructors AS CN JOIN constructorResults AS CR ON CN.constructorId = CR.constructorId JOIN constructorStandings AS CS ON CN.constructorId = CS.constructorId JOIN results AS R ON CN.constructorId = R.constructorId JOIN races AS RA ON R.raceId = RA.raceId JOIN circuits AS C ON RA.circuitId = C.circuitId WHERE CN.name = 'Renault'
SELECT COUNT(*) FROM races AS R INNER JOIN circuits AS C ON R.circuitId = C.circuitId WHERE R.year = 2010 AND C.country NOT IN ('Malaysia', 'Japan', 'China', 'India', 'Singapore', 'Bahrain', 'Germany', 'France', 'Italy', 'Spain', 'United Kingdom', 'Netherlands', 'Belgium', 'Austria', 'Switzerland', 'Portugal', 'Russia', 'Monaco', 'Czech Republic', 'Hungary', 'Finland', 'Sweden', 'Norway', 'Denmark', 'Ireland', 'Luxembourg', 'Poland', 'Romania', 'Slovakia', 'Slovenia', 'Croatia', 'Serbia', 'Greece', 'Turkey', 'Ukraine', 'Estonia', 'Latvia', 'Lithuania', 'Iceland', 'Malta', 'Cyprus');
SELECT T1.name FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Spain'
SELECT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T2.name = 'Australian Grand Prix'
SELECT T1.url FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.name = 'Sepang International Circuit'
SELECT T1.time FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.name = 'Sepang International Circuit'
SELECT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T2.name = 'Abu Dhabi Grand Prix'
SELECT C.nationality FROM constructorResults AS CR INNER JOIN constructors AS C ON CR.constructorId = C.constructorId WHERE CR.points = 1 AND CR.raceId = 24
SELECT q1 FROM qualifying WHERE raceId = 354 AND driverId = (SELECT driverId FROM drivers WHERE forename = 'Bruno' AND surname = 'Senna')
SELECT D.nationality FROM qualifying AS Q INNER JOIN drivers AS D ON Q.driverId = D.driverId WHERE Q.raceId = 355 AND Q.q2 = '0:01:40'
SELECT number FROM drivers WHERE driverId = (SELECT driverId FROM qualifying WHERE raceId = 903 AND q3 = '0:01:54')
SELECT COUNT(*) FROM results WHERE raceId = (SELECT raceId FROM races WHERE name = 'Bahrain Grand Prix' AND year = 2007) AND statusId != 1
SELECT S.year, S.url FROM races AS R INNER JOIN seasons AS S ON R.year = S.year WHERE R.raceId = 901
SELECT COUNT(*) FROM results AS R INNER JOIN races AS RACE ON R.raceId = RACE.raceId WHERE RACE.date = '2015-11-29' AND R.time IS NOT NULL
SELECT T1.driverId, T2.dob FROM results AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.raceId = 592 AND T1.time IS NOT NULL ORDER BY T2.dob ASC LIMIT 1
SELECT D.forename, D.surname, D.url FROM lapTimes AS L INNER JOIN drivers AS D ON L.driverId = D.driverId WHERE L.time = '0:01:27' AND L.raceId = 161
SELECT nationality FROM drivers WHERE driverId = (SELECT driverId FROM results WHERE raceId = 933 AND fastestLapSpeed = (SELECT MAX(fastestLapSpeed) FROM results WHERE raceId = 933))
SELECT C.lat, C.lng FROM races AS R INNER JOIN circuits AS C ON R.circuitId = C.circuitId WHERE R.name = 'Malaysian Grand Prix'
SELECT url FROM constructors WHERE constructorId = (SELECT constructorId FROM constructorResults WHERE raceId = 9 AND points = (SELECT MAX(points) FROM constructorResults WHERE raceId = 9))
SELECT Q.q1 FROM qualifying AS Q INNER JOIN drivers AS D ON Q.driverId = D.driverId WHERE Q.raceId = 345 AND D.forename = 'Lucas' AND D.surname = 'di Grassi'
SELECT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.raceId = 347 AND T1.q2 = '0:01:15'
SELECT d.code FROM drivers AS d INNER JOIN qualifying AS q ON d.driverId = q.driverId WHERE q.raceId = 45 AND q.q3 = '0:01:33'
SELECT T1.time FROM results AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.raceId = 743 AND T2.forename = 'Bruce' AND T2.surname = 'McLaren'
SELECT T1.driverId FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.name = 'San Marino Grand Prix' AND T2.year = 2006 AND T1.position = 2
SELECT S.year, S.url FROM races AS R INNER JOIN seasons AS S ON R.year = S.year WHERE R.raceId = 901
SELECT COUNT(*) FROM results AS R INNER JOIN races AS RA ON R.raceId = RA.raceId WHERE RA.date = '2015-11-29' AND R.statusId = 1
SELECT d.driverId, d.dob FROM results AS r INNER JOIN drivers AS d ON r.driverId = d.driverId WHERE r.raceId = 872 AND r.time IS NOT NULL ORDER BY d.dob ASC LIMIT 1
SELECT d.forename, d.surname FROM drivers d WHERE d.driverId = (SELECT driverId FROM results WHERE raceId = 348 AND fastestLapTime = (SELECT MIN(fastestLapTime) FROM results WHERE raceId = 348))
SELECT nationality FROM drivers WHERE driverId = (SELECT driverId FROM results WHERE fastestLapSpeed = (SELECT MAX(fastestLapSpeed) FROM results)) Since the original SQL query is already correct after removing the unnecessary raceId condition, we can return it as is:Final SQL: SELECT nationality FROM drivers WHERE driverId = (SELECT driverId FROM results WHERE fastestLapSpeed = (SELECT MAX(fastestLapSpeed) FROM results))
SELECT (SELECT fastestLapSpeed FROM results WHERE raceId = 853) - (SELECT fastestLapSpeed FROM results WHERE raceId = 854) AS speed_difference, CASE  WHEN (SELECT fastestLapSpeed FROM results WHERE raceId = 853) IS NOT NULL AND   (SELECT fastestLapSpeed FROM results WHERE raceId = 854) IS NOT NULL  THEN  ((SELECT fastestLapSpeed FROM results WHERE raceId = 853) -  (SELECT fastestLapSpeed FROM results WHERE raceId = 854)) * 100.0 /  (SELECT fastestLapSpeed FROM results WHERE raceId = 853)  ELSE  NULL END AS percentage_fasterThis revised query includes a CASE statement to handle potential NULL values in the fastest lap speeds, ensuring that the percentage calculation is only performed when both values are available.
SELECT (COUNT(CASE WHEN time IS NOT NULL THEN 1 END) * 100.0 / COUNT(driverId)) AS completion_rateFROM results WHERE raceId = (SELECT raceId FROM races WHERE date = '1983-07-16')
SELECT MIN(year) AS first_singapore_grand_prix_year FROM races WHERE name LIKE '%Singapore Grand Prix%';
SELECT COUNT(*) AS number_of_races FROM races WHERE year = 2005; If the intention was to list all the races in descending order, the query should be:Revised_SQL: SELECT raceId, name FROM races WHERE year = 2005 ORDER BY name DESC; Since the question specifically asks for the number of races, the first revised SQL is the correct answer.
SELECT * FROM races WHERE date = (SELECT MIN(date) FROM races)   OR strftime('%Y-%m', date) = strftime('%Y-%m', (SELECT MIN(date) FROM races)); This query selects all races that either match the first race's date or occur in the same month and year as the first race.
SELECT name, date FROM races WHERE year = 1999 AND round = (SELECT MAX(round) FROM races WHERE year = 1999)
SELECT year FROM races GROUP BY year ORDER BY COUNT(raceId) DESC LIMIT 1
SELECT name FROM races WHERE year = 2017
SELECT circuits.country, circuits.name AS circuit_name, circuits.location FROM races INNER JOIN circuits ON races.circuitId = circuits.circuitId WHERE races.raceId = (SELECT raceId FROM races WHERE name = 'European Grand Prix' ORDER BY year ASC LIMIT 1)
SELECT MAX(year) FROM races WHERE raceId IN ( SELECT raceId FROM races WHERE name = 'British Grand Prix' AND circuitId = ( SELECT circuitId  FROM circuits  WHERE name = 'Brands Hatch' ))This ensures that we are correctly filtering the races based on the race name and circuit name, and then finding the maximum year from those results.
SELECT COUNT(DISTINCT T3.year) FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId INNER JOIN seasons AS T3 ON T1.year = T3.year WHERE T1.name = 'British Grand Prix' AND T2.name = 'Silverstone Circuit'
SELECT D.forename, D.surname, R.position FROM results AS R INNER JOIN drivers AS D ON R.driverId = D.driverId INNER JOIN races AS RA ON R.raceId = RA.raceId WHERE RA.year = 2010 AND RA.name = 'Singapore Grand Prix' ORDER BY R.position
SELECT d.forename, d.surname FROM drivers AS d WHERE d.driverId IN (SELECT driverId FROM driverStandings WHERE points = (SELECT MAX(points) FROM driverStandings))
SELECT d.forename, d.surname, ds.points FROM driverStandings AS ds JOIN drivers AS d ON ds.driverId = d.driverId WHERE ds.raceId = (SELECT raceId FROM races WHERE name = 'Chinese Grand Prix' AND year = 2017)ORDER BY ds.points DESCLIMIT 3
SELECT D.forename, D.surname, R.name AS race_name, LT.time AS best_lap_timeFROM lapTimes AS LTINNER JOIN drivers AS D ON LT.driverId = D.driverIdINNER JOIN races AS R ON LT.raceId = R.raceIdWHERE LT.time = (SELECT MIN(time) FROM lapTimes)
SELECT AVG(CAST(SUBSTR(L.time, 1, INSTR(L.time, ':') - 1) AS INTEGER) * 60 * 1000 +  CAST(SUBSTR(L.time, INSTR(L.time, ':') + 1) AS INTEGER) * 1000) AS average_lap_timeFROM lapTimes AS L INNER JOIN drivers AS D ON L.driverId = D.driverId INNER JOIN races AS R ON L.raceId = R.raceId WHERE D.forename = 'Sebastian' AND D.surname = 'Vettel' AND R.name = 'Chinese Grand Prix' AND R.year = 2009;
SELECT (COUNT(CASE WHEN ds.position > 1 THEN 1 END) * 100.0 / NULLIF(COUNT(ds.raceId), 0)) AS percentageFROM driverStandings AS dsJOIN drivers AS d ON ds.driverId = d.driverIdJOIN races AS r ON ds.raceId = r.raceIdWHERE d.surname = 'Hamilton' AND r.year >= 2010
SELECT d.forename, d.surname, d.nationality, AVG(ds.points) AS average_pointsFROM driverStandings dsJOIN drivers d ON ds.driverId = d.driverIdJOIN (SELECT driverId, COUNT(*) AS wins FROM driverStandings GROUP BY driverId ORDER BY wins DESC LIMIT 1) AS max_winner ON ds.driverId = max_winner.driverIdGROUP BY d.driverId, d.forename, d.surname, d.nationality
SELECT forename, surname, (2022 - strftime('%Y', dob) + 1) AS age FROM drivers WHERE dob = (SELECT MAX(dob) FROM drivers WHERE nationality = 'Japanese')
SELECT C.circuitId, C.name, C.location, C.countryFROM circuits AS CJOIN races AS R ON C.circuitId = R.circuitIdWHERE R.year BETWEEN 1990 AND 2000GROUP BY C.circuitIdHAVING COUNT(R.raceId) = 4
SELECT C.name AS circuit_name, C.location AS circuit_location, R.name AS race_name FROM circuits AS C INNER JOIN races AS R ON C.circuitId = R.circuitId WHERE R.year = 2006 AND C.country = 'USA'
SELECT R.name AS race_name, C.name AS circuit_name, C.location FROM races AS R INNER JOIN circuits AS C ON R.circuitId = C.circuitId WHERE strftime('%Y', R.date) = '2005' AND strftime('%m', R.date) = '09'
SELECT R.* FROM races AS R INNER JOIN results AS Res ON R.raceId = Res.raceId WHERE Res.driverId = (SELECT driverId FROM drivers WHERE forename = 'Alex' AND surname = 'Yoong') AND Res.position < 10
SELECT COUNT(*) FROM results WHERE raceId IN (SELECT raceId FROM races WHERE circuitId = (SELECT circuitId FROM circuits WHERE name = 'Sepang International Circuit')) AND driverId = (SELECT driverId FROM drivers WHERE forename = 'Michael' AND surname = 'Schumacher') AND points = (SELECT MAX(points) FROM results WHERE raceId IN (SELECT raceId FROM races WHERE circuitId = (SELECT circuitId FROM circuits WHERE name = 'Sepang International Circuit')) AND driverId = (SELECT driverId FROM drivers WHERE forename = 'Michael' AND surname = 'Schumacher'))
SELECT R2.name, R2.year FROM results AS R INNER JOIN races AS R2 ON R.raceId = R2.raceId WHERE R.driverId = (SELECT driverId FROM drivers WHERE surname = 'Schumacher' AND forename = 'Michael') AND R.milliseconds = (SELECT MIN(milliseconds) FROM results WHERE driverId = (SELECT driverId FROM drivers WHERE surname = 'Schumacher' AND forename = 'Michael'))
SELECT AVG(ds.points) FROM driverStandings AS ds INNER JOIN races AS r ON ds.raceId = r.raceId INNER JOIN drivers AS d ON ds.driverId = d.driverId WHERE r.year = 2000 AND d.forename = 'Eddie' AND d.surname = 'Irvine'
SELECT races.year, results.points FROM results INNER JOIN races ON results.raceId = races.raceId WHERE results.driverId = (SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton') AND races.year = (SELECT MIN(races.year)    FROM results    INNER JOIN races ON results.raceId = races.raceId    WHERE results.driverId = (SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton'))
SELECT T1.name AS race_name, T1.date AS race_date, T2.country AS hosting_country FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE strftime('%Y', T1.date) = '2017' ORDER BY T1.date
SELECT R.name AS race_name, R.year AS race_year, C.location AS circuit_locationFROM results AS ResJOIN races AS R ON Res.raceId = R.raceIdJOIN circuits AS C ON R.circuitId = C.circuitIdWHERE Res.laps = (SELECT MAX(laps) FROM results)LIMIT 1
SELECT (COUNT(CASE WHEN country = 'Germany' AND name = 'European Grand Prix' THEN 1 END) * 100.0) / COUNT(CASE WHEN name = 'European Grand Prix' THEN 1 END) AS percentageFROM races;
SELECT lat, lng FROM circuits WHERE name = 'Silverstone Circuit';
SELECT name, lat FROM circuits WHERE name IN ('Silverstone Circuit', 'Hockenheimring', 'Hungaroring') ORDER BY lat DESC LIMIT 1
SELECT circuitRef FROM circuits WHERE name = 'Marina Bay Street Circuit';
SELECT country FROM circuits WHERE alt = (SELECT MAX(alt) FROM circuits);
SELECT COUNT(*) FROM drivers WHERE code IS NULL
SELECT nationality FROM drivers WHERE dob = (SELECT MIN(dob) FROM drivers);
`SELECT surname FROM drivers WHERE nationality = 'Italian'`
SELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson';
SELECT driverRef FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton'; This query correctly retrieves Lewis Hamilton's reference name from the drivers table.
SELECT C.name FROM races AS R INNER JOIN circuits AS C ON R.circuitId = C.circuitId WHERE R.year = 2009 AND R.name = 'Spanish Grand Prix'
SELECT DISTINCT T1.year FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.name = 'Silverstone Circuit'
SELECT T1.url FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.name = 'Silverstone Circuit'
SELECT T1.time FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T1.year = 2010 AND T2.name = 'Abu Dhabi Circuit'
SELECT COUNT(*) FROM races AS R INNER JOIN circuits AS C ON R.circuitId = C.circuitId WHERE C.country = 'Italy'
SELECT T1.date FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.name = 'Circuit de Barcelona-Catalunya'
SELECT C.url FROM races AS R INNER JOIN circuits AS C ON R.circuitId = C.circuitId WHERE R.year = 2009 AND R.name = 'Spanish Grand Prix'
SELECT MIN(fastestLapTime) FROM results WHERE driverId = (SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton')
SELECT d.forename, d.surname FROM results AS r INNER JOIN drivers AS d ON r.driverId = d.driverId WHERE r.fastestLapSpeed = (SELECT MAX(fastestLapSpeed) FROM results)
SELECT driverRef FROM drivers WHERE driverId = ( SELECT driverId FROM results WHERE raceId = ( SELECT raceId  FROM races  WHERE name = 'Australian Grand Prix' AND year = 2008 ) AND position = 1)
SELECT R.name FROM races AS R INNER JOIN results AS Res ON R.raceId = Res.raceId INNER JOIN drivers AS D ON Res.driverId = D.driverId WHERE D.forename = 'Lewis' AND D.surname = 'Hamilton'
SELECT races.name FROM results INNER JOIN races ON results.raceId = races.raceId WHERE results.driverId = (SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton') AND results.rank = (SELECT MIN(rank) FROM results WHERE driverId = (SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton'))
SELECT MAX(T1.fastestLapSpeed) FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix'
SELECT DISTINCT R.year FROM results AS R INNER JOIN drivers AS D ON R.driverId = D.driverId INNER JOIN races AS RACE ON R.raceId = RACE.raceId WHERE D.forename = 'Lewis' AND D.surname = 'Hamilton'
SELECT R.positionOrder FROM results AS R INNER JOIN drivers AS D ON R.driverId = D.driverId INNER JOIN races AS RA ON R.raceId = RA.raceId WHERE D.forename = 'Lewis' AND D.surname = 'Hamilton' AND RA.year = 2008 AND RA.name = 'Australian Grand Prix'
SELECT d.forename, d.surname FROM drivers AS d WHERE d.driverId = ( SELECT r.driverId FROM results AS r WHERE r.raceId = ( SELECT raceId  FROM races  WHERE year = 2008 AND name = 'Australian Grand Prix' ) AND r.grid = 4)
SELECT COUNT(DISTINCT T1.driverId) FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.year = 2008 AND T2.name = 'Australian Grand Prix' AND T1.time IS NOT NULL
SELECT fastestLapTime FROM results WHERE driverId = (SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton') AND raceId = (SELECT raceId FROM races WHERE year = 2008 AND name = 'Australian Grand Prix')
SELECT results.time FROM results INNER JOIN races ON results.raceId = races.raceId WHERE races.year = 2008 AND races.name = 'Australian Grand Prix' AND results.position = 2
SELECT T1.driverId, T2.url FROM results AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.raceId = (SELECT raceId FROM races WHERE year = 2008 AND name = 'Australian Grand Prix') AND T1.positionOrder = 1
SELECT COUNT(DISTINCT D.driverId) FROM drivers AS D INNER JOIN results AS R ON R.driverId = D.driverId INNER JOIN races AS RA ON R.raceId = RA.raceId WHERE D.nationality = 'American' AND RA.year = 2008 AND RA.name = 'Australian Grand Prix'
SELECT COUNT(DISTINCT driverId) FROM results WHERE driverId IN ( SELECT driverId FROM results WHERE raceId = (SELECT raceId FROM races WHERE year = 2008 AND name = 'Australian Grand Prix') AND time IS NOT NULL)
SELECT SUM(T1.points) FROM results AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton'
SELECT AVG((CAST(SUBSTR(fastestLapTime, 1, INSTR(fastestLapTime, ':') - 1) AS INTEGER) * 60) +  CAST(SUBSTR(fastestLapTime, INSTR(fastestLapTime, ':') + 1) AS REAL)) AS average_fastest_lap_timeFROM results WHERE driverId = (SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton')
SELECT (SELECT COUNT(raceId) FROM lapTimes WHERE raceId = (SELECT raceId FROM races WHERE year = 2008 AND name = 'Australian Grand Prix') AND time IS NOT NULL) * 1.0 / (SELECT COUNT(raceId) FROM lapTimes WHERE raceId = (SELECT raceId FROM races WHERE year = 2008 AND name = 'Australian Grand Prix')) AS completion_rate
WITH RaceInfo AS ( SELECT raceId FROM races WHERE year = 2008 AND name = 'Australian Grand Prix'),ChampionTime AS ( SELECT time FROM results WHERE raceId = (SELECT raceId FROM RaceInfo) AND positionOrder = 1),LastDriverTime AS ( SELECT time FROM results WHERE raceId = (SELECT raceId FROM RaceInfo) ORDER BY positionOrder DESC LIMIT 1)SELECT (CAST((CAST(substr(LastDriverTime.time, 1, 2) AS INTEGER) * 3600000 +  CAST(substr(LastDriverTime.time, 4, 2) AS INTEGER) * 60000 +  CAST(substr(LastDriverTime.time, 7, 2) AS INTEGER) * 1000 +  CAST(substr(LastDriverTime.time, 10, 3) AS INTEGER)) - (CAST(substr(ChampionTime.time, 1, 2) AS INTEGER) * 3600000 +  CAST(substr(ChampionTime.time, 4, 2) AS INTEGER) * 60000 +  CAST(substr(ChampionTime.time, 7, 2) AS INTEGER) * 1000 +  CAST(substr(ChampionTime.time, 10, 3) AS INTEGER)) AS REAL) / (CAST(substr(LastDriverTime.time, 1, 2) AS INTEGER) * 3600000 +  CAST(substr(LastDriverTime.time, 4, 2) AS INTEGER) * 60000 +  CAST(substr(LastDriverTime.time, 7, 2) AS INTEGER) * 1000 +  CAST(substr(LastDriverTime.time, 10, 3) AS INTEGER)) * 100) AS percentageFROM ChampionTime, LastDriverTime
SELECT COUNT(*) AS circuit_count FROM circuits WHERE location = 'Melbourne' AND country = 'Australia';
SELECT lat, lng FROM circuits WHERE country = 'USA';
SELECT COUNT(*) FROM drivers WHERE nationality = 'British' AND dob > '1980-01-01';
SELECT AVG(CR.points) FROM constructors AS C INNER JOIN constructorResults AS CR ON C.constructorId = CR.constructorId WHERE C.nationality = 'British'
SELECT name, MAX(total_points) AS highest_pointsFROM ( SELECT c.name, SUM(cr.points) AS total_points FROM constructors AS c JOIN constructorResults AS cr ON c.constructorId = cr.constructorId GROUP BY c.constructorId UNION ALL SELECT c.name, SUM(cs.points) AS total_points FROM constructors AS c JOIN constructorStandings AS cs ON c.constructorId = cs.constructorId GROUP BY c.constructorId) AS combined_pointsORDER BY highest_points DESCLIMIT 1
SELECT C.name FROM constructors AS C INNER JOIN constructorResults AS CR ON C.constructorId = CR.constructorId WHERE CR.raceId = 18 AND CR.points = 0
SELECT COUNT(DISTINCT C.constructorId) FROM constructors AS C JOIN constructorResults AS CR ON C.constructorId = CR.constructorId WHERE C.nationality = 'Japanese' AND CR.points = 0 GROUP BY C.constructorId HAVING COUNT(DISTINCT CR.raceId) = 2
SELECT T1.name FROM constructors AS T1 INNER JOIN constructorStandings AS T2 ON T1.constructorId = T2.constructorId WHERE T2.position = 1
SELECT COUNT(DISTINCT T1.constructorId) FROM constructors AS T1 INNER JOIN results AS T2 ON T1.constructorId = T2.constructorId WHERE T1.nationality = 'French' AND T2.laps > 50
SELECT (COUNT(CASE WHEN R.time IS NOT NULL THEN 1 END) * 100.0 / COUNT(*)) AS completion_percentageFROM results AS RJOIN drivers AS D ON R.driverId = D.driverIdJOIN races AS RACE ON R.raceId = RACE.raceIdWHERE D.nationality = 'Japanese' AND RACE.year BETWEEN 2007 AND 2009
SELECT R.year, AVG( CAST(SUBSTR(RES.time, 1, 2) AS INTEGER) * 3600 +  CAST(SUBSTR(RES.time, 4, 2) AS INTEGER) * 60 +  CAST(SUBSTR(RES.time, 7, 2) AS INTEGER) +  CAST(SUBSTR(RES.time, 10) AS INTEGER) / 1000 ) AS average_time_secondsFROM results AS RESJOIN races AS R ON RES.raceId = R.raceIdWHERE RES.position = 1 AND RES.time IS NOT NULLGROUP BY R.year
SELECT D.forename, D.surname FROM drivers AS D INNER JOIN driverStandings AS DS ON D.driverId = DS.driverId WHERE DS.position = 2 AND D.dob > '1975-01-01'
SELECT COUNT(*) FROM drivers AS D INNER JOIN results AS R ON D.driverId = R.driverId WHERE D.nationality = 'Italian' AND R.time IS NULL
SELECT D.forename, D.surname FROM results AS R INNER JOIN drivers AS D ON R.driverId = D.driverId ORDER BY CAST(SUBSTR(R.fastestLapTime, 1, INSTR(R.fastestLapTime, ':') - 1) AS INTEGER) * 60 +  CAST(SUBSTR(R.fastestLapTime, INSTR(R.fastestLapTime, ':') + 1) AS INTEGER)  ASC LIMIT 1
SELECT fastestLap FROM results WHERE raceId IN (SELECT raceId FROM races WHERE year = 2009) AND position = 1
SELECT AVG(T1.fastestLapSpeed) FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.name = 'Spanish Grand Prix' AND T2.year = 2009
SELECT T1.name, T1.year FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId WHERE T2.milliseconds IS NOT NULL AND T2.milliseconds = (SELECT MIN(milliseconds) FROM results WHERE milliseconds IS NOT NULL)
SELECT (COUNT(DISTINCT lapTimes.driverId) * 100.0 /  (SELECT COUNT(DISTINCT lapTimes.driverId)   FROM lapTimes   INNER JOIN races ON lapTimes.raceId = races.raceId   WHERE races.year BETWEEN 2000 AND 2005)) AS percentageFROM lapTimes INNER JOIN drivers ON lapTimes.driverId = drivers.driverId INNER JOIN races ON lapTimes.raceId = races.raceId WHERE drivers.dob < '1985-01-01' AND lapTimes.lap > 50 AND races.year BETWEEN 2000 AND 2005
SELECT COUNT(DISTINCT T1.driverId) FROM drivers AS T1 INNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverId WHERE T1.nationality = 'French' AND T2.milliseconds < 120000
SELECT code FROM drivers WHERE nationality = 'America';
SELECT raceId FROM races WHERE year = 2009
SELECT COUNT(DISTINCT driverId) FROM results WHERE raceId = 18
SELECT code, (SELECT COUNT(*) FROM drivers WHERE nationality = 'Dutch' AND driverId IN  (SELECT driverId FROM drivers ORDER BY dob DESC LIMIT 3)) AS netherlandic_count FROM drivers WHERE driverId IN (SELECT driverId FROM drivers ORDER BY dob DESC LIMIT 3);
SELECT driverRef FROM drivers WHERE forename = 'Robert' AND surname = 'Kubica';
SELECT COUNT(*) FROM drivers WHERE dob LIKE '1980%' AND nationality = 'Australian';
SELECT D.driverId, D.forename, D.surname, L.timeFROM drivers AS DINNER JOIN lapTimes AS L ON D.driverId = L.driverIdWHERE D.nationality = 'German' AND D.dob BETWEEN '1980-01-01' AND '1990-12-31'ORDER BY L.time ASCLIMIT 3
SELECT driverRef FROM drivers WHERE dob = (SELECT MIN(dob) FROM drivers WHERE nationality = 'German');
SELECT d.driverId, d.code FROM drivers AS d INNER JOIN results AS r ON d.driverId = r.driverId WHERE strftime('%Y', d.dob) = '1971' AND r.fastestLapTime IS NOT NULL
SELECT T1.driverId, MAX(T2.time) AS latest_lap_timeFROM drivers AS T1INNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverIdWHERE T1.nationality = 'Spanish' AND T1.dob < '1982-01-01'GROUP BY T1.driverIdORDER BY latest_lap_time DESCLIMIT 10
SELECT T2.year FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T1.fastestLapTime = (SELECT MIN(fastestLapTime) FROM results WHERE fastestLapTime IS NOT NULL)
SELECT T2.year FROM lapTimes AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE (CAST(SUBSTR(T1.time, 1, INSTR(T1.time, ':') - 1) AS INTEGER) * 60 * 1000 +  CAST(SUBSTR(T1.time, INSTR(T1.time, ':') + 1) AS INTEGER) * 1000) =   (SELECT MAX(CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS INTEGER) * 60 * 1000 + CAST(SUBSTR(time, INSTR(time, ':') + 1) AS INTEGER) * 1000) FROM lapTimes)
SELECT T1.driverId FROM lapTimes AS T1 WHERE T1.lap = 1 ORDER BY T1.milliseconds ASC LIMIT 5
SELECT COUNT(*) FROM results AS R INNER JOIN status AS S ON R.statusId = S.statusId WHERE R.raceId > 50 AND R.raceId < 100 AND R.time IS NULL AND S.statusId = 2
SELECT COUNT(T1.raceId) AS number_of_races, T2.location, T2.lat, T2.lng FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Austria' GROUP BY T2.location, T2.lat, T2.lng
SELECT roundFROM racesWHERE raceId = ( SELECT raceId FROM results WHERE time IS NOT NULL GROUP BY raceId ORDER BY COUNT(*) DESC LIMIT 1)
SELECT D.driverRef, D.nationality, D.dob FROM qualifying AS Q INNER JOIN drivers AS D ON Q.driverId = D.driverId WHERE Q.raceId = 23 AND Q.q2 IS NOT NULL
SELECT R.year, R.name, R.date, R.time FROM races AS R WHERE R.raceId = (SELECT Q.raceId    FROM qualifying AS Q    WHERE Q.driverId = (SELECT driverId     FROM drivers     ORDER BY dob ASC     LIMIT 1)    LIMIT 1)
SELECT COUNT(*) FROM results AS R INNER JOIN drivers AS D ON R.driverId = D.driverId INNER JOIN status AS S ON R.statusId = S.statusId WHERE D.nationality = 'American' AND S.statusId = 2
SELECT T1.url FROM constructors AS T1 INNER JOIN constructorStandings AS T2 ON T1.constructorId = T2.constructorId WHERE T1.nationality = 'Italian' ORDER BY T2.points DESC LIMIT 1
SELECT url FROM constructors WHERE constructorId IN (SELECT constructorId FROM constructorStandings WHERE wins = (SELECT MAX(wins) FROM constructorStandings))
SELECT driverId, milliseconds FROM lapTimes WHERE raceId = (SELECT raceId FROM races WHERE name = 'French Grand Prix') AND lap = 3 ORDER BY milliseconds DESC LIMIT 1
SELECT T1.raceId, T1.milliseconds FROM lapTimes AS T1 WHERE T1.lap = 1 AND T1.milliseconds = ( SELECT MIN(milliseconds) FROM lapTimes WHERE lap = 1)
SELECT AVG(CAST(fastestLapTime AS REAL)) FROM results WHERE raceId = (SELECT raceId FROM races WHERE year = 2006 AND name = 'United States Grand Prix') AND rank < 11
SELECT d.driverId, d.forename, d.surname, AVG(p.duration) AS average_duration FROM drivers AS d JOIN pitStops AS p ON d.driverId = p.driverId WHERE d.nationality = 'German' AND d.dob BETWEEN '1980-01-01' AND '1985-12-31' GROUP BY d.driverId ORDER BY average_duration ASC LIMIT 5
SELECT D.forename || ' ' || D.surname AS champion_name, R.time AS finish_timeFROM results AS RINNER JOIN races AS RA ON R.raceId = RA.raceIdINNER JOIN drivers AS D ON R.driverId = D.driverIdWHERE RA.name = 'Canadian Grand Prix' AND RA.year = 2008 AND R.positionText = '1'
SELECT C.constructorRef, C.url FROM constructors AS C INNER JOIN results AS R ON C.constructorId = R.constructorId WHERE R.raceId = (SELECT raceId FROM races WHERE year = 2009 AND name = 'Singapore Grand Prix') AND R.position = 1
SELECT forename, surname, dob FROM drivers WHERE nationality = 'Austrian' AND strftime('%Y', dob) BETWEEN '1981' AND '1991'
SELECT forename || ' ' || surname AS full_name, url, dob FROM drivers WHERE nationality = 'German' AND strftime('%Y', dob) BETWEEN '1971' AND '1985' ORDER BY dob DESC
SELECT location, country, lat, lng FROM circuits WHERE name = 'Hungaroring';
SELECT SUM(CR.points) AS total_points, C.name, C.nationalityFROM constructorResults AS CRINNER JOIN races AS R ON CR.raceId = R.raceIdINNER JOIN constructors AS C ON CR.constructorId = C.constructorIdWHERE R.name = 'Monaco Grand Prix' AND R.year BETWEEN 1980 AND 2010GROUP BY C.constructorIdORDER BY total_points DESCLIMIT 1
SELECT AVG(T1.points) FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T1.driverId = T3.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' AND T2.name = 'Turkish Grand Prix'
SELECT AVG(race_count) AS average_racesFROM ( SELECT COUNT(*) AS race_count FROM races WHERE date BETWEEN '2000-01-01' AND '2010-12-31' GROUP BY year) AS yearly_races;
SELECT nationality FROM drivers GROUP BY nationality ORDER BY COUNT(nationality) DESC LIMIT 1
SELECT CASE  WHEN EXISTS (SELECT 1 FROM driverStandings WHERE position = 91)  THEN (SELECT wins FROM driverStandings WHERE position = 91)  ELSE 0 END AS victories; This query will return the number of victories for the driver in the 91st position if they exist, or 0 if they do not.
SELECT r.name FROM results AS res INNER JOIN races AS r ON res.raceId = r.raceId WHERE res.fastestLapSpeed = (SELECT MIN(fastestLapSpeed) FROM results)
SELECT T1.name, T2.location || ', ' || T2.country AS full_locationFROM races AS T1INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitIdWHERE T1.date = (SELECT MAX(date) FROM races)
SELECT d.forename, d.surname FROM drivers AS d WHERE d.driverId = ( SELECT q.driverId FROM qualifying AS q WHERE q.raceId = ( SELECT r.raceId  FROM races AS r  WHERE r.year = 2008 AND r.circuitId = ( SELECT c.circuitId  FROM circuits AS c  WHERE c.name = 'Marina Bay Street Circuit' ) ) AND q.position = 1 AND q.q3 = ( SELECT MIN(q2.q3)  FROM qualifying AS q2  WHERE q2.raceId = q.raceId ) LIMIT 1)
SELECT d.forename || ' ' || d.surname AS full_name, d.nationality, r.name AS race_name FROM drivers d JOIN results res ON d.driverId = res.driverId JOIN races r ON res.raceId = r.raceId WHERE d.dob = (SELECT MAX(dob) FROM drivers) ORDER BY res.resultId ASC LIMIT 1
SELECT accident_count FROM ( SELECT driverId, COUNT(*) AS accident_count FROM results WHERE raceId = (SELECT raceId FROM races WHERE name = 'Canadian Grand Prix') AND statusId = 3 GROUP BY driverId ) AS accident_counts ORDER BY accident_count DESC LIMIT 1
SELECT T1.wins, T2.forename, T2.surname FROM driverStandings AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T2.dob = (SELECT MIN(dob) FROM drivers)
SELECT MAX(duration) FROM pitStops
SELECT time FROM lapTimes WHERE milliseconds = (SELECT MIN(milliseconds) FROM lapTimes)
SELECT MAX(T1.duration) FROM pitStops AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton'
SELECT lap FROM pitStops WHERE raceId = (SELECT raceId FROM races WHERE name = 'Australian Grand Prix' AND year = 2011) AND driverId = (SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton')
SELECT T1.driverId, T1.duration FROM pitStops AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.year = 2011 AND T2.name = 'Australian Grand Prix'
SELECT T1.time, T2.name FROM lapTimes AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T1.driverId = (SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton') ORDER BY T1.milliseconds ASC LIMIT 1
SELECT d.forename, d.surname FROM lapTimes AS lt JOIN drivers AS d ON lt.driverId = d.driverId WHERE lt.time = (SELECT MIN(time) FROM lapTimes)
SELECT circuits.name, results.position FROM results INNER JOIN races ON results.raceId = races.raceId INNER JOIN circuits ON races.circuitId = circuits.circuitId WHERE results.driverId = (SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton') AND results.fastestLap = (SELECT MIN(fastestLap) FROM results WHERE driverId = (SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton'))
SELECT MIN(CAST(SUBSTR(T1.time, 1, INSTR(T1.time, ':') - 1) AS INTEGER) * 60000 +   CAST(SUBSTR(T1.time, INSTR(T1.time, ':') + 1) AS INTEGER)) AS lap_recordFROM lapTimes AS T1INNER JOIN races AS T2 ON T1.raceId = T2.raceIdWHERE T2.name = 'Austrian Grand Prix'
SELECT T1.lap, T1.time, T1.driverId FROM lapTimes AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId INNER JOIN circuits AS T3 ON T2.circuitId = T3.circuitId WHERE T3.country = 'Italy'ORDER BY T1.time ASC
SELECT r.name FROM races r JOIN (SELECT raceId, MIN(milliseconds) AS fastest_lap_time   FROM lapTimes   WHERE raceId IN (SELECT raceId FROM races WHERE circuitId = (SELECT circuitId FROM circuits WHERE name = 'Austrian Grand Prix Circuit'))   GROUP BY raceId) AS fastest_lap ON r.raceId = fastest_lap.raceId
SELECT T2.duration FROM pitStops AS T2 WHERE T2.raceId = (SELECT raceId FROM races WHERE name = 'Austrian Grand Prix') AND T2.driverId = (SELECT driverId FROM lapTimes WHERE raceId = (SELECT raceId FROM races WHERE name = 'Austrian Grand Prix') ORDER BY milliseconds ASC LIMIT 1)
SELECT C.lat, C.lng FROM lapTimes AS L INNER JOIN races AS R ON L.raceId = R.raceId INNER JOIN circuits AS C ON R.circuitId = C.circuitId WHERE L.time = '1:29.488'
SELECT AVG(P.milliseconds) FROM pitStops AS P INNER JOIN drivers AS D ON P.driverId = D.driverId WHERE D.forename = 'Lewis' AND D.surname = 'Hamilton'
SELECT AVG(T1.milliseconds) FROM lapTimes AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId INNER JOIN circuits AS T3 ON T2.circuitId = T3.circuitId WHERE T3.country = 'Italy'
SELECT T1.player_api_id FROM Player AS T1 JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)
SELECT player_name, height FROM Player WHERE height = (SELECT MAX(height) FROM Player);
SELECT preferred_foot FROM Player_Attributes WHERE potential = (SELECT MIN(potential) FROM Player_Attributes)
SELECT COUNT(*) FROM Player_Attributes AS PA INNER JOIN Player AS P ON PA.player_api_id = P.player_api_id WHERE PA.overall_rating >= 60 AND PA.overall_rating < 65 AND PA.defensive_work_rate = 'low';
SELECT P.id, PA.crossing FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id ORDER BY PA.crossing DESC LIMIT 5
SELECT L.name, SUM(M.home_team_goal + M.away_team_goal) AS total_goalsFROM Match AS MJOIN League AS L ON M.league_id = L.idWHERE M.season = '2015/2016'GROUP BY L.idORDER BY total_goals DESCLIMIT 1
SELECT T.team_long_name, COUNT(*) AS lossesFROM Match AS MINNER JOIN Team AS T ON M.home_team_api_id = T.team_api_idWHERE M.home_team_goal < M.away_team_goal AND M.season = '2015/2016'GROUP BY T.team_long_nameORDER BY losses ASCLIMIT 1
SELECT P.player_name FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id ORDER BY PA.penalties DESC LIMIT 10
SELECT away_team_api_id FROM Match WHERE league_id = (SELECT id FROM League WHERE name = 'Scotland Premier League') AND season = '2009/2010' AND away_team_goal > home_team_goal GROUP BY away_team_api_id ORDER BY COUNT(*) DESC LIMIT 1
SELECT team_api_id, buildUpPlaySpeed FROM Team_Attributes ORDER BY buildUpPlaySpeed DESC LIMIT 4 This revised query will return the `team_api_id` along with the `buildUpPlaySpeed` for the top 4 teams with the highest build-up play speed.
SELECT L.name, COUNT(*) AS draw_countFROM Match AS MJOIN League AS L ON M.league_id = L.idWHERE M.season = '2015/2016' AND M.home_team_goal = M.away_team_goalGROUP BY L.nameORDER BY draw_count DESCLIMIT 1
SELECT (strftime('%Y', 'now') - strftime('%Y', P.birthday)) - CASE  WHEN strftime('%m', 'now') < strftime('%m', P.birthday) OR   (strftime('%m', 'now') = strftime('%m', P.birthday) AND strftime('%d', 'now') < strftime('%d', P.birthday))  THEN 1  ELSE 0 END AS ageFROM Player_Attributes AS PAJOIN Player AS P ON PA.player_api_id = P.player_api_idWHERE PA.sprint_speed >= 97 AND PA.date >= '2013-01-01 00:00:00' AND PA.date <= '2015-12-31 00:00:00';
SELECT L.name, COUNT(M.id) AS match_countFROM Match AS MJOIN League AS L ON M.league_id = L.idGROUP BY M.league_idORDER BY match_count DESCLIMIT 1
SELECT AVG(height) AS average_height FROM Player WHERE birthday >= '1990-01-01 00:00:00' AND birthday < '1996-01-01 00:00:00';
SELECT player_api_id FROM Player_Attributes WHERE overall_rating = ( SELECT MAX(overall_rating) FROM Player_Attributes WHERE substr(date, 1, 4) = '2010' AND overall_rating > (SELECT AVG(overall_rating) FROM Player_Attributes WHERE substr(date, 1, 4) = '2010')) AND substr(date, 1, 4) = '2010'
SELECT T.team_fifa_api_id FROM Team AS T INNER JOIN Team_Attributes AS TA ON T.team_api_id = TA.team_api_id WHERE TA.buildUpPlaySpeed BETWEEN 51 AND 59
SELECT T.team_long_name FROM Team AS T JOIN Team_Attributes AS TA ON T.team_api_id = TA.team_api_id WHERE TA.buildUpPlayPassing > (SELECT AVG(buildUpPlayPassing)    FROM Team_Attributes    WHERE strftime('%Y', date) = '2012' AND buildUpPlayPassing IS NOT NULL)AND strftime('%Y', TA.date) = '2012';
SELECT (SUM(CASE WHEN preferred_foot = 'left' THEN 1 ELSE 0 END) * 1.0 / COUNT(player_fifa_api_id)) * 100 AS percentage_left_footFROM PlayerWHERE birthday BETWEEN '1987-01-01' AND '1992-12-31';
SELECT L.name, SUM(M.home_team_goal + M.away_team_goal) AS total_goalsFROM Match AS MINNER JOIN League AS L ON M.league_id = L.idGROUP BY L.nameORDER BY total_goals ASCLIMIT 5
SELECT AVG(PA.long_shots) FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE P.player_name = 'Ahmed Samir Farag'
SELECT P.player_name, AVG(PA.heading_accuracy) AS average_heading_accuracyFROM Player AS PINNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_idWHERE P.height > 180GROUP BY P.player_api_idORDER BY average_heading_accuracy DESCLIMIT 10
SELECT T.team_long_nameFROM Team_Attributes AS TAINNER JOIN Team AS T ON TA.team_api_id = T.team_api_idWHERE TA.buildUpPlayDribblingClass = 'Normal' AND TA.date >= '2014-01-01 00:00:00' AND TA.date <= '2014-12-31 23:59:59'AND TA.chanceCreationPassing < (SELECT AVG(chanceCreationPassing)    FROM Team_Attributes    WHERE date >= '2014-01-01 00:00:00'    AND date <= '2014-12-31 23:59:59')ORDER BY TA.chanceCreationPassing DESC
SELECT L.name FROM League AS L JOIN Match AS M ON L.id = M.league_id WHERE M.season = '2009/2010' GROUP BY L.id HAVING AVG(M.home_team_goal) > AVG(M.away_team_goal)
SELECT team_short_name FROM Team WHERE team_long_name = 'Queens Park Rangers';
SELECT player_name, birthday FROM Player WHERE substr(birthday, 1, 4) = '1970' AND substr(birthday, 6, 2) = '10'
SELECT PA.attacking_work_rate FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE P.player_name = 'Franco Zennaro'
SELECT T2.buildUpPlayPositioningClass FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T1.team_long_name = 'ADO Den Haag'
SELECT PA.heading_accuracy FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE P.player_name = 'Francois Affolter' AND PA.date = '2014-09-18 00:00:00'
SELECT overall_rating FROM Player_Attributes WHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Gabriel Tamas') AND strftime('%Y', date) = '2011'
SELECT COUNT(*) FROM Match AS M INNER JOIN League AS L ON M.league_id = L.id WHERE L.name = 'Scotland Premier League' AND M.season = '2015/2016'
SELECT pa.preferred_foot FROM Player_Attributes pa JOIN Player p ON pa.player_api_id = p.player_api_id WHERE p.birthday = (SELECT MAX(birthday) FROM Player); This query correctly joins the `Player_Attributes` and `Player` tables and retrieves the `preferred_foot` of the youngest player based on the latest birthday.
SELECT P.player_name FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE PA.potential = (SELECT MAX(potential) FROM Player_Attributes)
SELECT COUNT(*) FROM Player WHERE weight < 130 AND preferred_foot = 'left';
SELECT T.team_short_name FROM Team AS T INNER JOIN Team_Attributes AS TA ON T.id = TA.team_api_id WHERE TA.chanceCreationPassingClass = 'Risky'
SELECT PA.defensive_work_rate FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE P.player_name = 'David Wilson'
SELECT P.birthday FROM Player AS P WHERE P.player_api_id = (SELECT player_api_id    FROM Player_Attributes    WHERE overall_rating = (SELECT MAX(overall_rating)     FROM Player_Attributes)    LIMIT 1)This ensures that we only get one player in case of ties for the highest overall rating.
SELECT L.name FROM League AS L INNER JOIN Country AS C ON L.country_id = C.id WHERE C.name = 'Netherlands'
SELECT AVG(M.home_team_goal) FROM Match AS M INNER JOIN Country AS C ON M.country_id = C.id WHERE C.name = 'Poland' AND M.season = '2010/2011'
SELECT p.player_name, AVG(pa.finishing) AS average_finishingFROM Player AS pJOIN Player_Attributes AS pa ON p.player_api_id = pa.player_api_idWHERE p.player_api_id IN ( SELECT player_api_id FROM Player WHERE height = (SELECT MAX(height) FROM Player) UNION SELECT player_api_id FROM Player WHERE height = (SELECT MIN(height) FROM Player))GROUP BY p.player_api_idORDER BY average_finishing DESCLIMIT 1
SELECT player_name FROM Player WHERE height > 180
SELECT COUNT(*) FROM Player WHERE strftime('%Y', birthday) > '1990';
SELECT COUNT(*) FROM Player WHERE player_name LIKE 'Adam%' AND weight > 170
SELECT P.player_name FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE PA.overall_rating > 80 AND strftime('%Y', PA.date) BETWEEN '2008' AND '2010'
SELECT PA.potential FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE P.player_name = 'Aaron Doran'
SELECT P.player_name FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.id = PA.player_api_id WHERE PA.preferred_foot = 'left'
SELECT T.team_long_name FROM Team AS T INNER JOIN Team_Attributes AS TA ON T.team_api_id = TA.team_api_id WHERE TA.buildUpPlaySpeedClass = 'Fast'
SELECT T2.buildUpPlayPassingClass FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T1.team_short_name = 'CLB'
SELECT T.team_short_name FROM Team AS T INNER JOIN Team_Attributes AS TA ON T.team_api_id = TA.team_api_id WHERE TA.buildUpPlayPassing > 70
SELECT AVG(PA.overall_rating) FROM Player_Attributes AS PA INNER JOIN Player AS P ON PA.player_api_id = P.player_api_id WHERE strftime('%Y', PA.date) BETWEEN '2010' AND '2015' AND P.height > 170
SELECT player_name, height FROM Player WHERE height = (SELECT MIN(height) FROM Player);
SELECT C.name FROM League AS L INNER JOIN Country AS C ON L.country_id = C.id WHERE L.name = 'Italy Serie A'
SELECT T.team_short_name FROM Team AS T INNER JOIN Team_Attributes AS TA ON T.team_api_id = TA.team_api_id WHERE TA.buildUpPlaySpeed = 31   AND TA.buildUpPlayDribbling = 53   AND TA.buildUpPlayPassing = 32
SELECT AVG(PA.overall_rating) FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE P.player_name = 'Aaron Doran'
SELECT COUNT(*) FROM Match AS M INNER JOIN League AS L ON M.league_id = L.id WHERE L.name = 'Germany 1. Bundesliga' AND strftime('%Y-%m', M.date) BETWEEN '2008-08' AND '2008-10'
SELECT T.team_short_name FROM Match AS M INNER JOIN Team AS T ON M.home_team_api_id = T.team_api_id WHERE M.home_team_goal = 10
SELECT P.player_name FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE PA.balance = (SELECT MAX(balance) FROM Player_Attributes WHERE potential = 61) AND PA.potential = 61
SELECT (SELECT AVG(ball_control) FROM Player_Attributes  WHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Abdou Diallo')) - (SELECT AVG(ball_control) FROM Player_Attributes  WHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Aaron Appindangoye')) AS ball_control_difference
`SELECT team_long_name FROM Team WHERE team_short_name = 'GEN';`
SELECT player_name, birthday FROM Player WHERE player_name IN ('Aaron Lennon', 'Abdelaziz Barrada') ORDER BY birthday ASC LIMIT 1
SELECT player_name, height FROM Player WHERE height = (SELECT MAX(height) FROM Player);
SELECT COUNT(*) FROM Player pJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_idWHERE pa.preferred_foot = 'left' AND pa.attacking_work_rate = 'low';
SELECT C.name FROM League AS L INNER JOIN Country AS C ON L.country_id = C.id WHERE L.name = 'Belgium Jupiler League'
SELECT L.name FROM League AS L INNER JOIN Country AS C ON L.country_id = C.id WHERE C.name = 'Germany'
SELECT P.player_name FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE PA.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)
SELECT COUNT(*) FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE strftime('%Y', P.birthday) < '1986' AND PA.defensive_work_rate = 'high'
SELECT P.player_name, PA.crossing FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE P.player_name IN ('Alexis', 'Ariel Borysiuk', 'Arouna Kone') ORDER BY PA.crossing DESC LIMIT 1
SELECT PA.heading_accuracy FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE P.player_name = 'Ariel Borysiuk'
SELECT COUNT(*) FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE P.height > 180 AND PA.volleys > 70
SELECT P.player_name FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE PA.volleys > 70 AND PA.dribbling > 70
SELECT COUNT(*) FROM Match AS M INNER JOIN Country AS C ON M.country_id = C.id WHERE M.season = '2008/2009' AND C.name = 'Belgium'
SELECT PA.long_passing FROM Player_Attributes AS PA INNER JOIN Player AS P ON PA.player_api_id = P.player_api_id WHERE P.player_api_id = (SELECT player_api_id FROM Player ORDER BY birthday DESC LIMIT 1)
SELECT COUNT(*) FROM Match AS M INNER JOIN League AS L ON M.league_id = L.id WHERE L.name = 'Belgium Jupiler League' AND strftime('%Y', M.date) = '2009' AND strftime('%m', M.date) = '04'
SELECT L.name, COUNT(M.id) AS match_countFROM Match AS MJOIN League AS L ON M.league_id = L.idWHERE M.season = '2008/2009'GROUP BY M.league_idORDER BY match_count DESCLIMIT 1
SELECT AVG(PA.overall_rating) AS average_rating FROM Player_Attributes AS PA INNER JOIN Player AS P ON PA.player_api_id = P.player_api_id WHERE strftime('%Y', P.birthday) < '1986'
SELECT (ariel_rating - paul_rating) AS rating_difference, ariel_rating, paul_rating, ((ariel_rating - paul_rating) * 100.0 / paul_rating) AS percentage_differenceFROM ( SELECT  (SELECT overall_rating FROM Player_Attributes  WHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Ariel Borysiuk')) AS ariel_rating, (SELECT overall_rating FROM Player_Attributes  WHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Paulin Puel')) AS paul_rating);This revised query retrieves the overall ratings for both players once and calculates the required differences and percentages in a more efficient manner.
SELECT AVG(TA.buildUpPlaySpeed) FROM Team AS T INNER JOIN Team_Attributes AS TA ON T.id = TA.team_api_id WHERE T.team_long_name = 'Heart of Midlothian'
SELECT AVG(T2.overall_rating) FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Pietro Marino'
SELECT SUM(pa.crossing) AS total_crossing_scoreFROM Player pJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_idWHERE p.player_name = 'Aaron Lennox';
SELECT MAX(TA.chanceCreationPassing) AS highest_chance_creation_passing_score, TA.chanceCreationPassingClass FROM Team AS T INNER JOIN Team_Attributes AS TA ON T.team_api_id = TA.team_api_id WHERE T.team_long_name = 'Ajax'AND TA.chanceCreationPassing = (SELECT MAX(chanceCreationPassing)    FROM Team_Attributes    WHERE team_api_id = T.team_api_id)This query ensures that we get the classification corresponding to the maximum chance creation passing score for Ajax.
SELECT PA.preferred_foot FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE P.player_name = 'Abdou Diallo'
SELECT MAX(overall_rating) FROM Player_Attributes WHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Dorlan Pabon')
SELECT AVG(M.away_team_goal) FROM Match AS M INNER JOIN Team AS T ON M.away_team_api_id = T.team_api_id INNER JOIN Country AS C ON M.country_id = C.id WHERE T.team_long_name = 'Parma' AND C.name = 'Italy'
SELECT P.player_name FROM Player AS P WHERE P.player_api_id IN ( SELECT player_api_id FROM Player_Attributes WHERE overall_rating = 77 AND date = '2016-06-23') ORDER BY P.birthday ASC LIMIT 1
SELECT overall_rating FROM Player_Attributes WHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Aaron Mooy') AND date = '2016-02-04 00:00:00'
SELECT potential FROM Player_Attributes WHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Francesco Parravicini') AND date = '2010-08-30 00:00:00'
SELECT attacking_work_rate FROM Player_Attributes WHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Francesco Migliore') AND date = '2015-05-01 00:00:00'
SELECT defensive_work_rate FROM Player_Attributes WHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Kevin Berigaud') AND date = '2013-02-22 00:00:00'
SELECT date FROM Player_Attributes AS PA INNER JOIN Player AS P ON PA.player_api_id = P.player_api_id WHERE P.player_name = 'Kevin Constant' AND PA.crossing = (SELECT MAX(crossing) FROM Player_Attributes AS PA INNER JOIN Player AS P ON PA.player_api_id = P.player_api_id WHERE P.player_name = 'Kevin Constant')ORDER BY date ASC LIMIT 1
SELECT T2.buildUpPlaySpeedClass FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T1.team_long_name = 'Willem II' AND T2.date = '2012-02-22 00:00:00'
SELECT T2.buildUpPlayDribblingClass FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T1.team_short_name = 'LEI' AND T2.date = '2015-09-10 00:00:00'
SELECT T2.buildUpPlayPassingClass FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T1.team_long_name = 'FC Lorient' AND T2.date = '2010-02-22'
SELECT T2.chanceCreationPassingClass FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T1.team_long_name = 'PEC Zwolle' AND T2.date = '2013-09-20 00:00:00'
SELECT chanceCreationCrossingClass FROM Team_Attributes WHERE team_api_id = (SELECT team_api_id FROM Team WHERE team_long_name = 'Hull City') AND date = '2010-02-22 00:00:00'
SELECT TA.defenceAggressionClass FROM Team_Attributes AS TA INNER JOIN Team AS T ON TA.team_api_id = T.id WHERE T.team_long_name = 'Hannover 96' AND TA.date = '2015-09-10 00:00:00'
SELECT AVG(PA.overall_rating) FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE P.player_name = 'Marko Arnautovic' AND PA.date BETWEEN '2007-02-22 00:00:00' AND '2016-04-21 00:00:00'
SELECT ((SELECT overall_rating   FROM Player_Attributes AS PA   JOIN Player AS P ON PA.player_api_id = P.player_api_id   WHERE P.player_name = 'Landon Donovan' AND PA.date = '2013-07-12') -  (SELECT overall_rating   FROM Player_Attributes AS PA   JOIN Player AS P ON PA.player_api_id = P.player_api_id   WHERE P.player_name = 'Jordan Bowery' AND PA.date = '2013-07-12')) * 100.0 / (SELECT overall_rating   FROM Player_Attributes AS PA   JOIN Player AS P ON PA.player_api_id = P.player_api_id   WHERE P.player_name = 'Landon Donovan' AND PA.date = '2013-07-12') AS percentage_difference
SELECT player_name FROM Player ORDER BY height DESC LIMIT 5
SELECT player_api_id FROM Player ORDER BY weight DESC LIMIT 10
SELECT player_name FROM Player WHERE (julianday('now') - julianday(birthday)) / 365.25 >= 35;
SELECT SUM(home_team_goal) FROM Match WHERE home_team_api_id IN ( SELECT team_api_id FROM Player_Attributes WHERE player_api_id = ( SELECT player_api_id  FROM Player  WHERE player_name = 'Aaron Lennon' ))
SELECT SUM(away_team_goal) FROM Match WHERE away_team_api_id IN ( SELECT team_api_id FROM Player_Attributes WHERE player_api_id IN ( SELECT player_api_id  FROM Player  WHERE player_name IN ('Daan Smith', 'Filipe Ferreira') ))
SELECT SUM(M.home_team_goal) FROM Match AS M INNER JOIN Team AS T ON M.home_team_api_id = T.team_api_id INNER JOIN Player AS P ON T.team_api_id = P.team_api_id WHERE (strftime('%Y', 'now') - strftime('%Y', P.birthday)) <= 30
SELECT P.player_name FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE PA.overall_rating IN ( SELECT DISTINCT PA2.overall_rating FROM Player_Attributes AS PA2 ORDER BY PA2.overall_rating DESC LIMIT 10)ORDER BY PA.overall_rating DESC;
SELECT P.player_name FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE PA.potential = (SELECT MAX(potential) FROM Player_Attributes)
SELECT P.player_name FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE PA.attacking_work_rate = 'high'
SELECT P.player_name FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE PA.finishing = 1 ORDER BY P.birthday DESC LIMIT 1
SELECT DISTINCT P.player_name FROM Player AS P JOIN Team AS T ON P.player_api_id = T.team_api_id JOIN League AS L ON T.team_api_id = L.id JOIN Country AS C ON L.country_id = C.id WHERE C.name = 'Belgium' However, since the `League` table has a `country_id` that references the `Country` table, we should actually join `Team` to `League` using the `team_api_id` instead of `team_api_id` to `league_id`. The correct join should be:Revised_SQL: SELECT DISTINCT P.player_name FROM Player AS P JOIN Team AS T ON P.player_api_id = T.team_api_id JOIN League AS L ON T.team_api_id = L.id JOIN Country AS C ON L.country_id = C.id WHERE C.name = 'Belgium'This query is now correct and retrieves the names of players who came from Belgium.
SELECT P.player_name, C.name AS country_nameFROM Player AS PINNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_idINNER JOIN Team_Attributes AS TA ON P.id = TA.team_api_idINNER JOIN Team AS T ON TA.team_api_id = T.team_api_idINNER JOIN League AS L ON T.id = L.country_idINNER JOIN Country AS C ON L.country_id = C.idWHERE PA.vision >= 90
SELECT C.nameFROM Country AS CJOIN League AS L ON C.id = L.country_idJOIN Match AS M ON L.id = M.league_idJOIN Team AS T ON M.home_team_api_id = T.team_api_id OR M.away_team_api_id = T.team_api_idJOIN Player AS P ON T.team_api_id = P.player_api_idGROUP BY C.nameORDER BY AVG(P.weight) DESCLIMIT 1
SELECT T.team_long_name FROM Team AS T INNER JOIN Team_Attributes AS TA ON T.id = TA.team_api_id WHERE TA.buildUpPlaySpeedClass = 'Slow'
SELECT T.team_short_name FROM Team AS T INNER JOIN Team_Attributes AS TA ON T.id = TA.team_api_id WHERE TA.chanceCreationPassingClass = 'Safe'
SELECT AVG(P.height) FROM Player AS P JOIN Team AS T ON P.team_api_id = T.team_api_id JOIN League AS L ON T.id = L.country_id JOIN Country AS C ON L.country_id = C.id WHERE C.name = 'Italy'
SELECT player_name FROM Player WHERE height > 180 ORDER BY player_name ASC LIMIT 3
SELECT COUNT(*) FROM Player WHERE player_name LIKE 'Aaron%' AND birthday > '1990-12-31';
SELECT (SELECT jumping FROM Player_Attributes WHERE player_api_id = 6) - (SELECT jumping FROM Player_Attributes WHERE player_api_id = 23) AS jumping_difference
SELECT P.id FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE PA.potential = (SELECT MIN(potential) FROM Player_Attributes) AND PA.preferred_foot = 'right' ORDER BY P.id  -- This ensures we have a consistent order in case of tiesLIMIT 3
SELECT COUNT(*) FROM Player_Attributes WHERE crossing = (SELECT MAX(crossing) FROM Player_Attributes) AND preferred_foot = 'left';
SELECT (SELECT COUNT(*) FROM Player_Attributes WHERE strength > 80 AND stamina > 80) * 100.0 / (SELECT COUNT(*) FROM Player) AS percentage
SELECT C.name FROM League AS L INNER JOIN Country AS C ON L.country_id = C.id WHERE L.name = 'Poland Ekstraklasa'
SELECT T1.home_team_goal, T1.away_team_goal FROM Match AS T1 INNER JOIN League AS T2 ON T1.league_id = T2.id WHERE T1.date LIKE '2008-09-24%' AND T2.name = 'Belgian Jupiler League'
SELECT PA.sprint_speed, PA.agility, PA.acceleration FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE P.player_name = 'Alexis Blin'
SELECT T2.buildUpPlaySpeedClass FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T1.team_long_name = 'KSV Cercle Brugge'
SELECT COUNT(*) FROM Match AS M INNER JOIN League AS L ON M.league_id = L.id WHERE M.season = '2015/2016' AND L.name = 'Italian Serie A'
SELECT MAX(M.home_team_goal) FROM Match AS M INNER JOIN League AS L ON M.league_id = L.id WHERE L.name = 'Eredivisie' AND L.country_id = (SELECT id FROM Country WHERE name = 'Netherlands')
SELECT Player_Attributes.finishing, Player_Attributes.curve FROM Player_Attributes WHERE player_api_id = (SELECT player_api_id FROM Player WHERE weight = (SELECT MAX(weight) FROM Player))
SELECT L.name, COUNT(M.id) AS match_countFROM Match AS MJOIN League AS L ON M.league_id = L.idWHERE M.season = '2015/2016'GROUP BY L.idORDER BY match_count DESCLIMIT 1
SELECT T.team_long_name FROM Team AS T INNER JOIN Match AS M ON M.away_team_api_id = T.team_api_id WHERE M.away_team_goal = (SELECT MAX(away_team_goal) FROM Match)
SELECT P.player_name FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE PA.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)LIMIT 1
SELECT (COUNT(CASE WHEN P.height < 180 AND PA.overall_rating > 70 THEN 1 END) * 100.0) / COUNT(P.id) AS percentageFROM Player AS PJOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id
SELECT (COUNT(CASE WHEN SEX = 'M' AND Admission = '+' THEN 1 END) -  COUNT(CASE WHEN SEX = 'M' AND Admission = '-' THEN 1 END)) * 100.0 / NULLIF(COUNT(CASE WHEN SEX = 'M' THEN 1 END), 0) AS deviation_percentageFROM Patient
SELECT (CAST(COUNT(CASE WHEN Birthday > '1930-01-01' AND SEX = 'F' THEN ID END) AS REAL) / COUNT(CASE WHEN SEX = 'F' THEN ID END)) * 100 AS percentage_female_born_after_1930FROM Patient;
SELECT (COUNT(CASE WHEN Admission = '+' THEN 1 END) * 100.0 / COUNT(*)) AS inpatient_percentageFROM PatientWHERE Birthday BETWEEN '1930-01-01' AND '1940-12-31';
SELECT CAST(COUNT(CASE WHEN Admission = '+' THEN ID END) AS REAL) / NULLIF(COUNT(CASE WHEN Admission = '-' THEN ID END), 0) AS ratioFROM PatientWHERE Diagnosis = 'SLE';
SELECT P.Diagnosis, L.Date FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE P.ID = 30609
SELECT P.SEX, P.Birthday, E.Examination Date, E.Symptoms FROM Patient AS P INNER JOIN Examination AS E ON P.ID = E.ID WHERE P.ID = 163109
SELECT P.ID, P.SEX, P.Birthday FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE L.LDH > 500
SELECT P.ID, (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) AS age FROM Patient AS P INNER JOIN Examination AS E ON P.ID = E.ID WHERE E.RVVT = '+'
SELECT P.ID, P.SEX, E.Diagnosis FROM Examination AS E INNER JOIN Patient AS P ON E.ID = P.ID WHERE E.Thrombosis = 2
SELECT P.ID, P.SEX, P.Birthday, P.Description, P.First_Date, P.Admission, P.Diagnosis FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE strftime('%Y', P.Birthday) = '1937' AND L.T-CHO >= 250
SELECT P.ID, P.SEX, P.Diagnosis FROM Laboratory AS L INNER JOIN Patient AS P ON L.ID = P.ID WHERE L.ALB < 3.5
SELECT CAST(SUM(CASE WHEN L.TP < 6.0 OR L.TP > 8.5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) AS percentageFROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE P.SEX = 'F'
SELECT AVG(E.aCL IgG) FROM Examination AS E INNER JOIN Patient AS P ON E.ID = P.ID WHERE P.Admission = '+' AND (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) >= 50
SELECT COUNT(*) FROM Patient WHERE SEX = 'F' AND strftime('%Y', First Date) = '1997' AND Admission = '-';
SELECT MIN(strftime('%Y', First Date) - strftime('%Y', Birthday)) AS age FROM Patient WHERE First Date IS NOT NULL;
SELECT COUNT(*) FROM Examination AS E INNER JOIN Patient AS P ON E.ID = P.ID WHERE E.Thrombosis = 1 AND P.SEX = 'F' AND E.Examination_Date LIKE '1997%'
SELECT (MAX(strftime('%Y', Birthday)) - MIN(strftime('%Y', Birthday))) AS age_gapFROM Patient AS PINNER JOIN Laboratory AS L ON P.ID = L.IDWHERE L.TG >= 200
SELECT E.Symptoms, E.Diagnosis FROM Examination AS E INNER JOIN Patient AS P ON E.ID = P.ID WHERE P.Birthday = (SELECT MIN(Birthday) FROM Patient)
SELECT COUNT(L.ID) / 12.0 AS average_male_patients_per_monthFROM Laboratory AS LINNER JOIN Patient AS P ON L.ID = P.IDWHERE L.Date BETWEEN '1998-01-01' AND '1998-12-31' AND P.SEX = 'M'
SELECT (strftime('%Y', First_Date) - strftime('%Y', Birthday)) AS Age, (SELECT Date FROM Laboratory WHERE ID = (SELECT ID FROM Patient WHERE Diagnosis = 'SJS' ORDER BY Birthday ASC LIMIT 1)) AS Lab_DateFROM Patient WHERE ID = (SELECT ID FROM Patient WHERE Diagnosis = 'SJS' ORDER BY Birthday ASC LIMIT 1)
SELECT (SELECT COUNT(*) FROM Laboratory AS L INNER JOIN Patient AS P ON L.ID = P.ID WHERE P.SEX = 'M' AND L.UA <= 8.0) * 1.0 / (SELECT COUNT(*) FROM Laboratory AS L INNER JOIN Patient AS P ON L.ID = P.ID WHERE P.SEX = 'F' AND L.UA <= 6.5) AS male_to_female_ratio
SELECT COUNT(P.ID) FROM Patient AS P LEFT JOIN Examination AS E ON P.ID = E.ID WHERE E.ID IS NULL OR (strftime('%Y', E.Examination Date) - strftime('%Y', P.First Date)) >= 1
SELECT COUNT(DISTINCT P.ID) FROM Patient AS P JOIN Examination AS E ON P.ID = E.ID WHERE E.Examination_Date BETWEEN '1990-01-01' AND '1993-12-31' AND (strftime('%Y', E.Examination_Date) - strftime('%Y', P.Birthday)) < 18
SELECT COUNT(*) FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE P.SEX = 'M' AND L.T-BIL > 2.0
SELECT Diagnosis, COUNT(Diagnosis) AS DiagnosisCountFROM Examination AS EJOIN Patient AS P ON E.ID = P.IDJOIN Laboratory AS L ON P.ID = L.IDWHERE E.Examination Date BETWEEN '1985-01-01' AND '1995-12-31'GROUP BY DiagnosisORDER BY DiagnosisCount DESCLIMIT 1
SELECT AVG(STRFTIME('%Y', '1991-10-31') - STRFTIME('%Y', P.Birthday)) AS average_ageFROM Laboratory AS LINNER JOIN Patient AS P ON L.ID = P.IDWHERE L.Date BETWEEN '1991-10-01' AND '1991-10-31'
SELECT strftime('%Y', E.Examination_Date) - strftime('%Y', P.Birthday) AS Age, P.Diagnosis FROM Laboratory AS L JOIN Patient AS P ON L.ID = P.ID JOIN Examination AS E ON P.ID = E.ID WHERE L.HGB = (SELECT MAX(HGB) FROM Laboratory)
SELECT ANA FROM Examination WHERE ID = 3605340 AND Examination Date = '1996-12-02';
SELECT CASE  WHEN T1.T-CHO < 250 THEN 'Normal'  ELSE 'Abnormal' END AS Cholesterol_StatusFROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T2.ID = 2927464 AND T1.Date = '1995-09-04'
SELECT P.SEX FROM Patient AS P INNER JOIN Examination AS E ON P.ID = E.ID WHERE E.Diagnosis = 'AORTITIS' ORDER BY E.Examination Date LIMIT 1
SELECT aCL IgM FROM Examination WHERE ID = (SELECT ID FROM Patient WHERE Diagnosis = 'SLE' AND Description = '1994-02-19') AND Examination Date = '1993-11-12'
SELECT P.SEX FROM Laboratory AS L INNER JOIN Patient AS P ON L.ID = P.ID WHERE L.Date = '1992-06-12' AND L.GPT = 9
SELECT (1991 - strftime('%Y', Birthday)) AS Age FROM Patient WHERE ID = (SELECT ID FROM Laboratory WHERE UA = 8.4 AND Date = '1991-10-21') Since the only issue was the year used for the age calculation, the final query remains the same as the original provided query. Thus, the final answer is:Final_SQL: SELECT (1991 - strftime('%Y', Birthday)) AS Age FROM Patient WHERE ID = (SELECT ID FROM Laboratory WHERE UA = 8.4 AND Date = '1991-10-21')
SELECT COUNT(ID) FROM Laboratory WHERE ID = (SELECT ID FROM Patient WHERE First Date = '1991-06-13' AND Diagnosis = 'SJS') AND Date >= '1995-01-01' AND Date < '1996-01-01';
SELECT Diagnosis FROM Patient WHERE ID = (SELECT ID FROM Examination WHERE Diagnosis = 'SLE' AND [Examination Date] = '1997-01-27')
SELECT Symptoms FROM Examination WHERE ID = (SELECT ID FROM Patient WHERE Birthday = '1959-03-01') AND Examination Date = '1993-09-27'
SELECT (SUM(CASE WHEN Date LIKE '1981-11-%' THEN T-CHO ELSE 0 END) -  SUM(CASE WHEN Date LIKE '1981-12-%' THEN T-CHO ELSE 0 END)) AS Decrease_RateFROM Laboratory WHERE ID = (SELECT ID FROM Patient WHERE Birthday = '1959-02-18')
SELECT P.ID FROM Patient AS P INNER JOIN Examination AS E ON P.ID = E.ID WHERE P.Diagnosis = 'Behcet' AND E.Examination Date >= '1997-01-01' AND E.Examination Date < '1998-01-01'
SELECT DISTINCT P.ID FROM Patient AS P INNER JOIN Examination AS E ON P.ID = E.ID INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE E.Examination Date BETWEEN '1987-07-06' AND '1996-01-31' AND L.GPT > 30 AND L.ALB < 4
SELECT ID FROM Patient WHERE SEX = 'F' AND strftime('%Y', Birthday) = '1964' AND Admission = '+' ORDER BY ID;
SELECT COUNT(DISTINCT P.ID) FROM Patient P JOIN Examination E ON P.ID = E.ID WHERE E.Thrombosis = 2 AND E.ANA Pattern = 'S' AND E.aCL IgM > (SELECT AVG(aCL IgM) * 1.2 FROM Examination)
WITH NormalProteinuria AS ( SELECT COUNT(*) AS total_patients FROM Laboratory WHERE U-PRO > 0 AND U-PRO < 30),UricAcidBelowNormal AS ( SELECT COUNT(*) AS patients_with_low_UA FROM Laboratory WHERE U-PRO > 0 AND U-PRO < 30 AND UA <= 6.5)SELECT (SELECT patients_with_low_UA FROM UricAcidBelowNormal) * 100.0 / (SELECT total_patients FROM NormalProteinuria) AS percentage
SELECT (SELECT COUNT(*)  FROM Patient p JOIN Examination e ON p.ID = e.ID WHERE p.SEX = 'M'  AND strftime('%Y', p.First Date) = '1981'  AND e.Diagnosis = 'BEHCET') * 100.0 / (SELECT COUNT(*)  FROM Patient p WHERE p.SEX = 'M'  AND strftime('%Y', p.First Date) = '1981') AS Percentage
SELECT P.*FROM Patient AS PINNER JOIN Laboratory AS L ON P.ID = L.IDWHERE P.Admission = '-'   AND L.Date LIKE '1991-10%'   AND L.T-BIL < 2.0
SELECT COUNT(*) FROM Examination AS E INNER JOIN Patient AS P ON E.ID = P.ID WHERE E.ANA Pattern != 'P' AND P.SEX = 'F' AND P.Birthday BETWEEN '1980-01-01' AND '1989-12-31'
SELECT P.SEX FROM Patient AS P JOIN Examination AS E ON P.ID = E.ID JOIN Laboratory AS L ON P.ID = L.ID WHERE E.Diagnosis = 'PSS' AND L.CRP > 2 AND L.CRE = 1 AND L.LDH = 123
SELECT AVG(Laboratory.ALB) FROM Laboratory INNER JOIN Patient ON Laboratory.ID = Patient.ID WHERE Patient.SEX = 'F' AND Patient.Diagnosis = 'SLE' AND Laboratory.PLT > 400
SELECT Symptoms FROM ( SELECT Symptoms, COUNT(*) as symptom_count FROM Examination WHERE Diagnosis = 'SLE' GROUP BY Symptoms) ORDER BY symptom_count DESC LIMIT 1
SELECT Description, Diagnosis FROM Patient WHERE ID = 48473;
SELECT COUNT(*) FROM Patient AS P INNER JOIN Examination AS E ON P.ID = E.ID WHERE P.SEX = 'F' AND E.Diagnosis = 'APS'
SELECT COUNT(DISTINCT P.ID) FROM Laboratory AS L INNER JOIN Patient AS P ON L.ID = P.ID WHERE strftime('%Y', L.Date) = '1997' AND (L.TP <= 6 OR L.TP >= 8.5)
SELECT (SUM(CASE WHEN E.Diagnosis LIKE '%SLE%' THEN 1 ELSE 0 END) * 100.0) / SUM(CASE WHEN E.Symptoms LIKE '%thrombocytopenia%' THEN 1 ELSE 0 END) AS proportionFROM Examination AS EJOIN Patient AS P ON E.ID = P.IDWHERE E.Symptoms LIKE '%thrombocytopenia%'
SELECT (COUNT(CASE WHEN SEX = 'F' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_of_womenFROM PatientWHERE strftime('%Y', Birthday) = '1980' AND Diagnosis = 'RA';
SELECT COUNT(*) FROM Examination AS E INNER JOIN Patient AS P ON E.ID = P.ID WHERE P.SEX = 'M' AND E.Examination Date BETWEEN '1995-01-01' AND '1997-12-31' AND E.Diagnosis = 'BEHCET' AND P.Admission = '-'
SELECT COUNT(*) FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE P.SEX = 'F' AND L.WBC < 3.5
SELECT julianday(E.Examination Date) - julianday(P.First Date) AS Days_BetweenFROM Patient AS PINNER JOIN Examination AS E ON P.ID = E.IDWHERE P.ID = 821298
SELECT CASE  WHEN P.SEX = 'M' AND L.UA > 8.0 THEN 'Normal' WHEN P.SEX = 'F' AND L.UA > 6.5 THEN 'Normal' ELSE 'Not Normal' END AS Uric_Acid_StatusFROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE P.ID = 57266
SELECT L.Date FROM Laboratory AS L INNER JOIN Patient AS P ON L.ID = P.ID WHERE P.ID = 48473 AND L.GOT >= 60
SELECT P.SEX, P.Birthday FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE L.GOT < 60 AND strftime('%Y', L.Date) = '1994'
SELECT DISTINCT P.ID FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE P.SEX = 'M' AND L.GPT >= 60
SELECT P.Diagnosis FROM Laboratory AS L INNER JOIN Patient AS P ON L.ID = P.ID WHERE L.GPT > 60 ORDER BY P.Birthday ASC
SELECT AVG(LDH) FROM Laboratory AS L INNER JOIN Patient AS P ON L.ID = P.ID WHERE L.LDH < 500
SELECT P.ID, (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) AS AgeFROM Patient AS PINNER JOIN Laboratory AS L ON P.ID = L.IDWHERE L.LDH BETWEEN 600 AND 800
SELECT P.Admission, COUNT(*) AS PatientCountFROM Laboratory AS LINNER JOIN Patient AS P ON L.ID = P.IDWHERE L.ALP < 300GROUP BY P.Admission
SELECT P.ID, L.ALP FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE P.Birthday = '1982-04-01' AND L.ALP < 300
SELECT P.ID, P.SEX, P.Birthday FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE L.TP < 6.0
SELECT (Laboratory.TP - 8.5) AS TP_DeviationFROM PatientINNER JOIN Laboratory ON Laboratory.ID = Patient.IDWHERE Patient.SEX = 'F' AND Laboratory.TP > 8.5
SELECT P.ID, P.Birthday, P.SEX, L.ALB FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE P.SEX = 'M' AND (L.ALB <= 3.5 OR L.ALB >= 5.5) ORDER BY P.Birthday DESC
SELECT P.ID, CASE  WHEN L.ALB BETWEEN 3.5 AND 5.5 THEN 'Within Normal Range'  ELSE 'Out of Normal Range' END AS Albumin_StatusFROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE strftime('%Y', P.Birthday) = '1982'
SELECT (SELECT COUNT(*)  FROM Laboratory AS L  INNER JOIN Patient AS P ON L.ID = P.ID  WHERE P.SEX = 'F' AND L.UA > 6.5) * 100.0 / (SELECT COUNT(*) FROM Patient WHERE SEX = 'F') AS percentage_female_with_high_UA Since the original query is already correct in terms of logic and structure, we can return it as is. Final SQL: SELECT (SELECT COUNT(*)  FROM Laboratory AS L  INNER JOIN Patient AS P ON L.ID = P.ID  WHERE P.SEX = 'F' AND L.UA > 6.5) * 100.0 / (SELECT COUNT(*) FROM Patient WHERE SEX = 'F') AS percentage_female_with_high_UA
SELECT AVG(L.UA) AS Average_UAFROM Laboratory LINNER JOIN ( SELECT ID, MAX(Date) AS LatestDate FROM Laboratory GROUP BY ID) AS LatestLab ON L.ID = LatestLab.ID AND L.Date = LatestLab.LatestDateINNER JOIN Patient P ON L.ID = P.IDWHERE (P.SEX = 'M' AND L.UA < 8.0) OR (P.SEX = 'F' AND L.UA < 6.5)
SELECT P.ID, P.SEX, P.Birthday FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE L.UN = 29
SELECT P.ID, P.SEX, P.Birthday FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE P.Diagnosis = 'RA' AND L.UN < 30
SELECT COUNT(*) FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE P.SEX = 'M' AND L.CRE >= 1.5
SELECT (SELECT COUNT(*) FROM Laboratory AS L  INNER JOIN Patient AS P ON L.ID = P.ID  WHERE L.CRE >= 1.5 AND P.SEX = 'M') > (SELECT COUNT(*) FROM Laboratory AS L  INNER JOIN Patient AS P ON L.ID = P.ID  WHERE L.CRE >= 1.5 AND P.SEX = 'F') AS More_Male_Than_Female
SELECT P.ID, P.SEX, P.Birthday FROM Laboratory L JOIN Patient P ON L.ID = P.ID WHERE L.T-BIL = (SELECT MAX(T-BIL) FROM Laboratory)
SELECT P.SEX, COUNT(*) AS Total_PatientsFROM Patient AS PINNER JOIN Laboratory AS L ON P.ID = L.IDWHERE L.T-BIL >= 2.0GROUP BY P.SEX
SELECT P.ID, L.T-CHO FROM Patient AS P JOIN Laboratory AS L ON P.ID = L.ID WHERE L.T-CHO = (SELECT MAX(T-CHO) FROM Laboratory) AND P.Birthday = (SELECT MIN(Birthday) FROM Patient)
SELECT AVG(STRFTIME('%Y', 'now') - STRFTIME('%Y', P.Birthday)) AS average_ageFROM Patient AS PINNER JOIN Laboratory AS L ON P.ID = L.IDWHERE P.SEX = 'M' AND L.T-CHO >= 250
SELECT P.ID, P.Diagnosis FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE L.TG > 300
SELECT COUNT(*) FROM Laboratory AS L INNER JOIN Patient AS P ON L.ID = P.ID WHERE L.TG >= 200 AND (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) > 50
SELECT DISTINCT P.ID FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE P.Admission = '-' AND L.CPK < 250
SELECT COUNT(*) FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE P.Birthday BETWEEN '1936-01-01' AND '1956-12-31' AND P.SEX = 'M' AND L.CPK > 250
SELECT P.ID, P.SEX, (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) AS age FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE L.GLU >= 180 AND L.T-CHO < 250
SELECT P.ID, L.GLU FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE CAST(SUBSTR(P.Description, 1, 4) AS INTEGER) >= 1991 AND L.GLU < 180
SELECT P.ID, P.SEX, P.BirthdayFROM Patient AS PINNER JOIN Laboratory AS L ON P.ID = L.IDWHERE L.WBC <= 3.5 OR L.WBC >= 9.0GROUP BY P.SEXORDER BY strftime('%Y', 'now') - strftime('%Y', P.Birthday) ASC
SELECT P.ID, P.Diagnosis, (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) AS Age FROM Laboratory AS L INNER JOIN Patient AS P ON L.ID = P.ID WHERE L.RBC < 3.5
SELECT Patient.Admission FROM Patient INNER JOIN Laboratory ON Laboratory.ID = Patient.ID WHERE Patient.SEX = 'F' AND (strftime('%Y', 'now') - strftime('%Y', Patient.Birthday)) >= 50 AND (Laboratory.RBC <= 3.5 OR Laboratory.RBC >= 6.0)
SELECT P.ID, P.SEX FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE P.Admission = '-' AND L.HGB < 10
SELECT ID, SEXFROM PatientWHERE ID IN ( SELECT E.ID FROM Examination AS E JOIN Laboratory AS L ON E.ID = L.ID WHERE E.Diagnosis = 'SLE' AND L.HGB > 10 AND L.HGB < 17)ORDER BY Birthday ASCLIMIT 1This query selects the ID and SEX of the oldest patient diagnosed with SLE who has a normal hemoglobin level. It uses a subquery to filter the IDs of patients diagnosed with SLE and then orders the results by Birthday to find the oldest patient.
SELECT P.ID, (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) AS ageFROM Laboratory LJOIN Patient P ON L.ID = P.IDWHERE L.HCT >= 52GROUP BY P.IDHAVING COUNT(L.ID) > 2
SELECT AVG(L.HCT) FROM Laboratory AS L INNER JOIN Patient AS P ON L.ID = P.ID WHERE L.Date LIKE '1991%' AND L.HCT < 29
SELECT (SELECT COUNT(DISTINCT ID) FROM Laboratory WHERE PLT < 100) AS Low_Platelet_Count, (SELECT COUNT(DISTINCT ID) FROM Laboratory WHERE PLT > 400) AS High_Platelet_Count, (SELECT COUNT(DISTINCT ID) FROM Laboratory WHERE PLT < 100) - (SELECT COUNT(DISTINCT ID) FROM Laboratory WHERE PLT > 400) AS Difference
SELECT P.IDFROM Laboratory AS LINNER JOIN Patient AS P ON L.ID = P.IDWHERE L.Date LIKE '1984%'AND (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) < 50AND L.PLT BETWEEN 100 AND 400
SELECT (SUM(CASE WHEN L.PT >= 14 AND P.SEX = 'F' THEN 1 ELSE 0 END) * 1.0 /  NULLIF(COUNT(CASE WHEN P.SEX = 'F' THEN 1 END), 0)) * 100 AS percentage_female_abnormal_PTFROM Patient PJOIN Laboratory L ON P.ID = L.IDWHERE (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) > 55 AND P.SEX = 'F'
SELECT P.*FROM Patient AS PINNER JOIN Laboratory AS L ON P.ID = L.IDWHERE P.First Date > '1992-01-01' AND L.PT < 14
SELECT COUNT(*) FROM Examination AS E JOIN Laboratory AS L ON E.ID = L.ID WHERE E.Examination Date > '1997-01-01' AND L.APTT < 45 Since the original SQL query is already correct in terms of structure and logic (except for the APTT column issue), the final answer is:Revised_SQL: SELECT COUNT(*) FROM Examination AS E JOIN Laboratory AS L ON E.ID = L.ID WHERE E.Examination Date > '1997-01-01' AND L.APTT < 45
SELECT COUNT(DISTINCT P.ID) FROM Laboratory AS L INNER JOIN Patient AS P ON L.ID = P.ID INNER JOIN Examination AS E ON E.ID = P.ID WHERE E.Thrombosis = 3This query counts the distinct patients with mild thrombosis without checking for the abnormal activated partial prothrombin time, as the relevant column is not available.
SELECT COUNT(DISTINCT Patient.ID) FROM Patient INNER JOIN Laboratory ON Laboratory.ID = Patient.ID WHERE Patient.SEX = 'M' AND Laboratory.WBC >= 3.5 AND Laboratory.WBC <= 9.0 AND (Laboratory.FG <= 150 OR Laboratory.FG >= 450)
SELECT COUNT(DISTINCT P.ID) FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE P.Birthday > '1980-01-01' AND (L.FG < 150 OR L.FG > 450)
SELECT DISTINCT P.Diagnosis FROM Laboratory AS L INNER JOIN Patient AS P ON L.ID = P.ID WHERE L.U-PRO >= 30
SELECT P.ID FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE L.U_PRO > 0 AND L.U_PRO < 30 AND P.Diagnosis = 'SLE'
SELECT COUNT(DISTINCT P.ID) FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID INNER JOIN Examination AS E ON P.ID = E.ID WHERE L.IGG < 900 AND E.Symptoms = 'abortion'
SELECT COUNT(DISTINCT E.ID) FROM Examination EINNER JOIN Laboratory L ON E.ID = L.IDWHERE L.IGG BETWEEN 900 AND 2000 AND E.Symptoms IS NOT NULL
SELECT P.Diagnosis FROM Patient P JOIN Examination E ON P.ID = E.ID WHERE E.aCL IgA = (SELECT MAX(aCL IgA) FROM Examination WHERE aCL IgA BETWEEN 80 AND 500);
SELECT COUNT(*) FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE L.IGA BETWEEN 80 AND 500 AND P.First_Date >= '1990-01-01'
SELECT Diagnosis FROM ( SELECT E.Diagnosis, COUNT(*) AS DiagnosisCount FROM Examination AS E WHERE E.aCL IgM NOT BETWEEN 40 AND 400 GROUP BY E.Diagnosis) AS DiagnosisCounts ORDER BY DiagnosisCount DESC LIMIT 1
SELECT COUNT(P.ID) FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE (L.CRP LIKE '+' OR L.CRP LIKE '-' OR L.CRP < 1.0) AND P.Description IS NULL
SELECT COUNT(DISTINCT P.ID) FROM Laboratory AS L INNER JOIN Patient AS P ON L.ID = P.ID WHERE L.CRP NOT IN ('+-', '-') AND L.CRP >= 1.0 AND (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) < 18
SELECT COUNT(DISTINCT P.ID) FROM Patient AS P JOIN Examination AS E ON P.ID = E.ID JOIN Laboratory AS L ON P.ID = L.ID WHERE (L.RA = '-' OR L.RA = '+-') AND E.KCT = '+'
SELECT P.Diagnosis FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE P.Birthday >= '1995-01-01' AND L.RA IN ('-', '+-')
SELECT P.ID FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE L.RF < 20 AND (strftime('%Y', 'now') - strftime('%Y', P.Birthday)) > 60
SELECT COUNT(*) FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID INNER JOIN Examination AS E ON P.ID = E.ID WHERE L.RF < 20 AND E.Thrombosis = 0
SELECT COUNT(DISTINCT P.ID) FROM Patient AS P JOIN Laboratory AS L ON P.ID = L.ID JOIN Examination AS E ON P.ID = E.ID WHERE L.C3 > 35 AND E.ANA Pattern = 'P'
SELECT T1.IDFROM Patient AS T1INNER JOIN Examination AS T2 ON T1.ID = T2.IDINNER JOIN Laboratory AS T3 ON T1.ID = T3.IDWHERE T3.HCT <= 29 OR T3.HCT >= 52ORDER BY T2.aCL IgA DESCLIMIT 1
SELECT COUNT(DISTINCT P.ID) FROM Patient AS P INNER JOIN Examination AS E ON P.ID = E.ID INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE E.Thrombosis >= 1 AND L.C4 > 10
SELECT COUNT(DISTINCT P.ID) FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE (L.RNP = '-' OR L.RNP = '+-') AND P.Admission = '+'
SELECT P.Birthday FROM Patient AS P JOIN Laboratory AS L ON P.ID = L.ID WHERE L.RNP NOT IN ('-', '+-') ORDER BY P.Birthday DESC LIMIT 1
SELECT COUNT(DISTINCT P.ID) FROM Patient AS P JOIN Laboratory AS L ON P.ID = L.ID JOIN Examination AS E ON P.ID = E.ID WHERE E.SM IN ('-', '+-') AND E.Thrombosis = 1
SELECT P.ID FROM Examination AS E INNER JOIN Patient AS P ON E.ID = P.ID WHERE E.SM NOT IN ('-', '+-') ORDER BY P.Birthday DESC LIMIT 3
SELECT DISTINCT P.ID FROM Patient AS P INNER JOIN Examination AS E ON P.ID = E.ID INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE E.Examination Date >= '1997-01-01' AND L.SC170 IN ('-', '+-')
SELECT COUNT(DISTINCT P.ID) FROM Patient AS P JOIN Laboratory AS L ON P.ID = L.ID JOIN Examination AS E ON P.ID = E.ID WHERE P.SEX = 'M' AND (L.SC170 = '-' OR L.SC170 = '+-') AND E.Symptoms LIKE '%vertigo%'
SELECT COUNT(DISTINCT P.ID) FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE L.SSA IN ('-', '+-') AND CAST(SUBSTR(P.First Date, 1, 4) AS INTEGER) < 1990 AND P.Admission = '+'
SELECT P.ID FROM Patient P INNER JOIN Laboratory L ON P.ID = L.ID WHERE L.SSA NOT IN ('-', '+-') ORDER BY P.First Date LIMIT 1
SELECT COUNT(DISTINCT Patient.ID) FROM Patient INNER JOIN Examination ON Patient.ID = Examination.ID WHERE Examination.Diagnosis = 'SLE';
SELECT COUNT(DISTINCT P.ID) FROM Laboratory L JOIN Patient P ON L.ID = P.ID JOIN Examination E ON P.ID = E.ID WHERE L.SSB IN ('-', '+-') AND E.Symptoms IS NOT NULL
SELECT COUNT(*) FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE L.CENTROMEA IN ('-', '+-') AND P.SEX = 'M'
SELECT E.Diagnosis FROM Examination AS E INNER JOIN Patient AS P ON E.ID = P.ID INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE L.DNA >= 8
SELECT COUNT(DISTINCT P.ID) FROM Laboratory AS L INNER JOIN Patient AS P ON L.ID = P.ID WHERE L.DNA < 8 AND P.Description IS NULL
SELECT COUNT(*) FROM Laboratory AS L INNER JOIN Patient AS P ON L.ID = P.ID WHERE L.DNA-II >= 8 AND P.Admission = '+'
SELECT (SELECT COUNT(L.ID)  FROM Laboratory AS L  JOIN Patient AS P ON L.ID = P.ID  WHERE L.GOT >= 60 AND P.Diagnosis = 'SLE') * 1.0 / (SELECT COUNT(L.ID)  FROM Laboratory AS L  WHERE L.GOT >= 60) * 100 AS percentage
SELECT COUNT(*) FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE P.SEX = 'M' AND L.GOT < 60
SELECT MAX(P.Birthday) FROM Laboratory AS L INNER JOIN Patient AS P ON L.ID = P.ID WHERE L.GOT >= 60
SELECT P.Birthday FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE L.GPT < 60 ORDER BY L.GPT DESC LIMIT 3
SELECT COUNT(*) FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE L.GOT < 60 AND P.SEX = 'M'
SELECT MIN(First Date) FROM Patient WHERE ID = (SELECT ID FROM Laboratory WHERE LDH = (SELECT MAX(LDH) FROM Laboratory WHERE LDH < 500))
SELECT MAX(P.First Date) FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE L.LDH >= 500
SELECT COUNT(*) FROM Laboratory AS L INNER JOIN Patient AS P ON L.ID = P.ID WHERE L.ALP >= 300 AND P.Admission = '+'
SELECT COUNT(*) FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE P.Admission = '-' AND L.ALP < 300
SELECT P.Diagnosis FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE L.TP < 6.0
SELECT COUNT(*) FROM Patient AS P INNER JOIN Examination AS E ON P.ID = E.ID INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE P.Diagnosis = 'SJS' AND L.TP > 6.0 AND L.TP < 8.5
SELECT Examination Date FROM Examination INNER JOIN Laboratory ON Examination.ID = Laboratory.ID WHERE Laboratory.ALB = (SELECT MAX(ALB) FROM Laboratory WHERE ALB > 3.5 AND ALB < 5.5)
SELECT COUNT(*) FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE P.SEX = 'M' AND L.ALB > 3.5 AND L.ALB < 5.5 AND L.TP BETWEEN 6.0 AND 8.5
SELECT E.aCL_IgG, E.aCL_IgM, E.aCL_IgA FROM Examination E WHERE E.ID IN (SELECT ID  FROM Laboratory  WHERE UA = (SELECT MAX(UA)   FROM Laboratory   WHERE ID IN (SELECT ID FROM Patient WHERE SEX = 'F') AND UA > 6.5))The final SQL query is correct as is, except for the missing closing parenthesis. The corrected version is provided above.
SELECT MAX(E.ANA) FROM Examination AS E INNER JOIN Laboratory AS L ON E.ID = L.ID WHERE L.CRE < 1.5
SELECT P.ID FROM Patient AS P JOIN Laboratory AS L ON P.ID = L.ID JOIN Examination AS E ON P.ID = E.ID WHERE L.CRE < 1.5 AND E.aCL IgA = (SELECT MAX(aCL IgA) FROM Examination)
SELECT COUNT(DISTINCT P.ID) FROM Laboratory L JOIN Patient P ON L.ID = P.ID JOIN Examination E ON P.ID = E.ID WHERE L.T-BIL >= 2.0 AND E.ANA Pattern LIKE '%P%'
SELECT E.ANA FROM Examination AS E WHERE E.ID IN (SELECT ID FROM Laboratory WHERE T-BIL = (SELECT MAX(T-BIL) FROM Laboratory WHERE T-BIL < 2.0))
SELECT COUNT(*) FROM Laboratory AS L INNER JOIN Examination AS E ON L.ID = E.ID INNER JOIN Patient AS P ON L.ID = P.ID WHERE L.T-CHO >= 250 AND E.KCT = '-'
SELECT COUNT(DISTINCT P.ID) FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID INNER JOIN Examination AS E ON P.ID = E.ID WHERE L.T-CHO < 250 AND E.ANA Pattern = 'P'
SELECT COUNT(DISTINCT P.ID) FROM Patient AS P JOIN Laboratory AS L ON P.ID = L.ID JOIN Examination AS E ON P.ID = E.ID WHERE L.TG < 200 AND E.Symptoms IS NOT NULL
SELECT P.Diagnosis FROM Patient AS P JOIN Laboratory AS L ON P.ID = L.ID WHERE L.TG = (SELECT MAX(TG) FROM Laboratory WHERE TG < 200)
SELECT DISTINCT P.ID FROM Patient AS P INNER JOIN Examination AS E ON P.ID = E.ID INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE E.Thrombosis = 0 AND L.CPK < 250
SELECT COUNT(DISTINCT P.ID) FROM Laboratory AS L JOIN Examination AS E ON L.ID = E.ID JOIN Patient AS P ON L.ID = P.ID WHERE L.CPK < 250 AND (E.KCT = '+' OR E.RVVT = '+' OR E.LAC = '+')
SELECT MIN(P.Birthday) FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE L.GLU > 180
SELECT COUNT(*) FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID INNER JOIN Examination AS E ON P.ID = E.ID WHERE L.GLU < 180 AND E.Thrombosis = 0
SELECT COUNT(*) FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE P.Admission = '+' AND L.WBC BETWEEN 3.5 AND 9.0
SELECT COUNT(DISTINCT P.ID) FROM Patient P INNER JOIN Laboratory L ON P.ID = L.ID WHERE P.Diagnosis = 'SLE' AND L.WBC BETWEEN 3.5 AND 9.0
SELECT P.ID FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE (L.RBC <= 3.5 OR L.RBC >= 6.0) AND P.Admission = '-'
SELECT COUNT(P.ID) FROM Patient P INNER JOIN Laboratory L ON P.ID = L.ID INNER JOIN Examination E ON P.ID = E.ID WHERE L.PLT > 100 AND L.PLT < 400 AND E.Symptoms IS NOT NULL
SELECT L.PLT FROM Laboratory AS L INNER JOIN Patient AS P ON L.ID = P.ID INNER JOIN Examination AS E ON E.ID = P.ID WHERE L.PLT > 100 AND L.PLT < 400 AND E.Diagnosis = 'MCTD'
SELECT AVG(Laboratory.PT) FROM Patient INNER JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE Patient.SEX = 'M' AND Laboratory.PT < 14
SELECT COUNT(*) FROM Patient AS P INNER JOIN Examination AS E ON P.ID = E.ID INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE E.Thrombosis IN (1, 2) AND L.PT < 14
SELECT M2.major_name FROM member AS M1 INNER JOIN major AS M2 ON M1.link_to_major = M2.major_id WHERE M1.first_name = 'Angela' AND M1.last_name = 'Sanders'
SELECT COUNT(*) FROM member AS M INNER JOIN major AS J ON M.link_to_major = J.major_id WHERE J.college = 'College of Engineering'
SELECT T1.first_name || ' ' || T1.last_name AS full_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'Art and Design Department'
SELECT COUNT(DISTINCT T1.link_to_member) FROM attendance AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'Women''s Soccer'
SELECT M.phone FROM attendance AS A INNER JOIN event AS E ON A.link_to_event = E.event_id INNER JOIN member AS M ON A.link_to_member = M.member_id WHERE E.event_name = 'Women''s Soccer'
SELECT COUNT(*) FROM attendance AS A INNER JOIN event AS E ON A.link_to_event = E.event_id INNER JOIN member AS M ON A.link_to_member = M.member_id WHERE E.event_name = 'Women''s Soccer' AND M.t_shirt_size = 'Medium'
SELECT E.event_id, E.event_name, COUNT(A.link_to_member) AS attendance_countFROM attendance AS AINNER JOIN event AS E ON A.link_to_event = E.event_idGROUP BY A.link_to_eventORDER BY attendance_count DESCLIMIT 1
SELECT M.link_to_major, MA.college FROM member AS M INNER JOIN major AS MA ON M.link_to_major = MA.major_id WHERE M.position = 'Vice President'
SELECT event.event_name FROM attendance INNER JOIN event ON attendance.link_to_event = event.event_id INNER JOIN member ON attendance.link_to_member = member.member_id WHERE member.first_name = 'Maya' AND member.last_name = 'Mclean'
SELECT COUNT(*) FROM attendance AS a INNER JOIN event AS e ON a.link_to_event = e.event_id WHERE a.link_to_member = (SELECT member_id FROM member WHERE first_name = 'Sacha' AND last_name = 'Harrison') AND strftime('%Y', e.event_date) = '2019'
SELECT COUNT(*) FROM ( SELECT T1.link_to_event FROM attendance AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id GROUP BY T1.link_to_event HAVING COUNT(T1.link_to_member) > 10 AND T2.type = 'Meeting') AS Subquery
SELECT T1.event_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_id HAVING COUNT(T2.link_to_event) > 20
SELECT CAST(COUNT(T1.link_to_event) AS REAL) / COUNT(DISTINCT T2.event_name) AS average_attendanceFROM attendance AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.type = 'Meeting' AND strftime('%Y', T2.event_date) = '2020'
SELECT expense_description, cost FROM expense WHERE cost = (SELECT MAX(cost) FROM expense) LIMIT 1
SELECT COUNT(*) FROM member AS m INNER JOIN major AS j ON m.link_to_major = j.major_id WHERE j.major_name = 'Environmental Engineering'
SELECT T1.first_name || ' ' || T1.last_name AS full_nameFROM attendance AS T2 INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id INNER JOIN member AS T1 ON T2.link_to_member = T1.member_id WHERE T3.event_name = 'Laugh Out Loud'
SELECT T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Law and Constitutional Studies'
SELECT Z.county FROM member AS M INNER JOIN zip_code AS Z ON M.zip = Z.zip_code WHERE M.first_name = 'Sherri' AND M.last_name = 'Ramsey'
SELECT M2.college FROM member AS M1 INNER JOIN major AS M2 ON M1.link_to_major = M2.major_id WHERE M1.first_name = 'Tyler' AND M1.last_name = 'Hewitt'
SELECT SUM(T1.amount) FROM income AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.position = 'Vice President'
SELECT T1.spent FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Food' AND T2.event_name = 'September Meeting'
SELECT Z.city, Z.state FROM member AS M INNER JOIN zip_code AS Z ON M.zip = Z.zip_code WHERE M.position = 'President'
SELECT T1.first_name || ' ' || T1.last_name AS full_name FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.state = 'Illinois'
SELECT T1.spent FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Advertisement' AND T2.event_name = 'September Meeting'
SELECT DISTINCT MA.department FROM member AS M JOIN major AS MA ON M.link_to_major = MA.major_id WHERE M.first_name = 'Luisa' AND M.last_name = 'Guidi'
SELECT SUM(b.amount) FROM budget AS b INNER JOIN event AS e ON b.link_to_event = e.event_id WHERE e.event_name = 'October Speaker'
SELECT approved FROM expense WHERE link_to_budget IN ( SELECT budget_id FROM budget WHERE link_to_event = ( SELECT event_id  FROM event  WHERE event_name = 'October Meeting' AND event_date = '2019-10-08' )) AND approved = 'true';This ensures that we are only retrieving expenses that were approved for the specified event.
SELECT AVG(cost) FROM expense WHERE link_to_member = (SELECT member_id FROM member WHERE first_name = 'Elijah' AND last_name = 'Allen') AND (strftime('%m', expense_date) = '09' OR strftime('%m', expense_date) = '10')
SELECT (SELECT SUM(b.spent)  FROM budget AS b  INNER JOIN event AS e ON b.link_to_event = e.event_id  WHERE strftime('%Y', e.event_date) = '2019') - (SELECT SUM(b.spent)  FROM budget AS b  INNER JOIN event AS e ON b.link_to_event = e.event_id  WHERE strftime('%Y', e.event_date) = '2020') AS difference
SELECT location FROM event WHERE event_name = 'Spring Budget Review';
SELECT cost FROM expense WHERE expense_description = 'Post Cards, Posters' AND expense_date = '2019-09-04'
SELECT remaining FROM budget WHERE amount = (SELECT MAX(amount) FROM budget WHERE category = 'Food');
SELECT notes FROM income WHERE source = 'Fundraising' AND date_received = '2019-09-14'; This query correctly retrieves the notes associated with the fundraising event on the specified date.
SELECT COUNT(*) FROM major WHERE college = 'College of Humanities and Social Sciences';
SELECT phone FROM member WHERE first_name = 'Carlo' AND last_name = 'Jacobs';
SELECT Z.county FROM member AS M INNER JOIN zip_code AS Z ON M.zip = Z.zip_code WHERE M.first_name = 'Adela' AND M.last_name = 'O''Gallagher'
SELECT COUNT(*) FROM budget AS B INNER JOIN event AS E ON B.link_to_event = E.event_id WHERE E.event_name = 'November Meeting' AND B.remaining < 0
SELECT SUM(b.amount) FROM budget AS b INNER JOIN event AS e ON b.link_to_event = e.event_id WHERE e.event_name = 'September Speaker'
SELECT event_status FROM event WHERE event_id = (SELECT link_to_event FROM budget WHERE budget_id = (SELECT link_to_budget FROM expense WHERE expense_description = 'Post Cards, Posters' AND expense_date = '2019-08-20'))
SELECT M2.major_name FROM member AS M1 INNER JOIN major AS M2 ON M1.link_to_major = M2.major_id WHERE M1.first_name = 'Brent' AND M1.last_name = 'Thomason'
SELECT COUNT(*) FROM member AS M INNER JOIN major AS J ON M.link_to_major = J.major_id WHERE J.major_name = 'Human Development and Family Studies' AND M.t_shirt_size = 'Large'
SELECT Z.type FROM member AS M INNER JOIN zip_code AS Z ON M.zip = Z.zip_code WHERE M.first_name = 'Christof' AND M.last_name = 'Nielson'
SELECT M2.major_name FROM member AS M1 INNER JOIN major AS M2 ON M1.link_to_major = M2.major_id WHERE M1.position = 'Vice President'
SELECT Z.state FROM member AS M INNER JOIN zip_code AS Z ON M.zip = Z.zip_code WHERE M.first_name = 'Sacha' AND M.last_name = 'Harrison'
SELECT M2.department FROM member AS M1 INNER JOIN major AS M2 ON M1.link_to_major = M2.major_id WHERE M1.position = 'President'
SELECT T1.date_received FROM income AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.first_name = 'Connor' AND T2.last_name = 'Hilton' AND T1.source = 'Dues'
SELECT m.first_name, m.last_name FROM member AS m WHERE m.member_id = (SELECT link_to_member FROM income WHERE date_received = (SELECT MIN(date_received) FROM income WHERE source = 'Dues'))
SELECT SUM(CASE WHEN T2.event_name = 'Yearly Kickoff' THEN T1.amount ELSE 0 END) / NULLIF(SUM(CASE WHEN T2.event_name = 'October Meeting' THEN T1.amount ELSE 0 END), 0) AS budget_ratioFROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Advertisement'
SELECT (SUM(CASE WHEN category = 'Parking' THEN amount ELSE 0 END) /  SUM(amount)) * 100 AS parking_percentageFROM budget WHERE link_to_event IN (SELECT event_id FROM event WHERE event_name = 'November Speaker')
`SELECT SUM(cost) AS total_cost FROM expense WHERE expense_description = 'Pizza';`
SELECT COUNT(DISTINCT city) AS number_of_cities FROM zip_code WHERE county = 'Orange County' AND state = 'Virginia';
SELECT * FROM table
SELECT Z.city, Z.county, Z.state FROM member AS M INNER JOIN zip_code AS Z ON M.zip = Z.zip_code WHERE M.first_name = 'Amy' AND M.last_name = 'Firth'
SELECT expense_description FROM expense WHERE link_to_budget = ( SELECT budget_id FROM budget WHERE remaining = (SELECT MIN(remaining) FROM budget))
SELECT M.first_name, M.last_name FROM attendance AS A INNER JOIN event AS E ON A.link_to_event = E.event_id INNER JOIN member AS M ON A.link_to_member = M.member_id WHERE E.event_name = 'October Meeting'
SELECT major.college, COUNT(member.member_id) AS member_count FROM member INNER JOIN major ON member.link_to_major = major.major_id GROUP BY major.college ORDER BY member_count DESC LIMIT 1
SELECT M2.major_name FROM member AS M1 INNER JOIN major AS M2 ON M1.link_to_major = M2.major_id WHERE M1.phone = '809-555-3360'
SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T2.amount = (SELECT MAX(amount) FROM budget)
SELECT T1.expense_description FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.position = 'Vice President'
SELECT COUNT(DISTINCT T1.link_to_member) FROM attendance AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'Women''s Soccer'
SELECT T1.date_received FROM income AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.first_name = 'Casey' AND T2.last_name = 'Mason'
SELECT COUNT(*) FROM member AS M INNER JOIN zip_code AS Z ON M.zip = Z.zip_code WHERE Z.state = 'Maryland'
SELECT COUNT(T1.link_to_event) FROM attendance AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.phone = '954-555-6240'
SELECT T1.first_name || ' ' || T1.last_name AS full_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'School of Applied Sciences, Technology and Education'
SELECT e.event_name, (b.spent / b.amount) AS spend_to_budget_ratioFROM event AS eJOIN budget AS b ON b.link_to_event = e.event_idWHERE e.status = 'Closed'ORDER BY spend_to_budget_ratio DESCLIMIT 1
SELECT COUNT(*) FROM member WHERE position = 'President';
`SELECT MAX(spent) AS highest_amount_spent FROM budget;`
SELECT COUNT(*) FROM event WHERE type = 'Meeting' AND strftime('%Y', event_date) = '2020';
SELECT SUM(spent) AS total_spent FROM budget WHERE category = 'Food';
SELECT T1.first_name || ' ' || T1.last_name AS full_nameFROM member AS T1INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_memberGROUP BY T1.member_idHAVING COUNT(T2.link_to_event) > 7
SELECT m.first_name, m.last_name FROM attendance AS a JOIN member AS m ON a.link_to_member = m.member_id WHERE m.link_to_major = (SELECT major_id FROM major WHERE major_name = 'Interior Design') AND a.link_to_event = (SELECT event_id FROM event WHERE event_name = 'Community Theater')
SELECT T1.first_name || ' ' || T1.last_name AS full_name FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.city = 'Georgetown' AND T2.state = 'South Carolina'
SELECT SUM(T1.amount) FROM income AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.first_name = 'Grant' AND T2.last_name = 'Gilmour'
SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T2.amount > 40
SELECT SUM(e.cost) FROM expense AS e INNER JOIN budget AS b ON e.link_to_budget = b.budget_id INNER JOIN event AS ev ON b.link_to_event = ev.event_id WHERE ev.event_name = 'Yearly Kickoff' If 'Yearly Kickoff' is incorrect and should be 'Baseball game', then the query should be:SELECT SUM(e.cost) FROM expense AS e INNER JOIN budget AS b ON e.link_to_budget = b.budget_id INNER JOIN event AS ev ON b.link_to_event = ev.event_id WHERE ev.event_name = 'Baseball game' Please confirm the correct event name to finalize the query.
SELECT M.first_name, M.last_name FROM budget AS B INNER JOIN event AS E ON B.link_to_event = E.event_id INNER JOIN expense AS Ex ON B.budget_id = Ex.link_to_budget INNER JOIN member AS M ON Ex.link_to_member = M.member_id WHERE E.event_name = 'Yearly Kickoff'
SELECT m.first_name || ' ' || m.last_name AS full_name, i.source FROM income AS i INNER JOIN member AS m ON i.link_to_member = m.member_id WHERE i.amount = (SELECT MAX(amount) FROM income)
SELECT e.event_nameFROM event AS eJOIN budget AS b ON e.event_id = b.link_to_eventJOIN expense AS ex ON b.budget_id = ex.link_to_budgetGROUP BY e.event_idORDER BY SUM(ex.cost) ASCLIMIT 1
SELECT (SUM(exp.cost) / (SELECT SUM(exp2.cost) FROM expense AS exp2)) * 100 AS percentageFROM expense AS expJOIN budget AS bud ON exp.link_to_budget = bud.budget_idJOIN event AS ev ON bud.link_to_event = ev.event_idWHERE ev.event_name = 'Yearly Kickoff'
SELECT (SELECT COUNT(*) FROM member AS m  INNER JOIN major AS j ON m.link_to_major = j.major_id  WHERE j.major_name = 'Finance') * 1.0 / (SELECT COUNT(*) FROM member AS m  INNER JOIN major AS j ON m.link_to_major = j.major_id  WHERE j.major_name = 'Physics') AS ratio
SELECT source, SUM(amount) as total_amount FROM income WHERE date_received BETWEEN '2019-09-01' AND '2019-09-30' GROUP BY source ORDER BY total_amount DESC LIMIT 1
SELECT first_name || ' ' || last_name AS full_name, email FROM member WHERE position = 'Secretary';
SELECT COUNT(*) FROM member AS M INNER JOIN major AS J ON M.link_to_major = J.major_id WHERE J.major_name = 'Physics Teaching'
SELECT COUNT(DISTINCT T1.link_to_member) FROM attendance AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'Community Theater' AND strftime('%Y', T2.event_date) = '2019'
WITH luisa AS ( SELECT member_id, link_to_major FROM member WHERE first_name = 'Luisa' AND last_name = 'Guidi')SELECT (SELECT COUNT(link_to_event) FROM attendance WHERE link_to_member = (SELECT member_id FROM luisa)) AS events_attended, (SELECT major.major_name FROM major WHERE major.major_id = (SELECT link_to_major FROM luisa)) AS major_name
SELECT SUM(T1.spent) / COUNT(T1.spent) AS average_spentFROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Food' AND T2.event_status = 'Closed'This revised query calculates the average spent on food for closed events by dividing the total spent by the count of entries, which aligns with the hint provided.
SELECT e.event_name FROM budget b JOIN event e ON b.link_to_event = e.event_id WHERE b.spent = (SELECT MAX(spent) FROM budget WHERE category = 'Advertisement') AND b.category = 'Advertisement'
SELECT CASE  WHEN COUNT(T1.link_to_member) > 0 THEN 'Yes'  ELSE 'No' END AS attendedFROM attendance AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id INNER JOIN member AS T3 ON T1.link_to_member = T3.member_id WHERE T3.first_name = 'Maya' AND T3.last_name = 'Mclean' AND T2.event_name = 'Women''s Soccer'
SELECT (SUM(CASE WHEN type = 'Community Service' THEN 1 ELSE 0 END) * 100.0 / COUNT(event_id)) AS percentage_shareFROM eventWHERE event_date BETWEEN '2019-01-01' AND '2019-12-31';
SELECT T1.cost FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T1.expense_description LIKE '%Posters%' AND T3.event_name = 'September Speaker' This change uses a LIKE clause to ensure that any expense description containing 'Posters' will be matched, accommodating the actual data.
SELECT t_shirt_size FROM member GROUP BY t_shirt_size ORDER BY COUNT(t_shirt_size) DESC LIMIT 1
SELECT e.event_name FROM event AS e JOIN budget AS b ON b.link_to_event = e.event_id WHERE e.status = 'Closed' AND b.remaining < 0 ORDER BY b.remaining ASC LIMIT 1
SELECT expense.expense_description, SUM(expense.cost) AS total_valueFROM expenseJOIN budget ON expense.link_to_budget = budget.budget_idJOIN event ON budget.link_to_event = event.event_idWHERE event.event_name = 'October Meeting' AND expense.approved = 'true'GROUP BY expense.expense_description
SELECT T1.category, T1.amount FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'April Speaker' ORDER BY T1.amount ASC
SELECT budget_id, category, amount FROM budget WHERE category = 'Food' ORDER BY amount DESC LIMIT 1;
SELECT budget_id, category, amount FROM budget WHERE category = 'Advertisement' ORDER BY amount DESC LIMIT 3
SELECT SUM(T1.cost) FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id WHERE T2.category = 'Parking'
`SELECT SUM(cost) AS total_expense FROM expense WHERE expense_date = '2019-08-20';`
SELECT T1.first_name || ' ' || T1.last_name AS full_name, SUM(T2.cost) AS total_cost FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.member_id = 'rec4BLdZHS2Blfp4v' GROUP BY T1.first_name, T1.last_name
SELECT T1.expense_description FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.first_name = 'Sacha' AND T2.last_name = 'Harrison'
SELECT T1.expense_description FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.t_shirt_size = 'X-Large'
SELECT M.zip FROM expense AS E INNER JOIN member AS M ON E.link_to_member = M.member_id WHERE E.cost < 50
SELECT M2.major_name FROM member AS M1 INNER JOIN major AS M2 ON M1.link_to_major = M2.major_id WHERE M1.first_name = 'Phillip' AND M1.last_name = 'Cullen'
SELECT T1.position FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Business'
SELECT COUNT(*) FROM member AS m INNER JOIN major AS j ON m.link_to_major = j.major_id WHERE j.major_name = 'Business' AND m.t_shirt_size = 'Medium'
SELECT DISTINCT type FROM budget INNER JOIN event ON budget.link_to_event = event.event_id WHERE budget.remaining > 30
SELECT DISTINCT B.category FROM event AS E INNER JOIN budget AS B ON E.event_id = B.link_to_event WHERE E.location = 'MU 215'
SELECT B.category FROM event AS E INNER JOIN budget AS B ON B.link_to_event = E.event_id WHERE E.event_date = '2020-03-24T12:00:00'
SELECT M2.major_name FROM member AS M1 INNER JOIN major AS M2 ON M1.link_to_major = M2.major_id WHERE M1.position = 'Vice President'
SELECT (SELECT COUNT(m.member_id)  FROM member AS m  INNER JOIN major AS j ON m.link_to_major = j.major_id  WHERE j.major_name = 'Mathematics' AND m.position = 'Member') * 100.0 / (SELECT COUNT(member_id) FROM member) AS percentage_of_math_members
SELECT DISTINCT B.category FROM event AS E INNER JOIN budget AS B ON E.event_id = B.link_to_event WHERE E.location = 'MU 215'
`SELECT COUNT(*) FROM income WHERE amount = 50;`
`SELECT COUNT(*) FROM member WHERE position = 'Member' AND t_shirt_size = 'X-Large';`
SELECT COUNT(*) FROM major WHERE department = 'School of Applied Sciences, Technology and Education' AND college = 'College of Agriculture and Applied Sciences';
SELECT M.last_name, J.department, J.college FROM member AS M INNER JOIN major AS J ON M.link_to_major = J.major_id WHERE J.major_name = 'Environmental Engineering'
SELECT B.category FROM budget AS B INNER JOIN event AS E ON B.link_to_event = E.event_id WHERE E.location = 'MU 215' AND E.type = 'Guest Speaker' AND B.spent = 0
SELECT zip_code.city, zip_code.state FROM member INNER JOIN major ON member.link_to_major = major.major_id INNER JOIN zip_code ON member.zip = zip_code.zip_code WHERE major.department = 'Electrical and Computer Engineering' AND member.position = 'Member' Since the only issue was the department name, the final query remains unchanged as it is already correct.
SELECT T1.event_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.type = 'Social' AND T3.position = 'Vice President' AND T1.location = '900 E. Washington St.'
SELECT M.last_name, M.position FROM expense AS E INNER JOIN member AS M ON E.link_to_member = M.member_id WHERE E.expense_description = 'Pizza' AND E.expense_date = '2019-09-10'
SELECT T3.last_name FROM attendance AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id INNER JOIN member AS T3 ON T1.link_to_member = T3.member_id WHERE T3.position = 'Member' AND T2.event_name = 'Women\'s Soccer'
SELECT (COUNT(CASE WHEN i.amount = 50 THEN 1 END) * 100.0 / COUNT(m.member_id)) AS percentageFROM member m LEFT JOIN income i ON m.member_id = i.link_to_member WHERE m.t_shirt_size = 'Medium' AND m.position = 'Member'This revised query correctly calculates the percentage of members with a t-shirt size of medium who received an amount of 50.
SELECT DISTINCT state FROM zip_code WHERE type = 'PO Box';
SELECT zip_code FROM zip_code WHERE type = 'PO Box' AND county = 'San Juan Municipio' AND state = 'Puerto Rico';
SELECT event_name FROM event WHERE type = 'Game' AND status = 'Closed' AND event_date BETWEEN '2019-03-15' AND '2020-03-20';
SELECT DISTINCT link_to_event FROM attendance WHERE link_to_member IN (SELECT DISTINCT link_to_member FROM expense WHERE cost > 50)
SELECT M.member_id, M.first_name, M.last_name, A.link_to_event FROM expense AS E JOIN attendance AS A ON E.link_to_member = A.link_to_member JOIN member AS M ON A.link_to_member = M.member_id WHERE E.approved = 'true' AND E.expense_date BETWEEN '2019-01-10' AND '2019-11-19'
SELECT M2.college FROM member AS M1 INNER JOIN major AS M2 ON M1.link_to_major = M2.major_id WHERE M1.first_name = 'Katy' AND M1.link_to_major = 'rec1N0upiVLy5esTO'
SELECT M.phone FROM member AS M INNER JOIN major AS J ON M.link_to_major = J.major_id WHERE J.major_name = 'Business' AND J.college = 'College of Agriculture and Applied Sciences'
SELECT M.email FROM expense AS E INNER JOIN member AS M ON E.link_to_member = M.member_id WHERE E.expense_date BETWEEN '2019-09-10' AND '2019-11-19' AND E.cost > 20
SELECT COUNT(*) FROM member AS M INNER JOIN major AS J ON M.link_to_major = J.major_id WHERE J.major_name = 'education' AND J.college = 'College of Education & Human Services' AND M.position = 'Member'
SELECT (CAST(SUM(CASE WHEN remaining < 0 THEN 1 ELSE 0 END) AS FLOAT) / COUNT(DISTINCT link_to_event)) * 100 AS percentage_over_budget FROM budget
SELECT event_id, location, status FROM event WHERE event_date BETWEEN '2019-11-01' AND '2020-03-31';
SELECT expense_description FROM expense GROUP BY expense_description HAVING SUM(cost) / COUNT(expense_id) > 50
SELECT first_name || ' ' || last_name AS full_name FROM member WHERE t_shirt_size = 'X-Large'
SELECT (SUM(CASE WHEN type = 'PO Box' THEN 1 ELSE 0 END) * 100.0 / COUNT(zip_code)) AS percentage_po_boxesFROM zip_code;
SELECT E.event_name, E.location FROM event AS E INNER JOIN budget AS B ON B.link_to_event = E.event_id WHERE B.remaining > 0
SELECT E.event_name, E.event_date FROM expense AS Ex INNER JOIN budget AS B ON Ex.link_to_budget = B.budget_id INNER JOIN event AS E ON B.link_to_event = E.event_id WHERE Ex.expense_description = 'Pizza' AND Ex.cost > 50 AND Ex.cost < 100
SELECT m.first_name || ' ' || m.last_name AS full_name, maj.major_name FROM expense AS e JOIN member AS m ON e.link_to_member = m.member_id JOIN major AS maj ON m.link_to_major = maj.major_id WHERE e.cost > 100
SELECT Z.city, Z.countyFROM income AS IJOIN member AS M ON I.link_to_member = M.member_idJOIN zip_code AS Z ON M.zip = Z.zip_codeJOIN expense AS E ON I.link_to_member = E.link_to_memberJOIN budget AS B ON E.link_to_budget = B.budget_idWHERE B.link_to_event IN (SELECT event_id FROM event)GROUP BY B.link_to_eventHAVING COUNT(I.income_id) > 40
SELECT T1.link_to_member, SUM(T2.cost) AS total_paidFROM ( SELECT link_to_member FROM expense GROUP BY link_to_member HAVING COUNT(DISTINCT link_to_budget) > 1) AS T1JOIN expense AS T2 ON T1.link_to_member = T2.link_to_memberGROUP BY T1.link_to_memberORDER BY total_paid DESCLIMIT 1However, since the original query is already using `link_to_budget` in the subquery, it should be corrected to use `link_to_event` instead. So the final corrected SQL query is:SELECT T1.link_to_member, SUM(T2.cost) AS total_paidFROM ( SELECT link_to_member FROM expense GROUP BY link_to_member HAVING COUNT(DISTINCT link_to_budget) > 1) AS T1JOIN expense AS T2 ON T1.link_to_member = T2.link_to_memberGROUP BY T1.link_to_memberORDER BY total_paid DESCLIMIT 1This query will now correctly find the member who incurred expenses in more than one event and paid the most amount.
SELECT AVG(cost) AS average_amount_paidFROM expense AS eINNER JOIN member AS m ON e.link_to_member = m.member_idWHERE m.position != 'Member'
SELECT e.event_name FROM event AS e JOIN budget AS b ON b.link_to_event = e.event_id JOIN expense AS ex ON ex.link_to_budget = b.budget_id WHERE ex.cost < (SELECT AVG(ex2.cost)    FROM expense AS ex2    JOIN budget AS b2 ON ex2.link_to_budget = b2.budget_id    WHERE b2.category = 'Parking')
SELECT (SUM(e.cost) / COUNT(DISTINCT ev.event_id)) * 100 AS percentage_cost FROM event ev JOIN budget b ON ev.event_id = b.link_to_event JOIN expense e ON b.budget_id = e.link_to_budget WHERE ev.type = 'Game'
SELECT B.* FROM budget AS B INNER JOIN expense AS E ON E.link_to_budget = B.budget_id WHERE E.expense_description = 'Water, chips, cookies' AND E.cost = (SELECT MAX(cost) FROM expense WHERE expense_description = 'Water, chips, cookies')
SELECT m.first_name || ' ' || m.last_name AS full_name, SUM(e.cost) AS total_spentFROM member AS mJOIN expense AS e ON m.member_id = e.link_to_memberGROUP BY m.member_idORDER BY total_spent DESCLIMIT 5
SELECT m.first_name || ' ' || m.last_name AS full_name, m.phone FROM member AS m JOIN expense AS e ON e.link_to_member = m.member_id WHERE e.cost > (SELECT AVG(cost) FROM expense)
SELECT (  (SELECT COUNT(*) FROM member WHERE position = 'Member' AND zip IN (SELECT zip_code FROM zip_code WHERE state = 'Maine')) * 1.0 /  (SELECT COUNT(*) FROM member WHERE position = 'Member') ) - (  (SELECT COUNT(*) FROM member WHERE position = 'Member' AND zip IN (SELECT zip_code FROM zip_code WHERE state = 'Vermont')) * 1.0 /  (SELECT COUNT(*) FROM member WHERE position = 'Member') ) AS percentage_difference
SELECT M.major_name, M.department FROM member AS mem INNER JOIN major AS M ON mem.link_to_major = M.major_id WHERE mem.first_name = 'Garrett' AND mem.last_name = 'Gerke'
SELECT M.first_name || ' ' || M.last_name AS full_name, E.costFROM expense AS EINNER JOIN member AS M ON E.link_to_member = M.member_idWHERE E.expense_description = 'Water, veggie tray and supplies'
SELECT M.last_name, M.phone FROM member AS M INNER JOIN major AS J ON M.link_to_major = J.major_id WHERE J.major_name = 'Elementary Education'
SELECT B.category, B.amount FROM budget AS B INNER JOIN event AS E ON B.link_to_event = E.event_id WHERE E.event_name = 'January Speaker'
SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T2.category = 'Food'
SELECT T1.first_name || ' ' || T1.last_name AS full_name, T2.amount FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T2.date_received = '2019-09-09'Since the date format in the SQL is already correct, the final query remains unchanged. Final SQL Query: SELECT T1.first_name || ' ' || T1.last_name AS full_name, T2.amount FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T2.date_received = '2019-09-09' Thus, the original SQL query is correct as is.
SELECT B.category FROM budget AS B INNER JOIN expense AS E ON E.link_to_budget = B.budget_id WHERE E.expense_description = 'Post Cards, Posters'
SELECT T1.first_name || ' ' || T1.last_name AS full_name, T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.position = 'Secretary'
SELECT T1.event_name, SUM(T2.spent) AS total_spentFROM budget AS T2INNER JOIN event AS T1 ON T2.link_to_event = T1.event_idWHERE T2.category = 'Speaker Gifts'GROUP BY T1.event_name
SELECT Z.city FROM member AS M INNER JOIN zip_code AS Z ON M.zip = Z.zip_code WHERE M.first_name = 'Garrett' AND M.last_name = 'Girke'
SELECT T1.first_name, T1.last_name, T1.position FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.city = 'Lincolnton' AND T2.state = 'North Carolina' AND T2.zip_code = 28092
SELECT COUNT(*) FROM gasstations WHERE Country = 'CZE' AND Segment = 'Premium';
SELECT CAST(SUM(CASE WHEN Currency = 'EUR' THEN 1 ELSE 0 END) AS REAL) / NULLIF(SUM(CASE WHEN Currency = 'CZK' THEN 1 ELSE 0 END), 0) AS ratio FROM customers
SELECT T1.CustomerID, SUM(T2.Consumption) AS TotalConsumption FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM' AND T2.Date BETWEEN '201201' AND '201212' GROUP BY T1.CustomerID ORDER BY TotalConsumption ASC LIMIT 1
SELECT AVG(T1.Consumption) / 12 FROM yearmonth AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Segment = 'SME' AND T1.Date BETWEEN '201301' AND '201312'
SELECT C.CustomerID, SUM(Y.Consumption) AS TotalConsumptionFROM customers AS CINNER JOIN yearmonth AS Y ON C.CustomerID = Y.CustomerIDWHERE C.Currency = 'CZK' AND Y.Date BETWEEN '201101' AND '201112'GROUP BY C.CustomerIDORDER BY TotalConsumption DESC
SELECT COUNT(DISTINCT C.CustomerID) FROM customers AS C INNER JOIN yearmonth AS Y ON C.CustomerID = Y.CustomerID WHERE C.Segment = 'KAM' AND Y.Consumption < 30000 AND Y.Date BETWEEN '201201' AND '201212'
SELECT (SELECT SUM(y.Consumption)  FROM yearmonth AS y  JOIN customers AS c ON y.CustomerID = c.CustomerID  WHERE c.Currency = 'CZK' AND y.Date BETWEEN '201201' AND '201212') - (SELECT SUM(y.Consumption)  FROM yearmonth AS y  JOIN customers AS c ON y.CustomerID = c.CustomerID  WHERE c.Currency = 'EUR' AND y.Date BETWEEN '201201' AND '201212') AS ConsumptionDifference
SELECT SUBSTR(T1.Date, 1, 4) AS Year, SUM(T1.Consumption) AS TotalConsumptionFROM yearmonth AS T1INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerIDWHERE T2.Currency = 'EUR'GROUP BY YearORDER BY TotalConsumption DESCLIMIT 1
SELECT c.Segment, SUM(ym.Consumption) AS TotalConsumptionFROM yearmonth AS ymINNER JOIN customers AS c ON ym.CustomerID = c.CustomerIDGROUP BY c.SegmentORDER BY TotalConsumption ASCLIMIT 1
SELECT YearFROM ( SELECT SUBSTR(Date, 1, 4) AS Year, SUM(Consumption) AS TotalConsumption FROM yearmonth WHERE CustomerID IN (SELECT CustomerID FROM customers WHERE Currency = 'CZK') GROUP BY Year) AS YearlyConsumptionORDER BY TotalConsumption DESCLIMIT 1
SELECT SUBSTR(y.Date, 5, 2) AS Month, SUM(y.Consumption) AS TotalConsumptionFROM yearmonth AS yJOIN customers AS c ON y.CustomerID = c.CustomerIDWHERE c.Segment = 'SME' AND y.Date LIKE '2013%'GROUP BY MonthORDER BY TotalConsumption DESCLIMIT 1
WITH LeastConsumption AS ( SELECT  c.Segment, y.CustomerID, MIN(y.Consumption) AS MinConsumption FROM  yearmonth y JOIN  customers c ON y.CustomerID = c.CustomerID WHERE  y.Date BETWEEN '201301' AND '201312'  AND c.Currency = 'CZK' GROUP BY  c.Segment),AnnualAverage AS ( SELECT  c.Segment, SUM(y.Consumption) / COUNT(y.CustomerID) AS AnnualAverageConsumption FROM  yearmonth y JOIN  customers c ON y.CustomerID = c.CustomerID WHERE  y.Date BETWEEN '201301' AND '201312'  AND c.Currency = 'CZK' AND y.CustomerID IN (SELECT CustomerID FROM LeastConsumption) GROUP BY  c.Segment)SELECT COALESCE((SELECT AnnualAverageConsumption FROM AnnualAverage WHERE Segment = 'SME'), 0) - COALESCE((SELECT AnnualAverageConsumption FROM AnnualAverage WHERE Segment = 'LAM'), 0) AS SME_LAM_Difference, COALESCE((SELECT AnnualAverageConsumption FROM AnnualAverage WHERE Segment = 'LAM'), 0) - COALESCE((SELECT AnnualAverageConsumption FROM AnnualAverage WHERE Segment = 'KAM'), 0) AS LAM_KAM_Difference, COALESCE((SELECT AnnualAverageConsumption FROM AnnualAverage WHERE Segment = 'KAM'), 0) - COALESCE((SELECT AnnualAverageConsumption FROM AnnualAverage WHERE Segment = 'SME'), 0) AS KAM_SME_Difference
WITH Consumption AS ( SELECT  c.Segment, SUM(ym.Consumption) AS TotalConsumption FROM  yearmonth ym JOIN  customers c ON ym.CustomerID = c.CustomerID WHERE  ym.Date BETWEEN '201201' AND '201312' AND c.Currency = 'EUR' GROUP BY  c.Segment),ConsumptionChange AS ( SELECT  Segment, MAX(CASE WHEN ym.Date BETWEEN '201201' AND '201212' THEN TotalConsumption END) AS Consumption2012, MAX(CASE WHEN ym.Date BETWEEN '201301' AND '201312' THEN TotalConsumption END) AS Consumption2013 FROM  Consumption GROUP BY  Segment)SELECT Segment, ((Consumption2013 - Consumption2012) / NULLIF(Consumption2013, 0)) * 100 AS PercentageIncreaseFROM ConsumptionChangeWHERE Consumption2012 IS NOT NULL AND Consumption2013 IS NOT NULLORDER BY PercentageIncrease DESC;
SELECT SUM(Consumption) FROM yearmonth WHERE CustomerID = 6 AND Date BETWEEN '201308' AND '201311'
SELECT (SELECT COUNT(*) FROM gasstations WHERE Segment = 'discount' AND Country = 'CZE') - (SELECT COUNT(*) FROM gasstations WHERE Segment = 'discount' AND Country = 'SVK') AS more_discount_gas_stations
SELECT (SELECT Consumption FROM yearmonth WHERE CustomerID = 7 AND Date = '201304') - (SELECT Consumption FROM yearmonth WHERE CustomerID = 5 AND Date = '201304') AS ConsumptionDifference
SELECT COUNT(DISTINCT t.CustomerID) AS SMEs_using_EURFROM transactions_1k AS t JOIN customers AS c ON t.CustomerID = c.CustomerID WHERE c.Segment = 'SME' AND c.Currency = 'EUR';
SELECT T1.CustomerID, T2.Consumption FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM' AND T1.Currency = 'EUR' AND T2.Date = '201310' ORDER BY T2.Consumption DESC LIMIT 1
SELECT y.CustomerID, MAX(y.Consumption) AS MaxConsumption FROM yearmonth y INNER JOIN customers c ON y.CustomerID = c.CustomerID WHERE c.Segment = 'KAM' GROUP BY y.CustomerID ORDER BY MaxConsumption DESC LIMIT 1
SELECT SUM(YM.Consumption) FROM yearmonth AS YM INNER JOIN customers AS C ON YM.CustomerID = C.CustomerID WHERE C.Segment = 'KAM' AND YM.Date = '201305'
SELECT (COUNT(DISTINCT y.CustomerID) * 100.0 / (SELECT COUNT(CustomerID) FROM customers WHERE Segment = 'LAM')) AS PercentageFROM yearmonth AS y JOIN customers AS c ON y.CustomerID = c.CustomerID WHERE c.Segment = 'LAM' AND y.Consumption > 46.73
SELECT Country, COUNT(*) AS TotalValueForMoneyGasStations FROM gasstations WHERE Segment = 'Value for money' GROUP BY Country ORDER BY TotalValueForMoneyGasStations DESC
SELECT (CAST((SELECT COUNT(*) FROM customers WHERE Segment = 'KAM' AND Currency = 'EUR') AS REAL) /  NULLIF((SELECT COUNT(*) FROM customers WHERE Segment = 'KAM'), 0)) * 100 AS Percentage
SELECT (COUNT(DISTINCT CASE WHEN y.Consumption > 528.3 THEN y.CustomerID END) * 100.0) / COUNT(DISTINCT c.CustomerID) AS percentageFROM yearmonth yJOIN customers c ON y.CustomerID = c.CustomerIDWHERE y.Date = '201202'
SELECT (COUNT(CASE WHEN Segment = 'Premium' THEN 1 END) * 100.0 / COUNT(*)) AS premium_percentageFROM gasstationsWHERE Country = 'SVK';
SELECT CustomerID FROM yearmonth WHERE Date = '201309' ORDER BY Consumption DESC LIMIT 1
SELECT C.Segment, SUM(Y.Consumption) AS TotalConsumptionFROM customers AS CINNER JOIN yearmonth AS Y ON C.CustomerID = Y.CustomerIDWHERE Y.Date = '201309'GROUP BY C.SegmentORDER BY TotalConsumption ASCLIMIT 1
SELECT y.CustomerID, y.Consumption FROM yearmonth AS y INNER JOIN customers AS c ON y.CustomerID = c.CustomerID WHERE c.Segment = 'SME' AND y.Date = '201206' ORDER BY y.Consumption ASC LIMIT 1
SELECT MAX(Consumption) AS HighestConsumptionFROM yearmonthWHERE Date LIKE '2012%';
SELECT MAX(total_consumption / 12) AS biggest_monthly_consumptionFROM ( SELECT SUM(Consumption) AS total_consumption FROM yearmonth AS ym INNER JOIN customers AS c ON ym.CustomerID = c.CustomerID WHERE c.Currency = 'EUR' GROUP BY ym.CustomerID)
SELECT P.Description FROM products AS P INNER JOIN transactions_1k AS T ON P.ProductID = T.ProductID INNER JOIN yearmonth AS Y ON T.CustomerID = Y.CustomerID WHERE Y.Date = '201309'
SELECT DISTINCT G.Country FROM transactions_1k AS T INNER JOIN gasstations AS G ON T.GasStationID = G.GasStationID WHERE T.Date LIKE '201306%'
SELECT DISTINCT g.ChainID FROM transactions_1k t INNER JOIN customers c ON t.CustomerID = c.CustomerID INNER JOIN gasstations g ON t.GasStationID = g.GasStationID WHERE c.Currency = 'EUR'
SELECT P.Description FROM transactions_1k AS T INNER JOIN customers AS C ON T.CustomerID = C.CustomerID INNER JOIN products AS P ON T.ProductID = P.ProductID WHERE C.Currency = 'EUR'
SELECT AVG(Price) AS AverageTotalPrice FROM transactions_1k WHERE Date LIKE '2012-01%';
SELECT COUNT(DISTINCT c.CustomerID) FROM customers AS c INNER JOIN yearmonth AS ym ON c.CustomerID = ym.CustomerID WHERE c.Currency = 'EUR' AND ym.Consumption > 1000
SELECT products.Description FROM transactions_1k INNER JOIN gasstations ON transactions_1k.GasStationID = gasstations.GasStationID INNER JOIN products ON transactions_1k.ProductID = products.ProductID WHERE gasstations.Country = 'CZE'
SELECT DISTINCT T1.Time FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.ChainID = 11
SELECT COUNT(*) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.Country = 'CZE' AND T1.Price > 1000
SELECT COUNT(*) FROM transactions_1k AS T1 INNER JOIN gasstations AS G ON T1.GasStationID = G.GasStationID WHERE G.Country = 'CZE' AND T1.Date > '2012-01-01'
SELECT AVG(T1.Price) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.Country = 'CZE'
SELECT AVG(T2.Price) FROM customers AS T1 INNER JOIN transactions_1k AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'EUR'
SELECT C.CustomerID, SUM(T.Price) AS TotalPaidFROM transactions_1k AS TINNER JOIN customers AS C ON T.CustomerID = C.CustomerIDWHERE T.Date = '2012-08-25'GROUP BY C.CustomerIDORDER BY TotalPaid DESCLIMIT 1
SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' ORDER BY T1.TransactionID LIMIT 1
SELECT C.Currency FROM customers AS C INNER JOIN transactions_1k AS T ON C.CustomerID = T.CustomerID WHERE T.Date = '2012-08-24' AND T.Time = '16:25:00'
SELECT T2.Segment FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-23' AND T1.Time = '21:20:00'
SELECT COUNT(T1.TransactionID) FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-26' AND T1.Time < '13:00:00' AND T2.Currency = 'EUR'
SELECT Segment FROM customers WHERE CustomerID = (SELECT MIN(CustomerID) FROM customers);
SELECT g.Country FROM transactions_1k AS t INNER JOIN gasstations AS g ON t.GasStationID = g.GasStationID WHERE t.Date = '2012-08-24' AND t.Time = '12:42:00'
SELECT ProductID FROM transactions_1k WHERE Date = '2012-08-23' AND Time = '21:20:00';
SELECT Date, Consumption FROM yearmonth WHERE CustomerID = (SELECT CustomerID  FROM transactions_1k  WHERE Date = '2012-08-24' AND Price = 124.05) AND Date LIKE '201201%'
SELECT COUNT(T1.TransactionID) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-26' AND T1.Time BETWEEN '08:00:00' AND '09:00:00' AND T2.Country = 'CZE'
SELECT C.Currency FROM customers AS C JOIN yearmonth AS Y ON C.CustomerID = Y.CustomerID WHERE Y.Date = '201306' AND Y.Consumption = 214582.17
SELECT g.Country FROM transactions_1k AS t INNER JOIN gasstations AS g ON t.GasStationID = g.GasStationID WHERE t.CardID = 667467
SELECT C.Currency FROM transactions_1k AS T INNER JOIN customers AS C ON T.CustomerID = C.CustomerID WHERE T.Date = '2012-08-24' AND (T.Amount * T.Price) = 548.4
SELECT CAST(COUNT(DISTINCT CASE WHEN C.Currency = 'EUR' THEN C.CustomerID END) AS REAL) * 100 / COUNT(DISTINCT C.CustomerID) AS percentageFROM customers AS C LEFT JOIN transactions_1k AS T ON C.CustomerID = T.CustomerID WHERE T.Date = '2012-08-25'
SELECT (MAX(CASE WHEN Date LIKE '2012%' THEN Consumption END) -  MAX(CASE WHEN Date LIKE '2013%' THEN Consumption END)) / MAX(CASE WHEN Date LIKE '2012%' THEN Consumption END) AS consumption_decrease_rateFROM yearmonth WHERE CustomerID = (SELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-25' AND Price = 634.8)
SELECT T1.GasStationID, SUM(T2.Amount * T2.Price) AS TotalRevenueFROM gasstations AS T1INNER JOIN transactions_1k AS T2 ON T1.GasStationID = T2.GasStationIDGROUP BY T1.GasStationIDORDER BY TotalRevenue DESCLIMIT 1
SELECT (COUNT(CASE WHEN g.Segment = 'Premium' THEN t.TransactionID END) * 100.0 / COUNT(t.TransactionID)) AS premium_percentageFROM gasstations gJOIN transactions_1k t ON g.GasStationID = t.GasStationIDWHERE g.Country = 'SVK';
SELECT SUM(Amount) AS AmountSpentInJanuary FROM transactions_1k WHERE CustomerID = 38508 AND Date BETWEEN '2012-01-01' AND '2012-01-31';
SELECT P.Description FROM products AS P INNER JOIN transactions_1k AS T ON P.ProductID = T.ProductID GROUP BY P.ProductID ORDER BY SUM(T.Amount) DESC LIMIT 5
SELECT c.CustomerID, c.Currency, SUM(t.Price) / SUM(t.Amount) AS AveragePricePerItemFROM transactions_1k AS tJOIN customers AS c ON t.CustomerID = c.CustomerIDWHERE t.CustomerID = ( SELECT CustomerID FROM ( SELECT CustomerID, SUM(Price) AS TotalSpending FROM transactions_1k GROUP BY CustomerID ) AS Spending ORDER BY TotalSpending DESC LIMIT 1)GROUP BY c.CustomerID, c.Currency
SELECT g.Country FROM gasstations AS g INNER JOIN transactions_1k AS t ON g.GasStationID = t.GasStationID WHERE t.Price = (SELECT MAX(Price)    FROM transactions_1k    WHERE ProductID = 2 AND Amount = 1) AND t.ProductID = 2 AND t.Amount = 1
SELECT y.CustomerID, y.Consumption FROM yearmonth AS y WHERE y.Date = '201208' AND y.CustomerID IN ( SELECT CustomerID FROM transactions_1k WHERE ProductID = 5 AND (Price / Amount) > 29.00)
